
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * Tenant represents an organization or team
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * User represents a user within a tenant
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Protocol
 * A Protocol represents a complete training methodology or system
 */
export type Protocol = $Result.DefaultSelection<Prisma.$ProtocolPayload>
/**
 * Model Block
 * A Block represents a specific phase or period within a Protocol
 * Examples: "Base Building", "Peak Phase", "Deload Week", "Strength Block"
 */
export type Block = $Result.DefaultSelection<Prisma.$BlockPayload>
/**
 * Model BlockSession
 * A BlockSession represents a specific training session within a Block
 */
export type BlockSession = $Result.DefaultSelection<Prisma.$BlockSessionPayload>
/**
 * Model BlockProgression
 * A BlockProgression defines how a Block progresses over time
 */
export type BlockProgression = $Result.DefaultSelection<Prisma.$BlockProgressionPayload>
/**
 * Model ProtocolPermission
 * ProtocolPermission manages fine-grained access control
 */
export type ProtocolPermission = $Result.DefaultSelection<Prisma.$ProtocolPermissionPayload>
/**
 * Model AuditLog
 * AuditLog tracks all security-relevant operations
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model ProtocolTemplate
 * A ProtocolTemplate is a pre-configured Protocol with specific parameters
 */
export type ProtocolTemplate = $Result.DefaultSelection<Prisma.$ProtocolTemplatePayload>
/**
 * Model ProtocolExecution
 * A ProtocolExecution represents a user's execution of a Protocol
 */
export type ProtocolExecution = $Result.DefaultSelection<Prisma.$ProtocolExecutionPayload>
/**
 * Model BlockExecution
 * A BlockExecution represents execution of a specific Block
 */
export type BlockExecution = $Result.DefaultSelection<Prisma.$BlockExecutionPayload>
/**
 * Model SessionExecution
 * A SessionExecution represents execution of a specific training session
 */
export type SessionExecution = $Result.DefaultSelection<Prisma.$SessionExecutionPayload>
/**
 * Model ProtocolAnalytics
 * ProtocolAnalytics tracks performance and usage metrics
 */
export type ProtocolAnalytics = $Result.DefaultSelection<Prisma.$ProtocolAnalyticsPayload>
/**
 * Model ProtocolShare
 * ProtocolShare represents shared protocols between users
 */
export type ProtocolShare = $Result.DefaultSelection<Prisma.$ProtocolSharePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Visibility: {
  PRIVATE: 'PRIVATE',
  TENANT: 'TENANT',
  PUBLIC: 'PUBLIC'
};

export type Visibility = (typeof Visibility)[keyof typeof Visibility]


export const PermissionRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  EDITOR: 'EDITOR',
  VIEWER: 'VIEWER',
  GUEST: 'GUEST'
};

export type PermissionRole = (typeof PermissionRole)[keyof typeof PermissionRole]


export const Permission: {
  READ: 'READ',
  WRITE: 'WRITE',
  EXECUTE: 'EXECUTE',
  SHARE: 'SHARE',
  DELETE: 'DELETE',
  ANALYTICS: 'ANALYTICS',
  EXPORT: 'EXPORT'
};

export type Permission = (typeof Permission)[keyof typeof Permission]


export const DataClassification: {
  PUBLIC: 'PUBLIC',
  INTERNAL: 'INTERNAL',
  CONFIDENTIAL: 'CONFIDENTIAL',
  PERSONAL: 'PERSONAL',
  SENSITIVE: 'SENSITIVE'
};

export type DataClassification = (typeof DataClassification)[keyof typeof DataClassification]

}

export type Visibility = $Enums.Visibility

export const Visibility: typeof $Enums.Visibility

export type PermissionRole = $Enums.PermissionRole

export const PermissionRole: typeof $Enums.PermissionRole

export type Permission = $Enums.Permission

export const Permission: typeof $Enums.Permission

export type DataClassification = $Enums.DataClassification

export const DataClassification: typeof $Enums.DataClassification

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.protocol`: Exposes CRUD operations for the **Protocol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Protocols
    * const protocols = await prisma.protocol.findMany()
    * ```
    */
  get protocol(): Prisma.ProtocolDelegate<ExtArgs>;

  /**
   * `prisma.block`: Exposes CRUD operations for the **Block** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blocks
    * const blocks = await prisma.block.findMany()
    * ```
    */
  get block(): Prisma.BlockDelegate<ExtArgs>;

  /**
   * `prisma.blockSession`: Exposes CRUD operations for the **BlockSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockSessions
    * const blockSessions = await prisma.blockSession.findMany()
    * ```
    */
  get blockSession(): Prisma.BlockSessionDelegate<ExtArgs>;

  /**
   * `prisma.blockProgression`: Exposes CRUD operations for the **BlockProgression** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockProgressions
    * const blockProgressions = await prisma.blockProgression.findMany()
    * ```
    */
  get blockProgression(): Prisma.BlockProgressionDelegate<ExtArgs>;

  /**
   * `prisma.protocolPermission`: Exposes CRUD operations for the **ProtocolPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProtocolPermissions
    * const protocolPermissions = await prisma.protocolPermission.findMany()
    * ```
    */
  get protocolPermission(): Prisma.ProtocolPermissionDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.protocolTemplate`: Exposes CRUD operations for the **ProtocolTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProtocolTemplates
    * const protocolTemplates = await prisma.protocolTemplate.findMany()
    * ```
    */
  get protocolTemplate(): Prisma.ProtocolTemplateDelegate<ExtArgs>;

  /**
   * `prisma.protocolExecution`: Exposes CRUD operations for the **ProtocolExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProtocolExecutions
    * const protocolExecutions = await prisma.protocolExecution.findMany()
    * ```
    */
  get protocolExecution(): Prisma.ProtocolExecutionDelegate<ExtArgs>;

  /**
   * `prisma.blockExecution`: Exposes CRUD operations for the **BlockExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockExecutions
    * const blockExecutions = await prisma.blockExecution.findMany()
    * ```
    */
  get blockExecution(): Prisma.BlockExecutionDelegate<ExtArgs>;

  /**
   * `prisma.sessionExecution`: Exposes CRUD operations for the **SessionExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionExecutions
    * const sessionExecutions = await prisma.sessionExecution.findMany()
    * ```
    */
  get sessionExecution(): Prisma.SessionExecutionDelegate<ExtArgs>;

  /**
   * `prisma.protocolAnalytics`: Exposes CRUD operations for the **ProtocolAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProtocolAnalytics
    * const protocolAnalytics = await prisma.protocolAnalytics.findMany()
    * ```
    */
  get protocolAnalytics(): Prisma.ProtocolAnalyticsDelegate<ExtArgs>;

  /**
   * `prisma.protocolShare`: Exposes CRUD operations for the **ProtocolShare** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProtocolShares
    * const protocolShares = await prisma.protocolShare.findMany()
    * ```
    */
  get protocolShare(): Prisma.ProtocolShareDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    User: 'User',
    Protocol: 'Protocol',
    Block: 'Block',
    BlockSession: 'BlockSession',
    BlockProgression: 'BlockProgression',
    ProtocolPermission: 'ProtocolPermission',
    AuditLog: 'AuditLog',
    ProtocolTemplate: 'ProtocolTemplate',
    ProtocolExecution: 'ProtocolExecution',
    BlockExecution: 'BlockExecution',
    SessionExecution: 'SessionExecution',
    ProtocolAnalytics: 'ProtocolAnalytics',
    ProtocolShare: 'ProtocolShare'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "tenant" | "user" | "protocol" | "block" | "blockSession" | "blockProgression" | "protocolPermission" | "auditLog" | "protocolTemplate" | "protocolExecution" | "blockExecution" | "sessionExecution" | "protocolAnalytics" | "protocolShare"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Protocol: {
        payload: Prisma.$ProtocolPayload<ExtArgs>
        fields: Prisma.ProtocolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProtocolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProtocolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPayload>
          }
          findFirst: {
            args: Prisma.ProtocolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProtocolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPayload>
          }
          findMany: {
            args: Prisma.ProtocolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPayload>[]
          }
          create: {
            args: Prisma.ProtocolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPayload>
          }
          createMany: {
            args: Prisma.ProtocolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProtocolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPayload>[]
          }
          delete: {
            args: Prisma.ProtocolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPayload>
          }
          update: {
            args: Prisma.ProtocolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPayload>
          }
          deleteMany: {
            args: Prisma.ProtocolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProtocolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProtocolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPayload>
          }
          aggregate: {
            args: Prisma.ProtocolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProtocol>
          }
          groupBy: {
            args: Prisma.ProtocolGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProtocolGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProtocolCountArgs<ExtArgs>
            result: $Utils.Optional<ProtocolCountAggregateOutputType> | number
          }
        }
      }
      Block: {
        payload: Prisma.$BlockPayload<ExtArgs>
        fields: Prisma.BlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findFirst: {
            args: Prisma.BlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findMany: {
            args: Prisma.BlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          create: {
            args: Prisma.BlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          createMany: {
            args: Prisma.BlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          delete: {
            args: Prisma.BlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          update: {
            args: Prisma.BlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          deleteMany: {
            args: Prisma.BlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          aggregate: {
            args: Prisma.BlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlock>
          }
          groupBy: {
            args: Prisma.BlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockCountArgs<ExtArgs>
            result: $Utils.Optional<BlockCountAggregateOutputType> | number
          }
        }
      }
      BlockSession: {
        payload: Prisma.$BlockSessionPayload<ExtArgs>
        fields: Prisma.BlockSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockSessionPayload>
          }
          findFirst: {
            args: Prisma.BlockSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockSessionPayload>
          }
          findMany: {
            args: Prisma.BlockSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockSessionPayload>[]
          }
          create: {
            args: Prisma.BlockSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockSessionPayload>
          }
          createMany: {
            args: Prisma.BlockSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockSessionPayload>[]
          }
          delete: {
            args: Prisma.BlockSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockSessionPayload>
          }
          update: {
            args: Prisma.BlockSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockSessionPayload>
          }
          deleteMany: {
            args: Prisma.BlockSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlockSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockSessionPayload>
          }
          aggregate: {
            args: Prisma.BlockSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlockSession>
          }
          groupBy: {
            args: Prisma.BlockSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockSessionCountArgs<ExtArgs>
            result: $Utils.Optional<BlockSessionCountAggregateOutputType> | number
          }
        }
      }
      BlockProgression: {
        payload: Prisma.$BlockProgressionPayload<ExtArgs>
        fields: Prisma.BlockProgressionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockProgressionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockProgressionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockProgressionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockProgressionPayload>
          }
          findFirst: {
            args: Prisma.BlockProgressionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockProgressionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockProgressionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockProgressionPayload>
          }
          findMany: {
            args: Prisma.BlockProgressionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockProgressionPayload>[]
          }
          create: {
            args: Prisma.BlockProgressionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockProgressionPayload>
          }
          createMany: {
            args: Prisma.BlockProgressionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockProgressionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockProgressionPayload>[]
          }
          delete: {
            args: Prisma.BlockProgressionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockProgressionPayload>
          }
          update: {
            args: Prisma.BlockProgressionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockProgressionPayload>
          }
          deleteMany: {
            args: Prisma.BlockProgressionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockProgressionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlockProgressionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockProgressionPayload>
          }
          aggregate: {
            args: Prisma.BlockProgressionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlockProgression>
          }
          groupBy: {
            args: Prisma.BlockProgressionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockProgressionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockProgressionCountArgs<ExtArgs>
            result: $Utils.Optional<BlockProgressionCountAggregateOutputType> | number
          }
        }
      }
      ProtocolPermission: {
        payload: Prisma.$ProtocolPermissionPayload<ExtArgs>
        fields: Prisma.ProtocolPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProtocolPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProtocolPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPermissionPayload>
          }
          findFirst: {
            args: Prisma.ProtocolPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProtocolPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPermissionPayload>
          }
          findMany: {
            args: Prisma.ProtocolPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPermissionPayload>[]
          }
          create: {
            args: Prisma.ProtocolPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPermissionPayload>
          }
          createMany: {
            args: Prisma.ProtocolPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProtocolPermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPermissionPayload>[]
          }
          delete: {
            args: Prisma.ProtocolPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPermissionPayload>
          }
          update: {
            args: Prisma.ProtocolPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPermissionPayload>
          }
          deleteMany: {
            args: Prisma.ProtocolPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProtocolPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProtocolPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolPermissionPayload>
          }
          aggregate: {
            args: Prisma.ProtocolPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProtocolPermission>
          }
          groupBy: {
            args: Prisma.ProtocolPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProtocolPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProtocolPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<ProtocolPermissionCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      ProtocolTemplate: {
        payload: Prisma.$ProtocolTemplatePayload<ExtArgs>
        fields: Prisma.ProtocolTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProtocolTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProtocolTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolTemplatePayload>
          }
          findFirst: {
            args: Prisma.ProtocolTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProtocolTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolTemplatePayload>
          }
          findMany: {
            args: Prisma.ProtocolTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolTemplatePayload>[]
          }
          create: {
            args: Prisma.ProtocolTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolTemplatePayload>
          }
          createMany: {
            args: Prisma.ProtocolTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProtocolTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolTemplatePayload>[]
          }
          delete: {
            args: Prisma.ProtocolTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolTemplatePayload>
          }
          update: {
            args: Prisma.ProtocolTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ProtocolTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProtocolTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProtocolTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolTemplatePayload>
          }
          aggregate: {
            args: Prisma.ProtocolTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProtocolTemplate>
          }
          groupBy: {
            args: Prisma.ProtocolTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProtocolTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProtocolTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ProtocolTemplateCountAggregateOutputType> | number
          }
        }
      }
      ProtocolExecution: {
        payload: Prisma.$ProtocolExecutionPayload<ExtArgs>
        fields: Prisma.ProtocolExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProtocolExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProtocolExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolExecutionPayload>
          }
          findFirst: {
            args: Prisma.ProtocolExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProtocolExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolExecutionPayload>
          }
          findMany: {
            args: Prisma.ProtocolExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolExecutionPayload>[]
          }
          create: {
            args: Prisma.ProtocolExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolExecutionPayload>
          }
          createMany: {
            args: Prisma.ProtocolExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProtocolExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolExecutionPayload>[]
          }
          delete: {
            args: Prisma.ProtocolExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolExecutionPayload>
          }
          update: {
            args: Prisma.ProtocolExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolExecutionPayload>
          }
          deleteMany: {
            args: Prisma.ProtocolExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProtocolExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProtocolExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolExecutionPayload>
          }
          aggregate: {
            args: Prisma.ProtocolExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProtocolExecution>
          }
          groupBy: {
            args: Prisma.ProtocolExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProtocolExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProtocolExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<ProtocolExecutionCountAggregateOutputType> | number
          }
        }
      }
      BlockExecution: {
        payload: Prisma.$BlockExecutionPayload<ExtArgs>
        fields: Prisma.BlockExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionPayload>
          }
          findFirst: {
            args: Prisma.BlockExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionPayload>
          }
          findMany: {
            args: Prisma.BlockExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionPayload>[]
          }
          create: {
            args: Prisma.BlockExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionPayload>
          }
          createMany: {
            args: Prisma.BlockExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionPayload>[]
          }
          delete: {
            args: Prisma.BlockExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionPayload>
          }
          update: {
            args: Prisma.BlockExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionPayload>
          }
          deleteMany: {
            args: Prisma.BlockExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlockExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockExecutionPayload>
          }
          aggregate: {
            args: Prisma.BlockExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlockExecution>
          }
          groupBy: {
            args: Prisma.BlockExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<BlockExecutionCountAggregateOutputType> | number
          }
        }
      }
      SessionExecution: {
        payload: Prisma.$SessionExecutionPayload<ExtArgs>
        fields: Prisma.SessionExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionExecutionPayload>
          }
          findFirst: {
            args: Prisma.SessionExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionExecutionPayload>
          }
          findMany: {
            args: Prisma.SessionExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionExecutionPayload>[]
          }
          create: {
            args: Prisma.SessionExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionExecutionPayload>
          }
          createMany: {
            args: Prisma.SessionExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionExecutionPayload>[]
          }
          delete: {
            args: Prisma.SessionExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionExecutionPayload>
          }
          update: {
            args: Prisma.SessionExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionExecutionPayload>
          }
          deleteMany: {
            args: Prisma.SessionExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionExecutionPayload>
          }
          aggregate: {
            args: Prisma.SessionExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionExecution>
          }
          groupBy: {
            args: Prisma.SessionExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionExecutionCountAggregateOutputType> | number
          }
        }
      }
      ProtocolAnalytics: {
        payload: Prisma.$ProtocolAnalyticsPayload<ExtArgs>
        fields: Prisma.ProtocolAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProtocolAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProtocolAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.ProtocolAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProtocolAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolAnalyticsPayload>
          }
          findMany: {
            args: Prisma.ProtocolAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolAnalyticsPayload>[]
          }
          create: {
            args: Prisma.ProtocolAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolAnalyticsPayload>
          }
          createMany: {
            args: Prisma.ProtocolAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProtocolAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.ProtocolAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolAnalyticsPayload>
          }
          update: {
            args: Prisma.ProtocolAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.ProtocolAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProtocolAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProtocolAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.ProtocolAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProtocolAnalytics>
          }
          groupBy: {
            args: Prisma.ProtocolAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProtocolAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProtocolAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<ProtocolAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      ProtocolShare: {
        payload: Prisma.$ProtocolSharePayload<ExtArgs>
        fields: Prisma.ProtocolShareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProtocolShareFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolSharePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProtocolShareFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolSharePayload>
          }
          findFirst: {
            args: Prisma.ProtocolShareFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolSharePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProtocolShareFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolSharePayload>
          }
          findMany: {
            args: Prisma.ProtocolShareFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolSharePayload>[]
          }
          create: {
            args: Prisma.ProtocolShareCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolSharePayload>
          }
          createMany: {
            args: Prisma.ProtocolShareCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProtocolShareCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolSharePayload>[]
          }
          delete: {
            args: Prisma.ProtocolShareDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolSharePayload>
          }
          update: {
            args: Prisma.ProtocolShareUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolSharePayload>
          }
          deleteMany: {
            args: Prisma.ProtocolShareDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProtocolShareUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProtocolShareUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocolSharePayload>
          }
          aggregate: {
            args: Prisma.ProtocolShareAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProtocolShare>
          }
          groupBy: {
            args: Prisma.ProtocolShareGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProtocolShareGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProtocolShareCountArgs<ExtArgs>
            result: $Utils.Optional<ProtocolShareCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    protocols: number
    users: number
    executions: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    protocols?: boolean | TenantCountOutputTypeCountProtocolsArgs
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    executions?: boolean | TenantCountOutputTypeCountExecutionsArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountProtocolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProtocolWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProtocolExecutionWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    protocols: number
    executions: number
    permissions: number
    sharedProtocols: number
    receivedProtocols: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    protocols?: boolean | UserCountOutputTypeCountProtocolsArgs
    executions?: boolean | UserCountOutputTypeCountExecutionsArgs
    permissions?: boolean | UserCountOutputTypeCountPermissionsArgs
    sharedProtocols?: boolean | UserCountOutputTypeCountSharedProtocolsArgs
    receivedProtocols?: boolean | UserCountOutputTypeCountReceivedProtocolsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProtocolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProtocolWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProtocolExecutionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProtocolPermissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSharedProtocolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProtocolShareWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedProtocolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProtocolShareWhereInput
  }


  /**
   * Count Type ProtocolCountOutputType
   */

  export type ProtocolCountOutputType = {
    blocks: number
    templates: number
    executions: number
    permissions: number
    shares: number
  }

  export type ProtocolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocks?: boolean | ProtocolCountOutputTypeCountBlocksArgs
    templates?: boolean | ProtocolCountOutputTypeCountTemplatesArgs
    executions?: boolean | ProtocolCountOutputTypeCountExecutionsArgs
    permissions?: boolean | ProtocolCountOutputTypeCountPermissionsArgs
    shares?: boolean | ProtocolCountOutputTypeCountSharesArgs
  }

  // Custom InputTypes
  /**
   * ProtocolCountOutputType without action
   */
  export type ProtocolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolCountOutputType
     */
    select?: ProtocolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProtocolCountOutputType without action
   */
  export type ProtocolCountOutputTypeCountBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
  }

  /**
   * ProtocolCountOutputType without action
   */
  export type ProtocolCountOutputTypeCountTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProtocolTemplateWhereInput
  }

  /**
   * ProtocolCountOutputType without action
   */
  export type ProtocolCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProtocolExecutionWhereInput
  }

  /**
   * ProtocolCountOutputType without action
   */
  export type ProtocolCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProtocolPermissionWhereInput
  }

  /**
   * ProtocolCountOutputType without action
   */
  export type ProtocolCountOutputTypeCountSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProtocolShareWhereInput
  }


  /**
   * Count Type BlockCountOutputType
   */

  export type BlockCountOutputType = {
    sessions: number
    progressions: number
    executions: number
  }

  export type BlockCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | BlockCountOutputTypeCountSessionsArgs
    progressions?: boolean | BlockCountOutputTypeCountProgressionsArgs
    executions?: boolean | BlockCountOutputTypeCountExecutionsArgs
  }

  // Custom InputTypes
  /**
   * BlockCountOutputType without action
   */
  export type BlockCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockCountOutputType
     */
    select?: BlockCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlockCountOutputType without action
   */
  export type BlockCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockSessionWhereInput
  }

  /**
   * BlockCountOutputType without action
   */
  export type BlockCountOutputTypeCountProgressionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockProgressionWhereInput
  }

  /**
   * BlockCountOutputType without action
   */
  export type BlockCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockExecutionWhereInput
  }


  /**
   * Count Type ProtocolExecutionCountOutputType
   */

  export type ProtocolExecutionCountOutputType = {
    blockExecutions: number
    sessions: number
  }

  export type ProtocolExecutionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blockExecutions?: boolean | ProtocolExecutionCountOutputTypeCountBlockExecutionsArgs
    sessions?: boolean | ProtocolExecutionCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * ProtocolExecutionCountOutputType without action
   */
  export type ProtocolExecutionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolExecutionCountOutputType
     */
    select?: ProtocolExecutionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProtocolExecutionCountOutputType without action
   */
  export type ProtocolExecutionCountOutputTypeCountBlockExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockExecutionWhereInput
  }

  /**
   * ProtocolExecutionCountOutputType without action
   */
  export type ProtocolExecutionCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionExecutionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantAvgAggregateOutputType = {
    maxUsers: number | null
    maxProtocols: number | null
  }

  export type TenantSumAggregateOutputType = {
    maxUsers: number | null
    maxProtocols: number | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    domain: string | null
    isActive: boolean | null
    maxUsers: number | null
    maxProtocols: number | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    domain: string | null
    isActive: boolean | null
    maxUsers: number | null
    maxProtocols: number | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    domain: number
    isActive: number
    settings: number
    maxUsers: number
    maxProtocols: number
    _all: number
  }


  export type TenantAvgAggregateInputType = {
    maxUsers?: true
    maxProtocols?: true
  }

  export type TenantSumAggregateInputType = {
    maxUsers?: true
    maxProtocols?: true
  }

  export type TenantMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    domain?: true
    isActive?: true
    maxUsers?: true
    maxProtocols?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    domain?: true
    isActive?: true
    maxUsers?: true
    maxProtocols?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    domain?: true
    isActive?: true
    settings?: true
    maxUsers?: true
    maxProtocols?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _avg?: TenantAvgAggregateInputType
    _sum?: TenantSumAggregateInputType
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    domain: string | null
    isActive: boolean
    settings: JsonValue | null
    maxUsers: number
    maxProtocols: number
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    domain?: boolean
    isActive?: boolean
    settings?: boolean
    maxUsers?: boolean
    maxProtocols?: boolean
    protocols?: boolean | Tenant$protocolsArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    executions?: boolean | Tenant$executionsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    domain?: boolean
    isActive?: boolean
    settings?: boolean
    maxUsers?: boolean
    maxProtocols?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    domain?: boolean
    isActive?: boolean
    settings?: boolean
    maxUsers?: boolean
    maxProtocols?: boolean
  }

  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    protocols?: boolean | Tenant$protocolsArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    executions?: boolean | Tenant$executionsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      protocols: Prisma.$ProtocolPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      executions: Prisma.$ProtocolExecutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      domain: string | null
      isActive: boolean
      settings: Prisma.JsonValue | null
      maxUsers: number
      maxProtocols: number
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    protocols<T extends Tenant$protocolsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$protocolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    executions<T extends Tenant$executionsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */ 
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly domain: FieldRef<"Tenant", 'String'>
    readonly isActive: FieldRef<"Tenant", 'Boolean'>
    readonly settings: FieldRef<"Tenant", 'Json'>
    readonly maxUsers: FieldRef<"Tenant", 'Int'>
    readonly maxProtocols: FieldRef<"Tenant", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant.protocols
   */
  export type Tenant$protocolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    where?: ProtocolWhereInput
    orderBy?: ProtocolOrderByWithRelationInput | ProtocolOrderByWithRelationInput[]
    cursor?: ProtocolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProtocolScalarFieldEnum | ProtocolScalarFieldEnum[]
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.executions
   */
  export type Tenant$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolExecution
     */
    select?: ProtocolExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolExecutionInclude<ExtArgs> | null
    where?: ProtocolExecutionWhereInput
    orderBy?: ProtocolExecutionOrderByWithRelationInput | ProtocolExecutionOrderByWithRelationInput[]
    cursor?: ProtocolExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProtocolExecutionScalarFieldEnum | ProtocolExecutionScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    name: string | null
    tenantId: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    name: string | null
    tenantId: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    email: number
    name: number
    tenantId: number
    isActive: number
    lastLoginAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    name?: true
    tenantId?: true
    isActive?: true
    lastLoginAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    name?: true
    tenantId?: true
    isActive?: true
    lastLoginAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    name?: true
    tenantId?: true
    isActive?: true
    lastLoginAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    email: string
    name: string | null
    tenantId: string
    isActive: boolean
    lastLoginAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    name?: boolean
    tenantId?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    protocols?: boolean | User$protocolsArgs<ExtArgs>
    executions?: boolean | User$executionsArgs<ExtArgs>
    permissions?: boolean | User$permissionsArgs<ExtArgs>
    sharedProtocols?: boolean | User$sharedProtocolsArgs<ExtArgs>
    receivedProtocols?: boolean | User$receivedProtocolsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    name?: boolean
    tenantId?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    name?: boolean
    tenantId?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    protocols?: boolean | User$protocolsArgs<ExtArgs>
    executions?: boolean | User$executionsArgs<ExtArgs>
    permissions?: boolean | User$permissionsArgs<ExtArgs>
    sharedProtocols?: boolean | User$sharedProtocolsArgs<ExtArgs>
    receivedProtocols?: boolean | User$receivedProtocolsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      protocols: Prisma.$ProtocolPayload<ExtArgs>[]
      executions: Prisma.$ProtocolExecutionPayload<ExtArgs>[]
      permissions: Prisma.$ProtocolPermissionPayload<ExtArgs>[]
      sharedProtocols: Prisma.$ProtocolSharePayload<ExtArgs>[]
      receivedProtocols: Prisma.$ProtocolSharePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      email: string
      name: string | null
      tenantId: string
      isActive: boolean
      lastLoginAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    protocols<T extends User$protocolsArgs<ExtArgs> = {}>(args?: Subset<T, User$protocolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "findMany"> | Null>
    executions<T extends User$executionsArgs<ExtArgs> = {}>(args?: Subset<T, User$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    permissions<T extends User$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolPermissionPayload<ExtArgs>, T, "findMany"> | Null>
    sharedProtocols<T extends User$sharedProtocolsArgs<ExtArgs> = {}>(args?: Subset<T, User$sharedProtocolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolSharePayload<ExtArgs>, T, "findMany"> | Null>
    receivedProtocols<T extends User$receivedProtocolsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedProtocolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolSharePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.protocols
   */
  export type User$protocolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    where?: ProtocolWhereInput
    orderBy?: ProtocolOrderByWithRelationInput | ProtocolOrderByWithRelationInput[]
    cursor?: ProtocolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProtocolScalarFieldEnum | ProtocolScalarFieldEnum[]
  }

  /**
   * User.executions
   */
  export type User$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolExecution
     */
    select?: ProtocolExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolExecutionInclude<ExtArgs> | null
    where?: ProtocolExecutionWhereInput
    orderBy?: ProtocolExecutionOrderByWithRelationInput | ProtocolExecutionOrderByWithRelationInput[]
    cursor?: ProtocolExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProtocolExecutionScalarFieldEnum | ProtocolExecutionScalarFieldEnum[]
  }

  /**
   * User.permissions
   */
  export type User$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolPermission
     */
    select?: ProtocolPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolPermissionInclude<ExtArgs> | null
    where?: ProtocolPermissionWhereInput
    orderBy?: ProtocolPermissionOrderByWithRelationInput | ProtocolPermissionOrderByWithRelationInput[]
    cursor?: ProtocolPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProtocolPermissionScalarFieldEnum | ProtocolPermissionScalarFieldEnum[]
  }

  /**
   * User.sharedProtocols
   */
  export type User$sharedProtocolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolShare
     */
    select?: ProtocolShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolShareInclude<ExtArgs> | null
    where?: ProtocolShareWhereInput
    orderBy?: ProtocolShareOrderByWithRelationInput | ProtocolShareOrderByWithRelationInput[]
    cursor?: ProtocolShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProtocolShareScalarFieldEnum | ProtocolShareScalarFieldEnum[]
  }

  /**
   * User.receivedProtocols
   */
  export type User$receivedProtocolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolShare
     */
    select?: ProtocolShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolShareInclude<ExtArgs> | null
    where?: ProtocolShareWhereInput
    orderBy?: ProtocolShareOrderByWithRelationInput | ProtocolShareOrderByWithRelationInput[]
    cursor?: ProtocolShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProtocolShareScalarFieldEnum | ProtocolShareScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Protocol
   */

  export type AggregateProtocol = {
    _count: ProtocolCountAggregateOutputType | null
    _avg: ProtocolAvgAggregateOutputType | null
    _sum: ProtocolSumAggregateOutputType | null
    _min: ProtocolMinAggregateOutputType | null
    _max: ProtocolMaxAggregateOutputType | null
  }

  export type ProtocolAvgAggregateOutputType = {
    duration: number | null
    frequency: number | null
  }

  export type ProtocolSumAggregateOutputType = {
    duration: number | null
    frequency: number | null
  }

  export type ProtocolMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    tenantId: string | null
    name: string | null
    version: string | null
    description: string | null
    category: string | null
    difficulty: string | null
    duration: number | null
    frequency: number | null
    ownerId: string | null
    visibility: $Enums.Visibility | null
    isActive: boolean | null
    isPublic: boolean | null
    overview: string | null
  }

  export type ProtocolMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    tenantId: string | null
    name: string | null
    version: string | null
    description: string | null
    category: string | null
    difficulty: string | null
    duration: number | null
    frequency: number | null
    ownerId: string | null
    visibility: $Enums.Visibility | null
    isActive: boolean | null
    isPublic: boolean | null
    overview: string | null
  }

  export type ProtocolCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    tenantId: number
    name: number
    version: number
    description: number
    category: number
    difficulty: number
    duration: number
    frequency: number
    ownerId: number
    visibility: number
    isActive: number
    isPublic: number
    overview: number
    principles: number
    requirements: number
    _all: number
  }


  export type ProtocolAvgAggregateInputType = {
    duration?: true
    frequency?: true
  }

  export type ProtocolSumAggregateInputType = {
    duration?: true
    frequency?: true
  }

  export type ProtocolMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    tenantId?: true
    name?: true
    version?: true
    description?: true
    category?: true
    difficulty?: true
    duration?: true
    frequency?: true
    ownerId?: true
    visibility?: true
    isActive?: true
    isPublic?: true
    overview?: true
  }

  export type ProtocolMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    tenantId?: true
    name?: true
    version?: true
    description?: true
    category?: true
    difficulty?: true
    duration?: true
    frequency?: true
    ownerId?: true
    visibility?: true
    isActive?: true
    isPublic?: true
    overview?: true
  }

  export type ProtocolCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    tenantId?: true
    name?: true
    version?: true
    description?: true
    category?: true
    difficulty?: true
    duration?: true
    frequency?: true
    ownerId?: true
    visibility?: true
    isActive?: true
    isPublic?: true
    overview?: true
    principles?: true
    requirements?: true
    _all?: true
  }

  export type ProtocolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Protocol to aggregate.
     */
    where?: ProtocolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Protocols to fetch.
     */
    orderBy?: ProtocolOrderByWithRelationInput | ProtocolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProtocolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Protocols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Protocols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Protocols
    **/
    _count?: true | ProtocolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProtocolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProtocolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProtocolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProtocolMaxAggregateInputType
  }

  export type GetProtocolAggregateType<T extends ProtocolAggregateArgs> = {
        [P in keyof T & keyof AggregateProtocol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProtocol[P]>
      : GetScalarType<T[P], AggregateProtocol[P]>
  }




  export type ProtocolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProtocolWhereInput
    orderBy?: ProtocolOrderByWithAggregationInput | ProtocolOrderByWithAggregationInput[]
    by: ProtocolScalarFieldEnum[] | ProtocolScalarFieldEnum
    having?: ProtocolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProtocolCountAggregateInputType | true
    _avg?: ProtocolAvgAggregateInputType
    _sum?: ProtocolSumAggregateInputType
    _min?: ProtocolMinAggregateInputType
    _max?: ProtocolMaxAggregateInputType
  }

  export type ProtocolGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    tenantId: string
    name: string
    version: string
    description: string | null
    category: string
    difficulty: string
    duration: number | null
    frequency: number | null
    ownerId: string
    visibility: $Enums.Visibility
    isActive: boolean
    isPublic: boolean
    overview: string | null
    principles: string[]
    requirements: string[]
    _count: ProtocolCountAggregateOutputType | null
    _avg: ProtocolAvgAggregateOutputType | null
    _sum: ProtocolSumAggregateOutputType | null
    _min: ProtocolMinAggregateOutputType | null
    _max: ProtocolMaxAggregateOutputType | null
  }

  type GetProtocolGroupByPayload<T extends ProtocolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProtocolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProtocolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProtocolGroupByOutputType[P]>
            : GetScalarType<T[P], ProtocolGroupByOutputType[P]>
        }
      >
    >


  export type ProtocolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenantId?: boolean
    name?: boolean
    version?: boolean
    description?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    frequency?: boolean
    ownerId?: boolean
    visibility?: boolean
    isActive?: boolean
    isPublic?: boolean
    overview?: boolean
    principles?: boolean
    requirements?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    blocks?: boolean | Protocol$blocksArgs<ExtArgs>
    templates?: boolean | Protocol$templatesArgs<ExtArgs>
    executions?: boolean | Protocol$executionsArgs<ExtArgs>
    permissions?: boolean | Protocol$permissionsArgs<ExtArgs>
    shares?: boolean | Protocol$sharesArgs<ExtArgs>
    _count?: boolean | ProtocolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["protocol"]>

  export type ProtocolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenantId?: boolean
    name?: boolean
    version?: boolean
    description?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    frequency?: boolean
    ownerId?: boolean
    visibility?: boolean
    isActive?: boolean
    isPublic?: boolean
    overview?: boolean
    principles?: boolean
    requirements?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["protocol"]>

  export type ProtocolSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenantId?: boolean
    name?: boolean
    version?: boolean
    description?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    frequency?: boolean
    ownerId?: boolean
    visibility?: boolean
    isActive?: boolean
    isPublic?: boolean
    overview?: boolean
    principles?: boolean
    requirements?: boolean
  }

  export type ProtocolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    blocks?: boolean | Protocol$blocksArgs<ExtArgs>
    templates?: boolean | Protocol$templatesArgs<ExtArgs>
    executions?: boolean | Protocol$executionsArgs<ExtArgs>
    permissions?: boolean | Protocol$permissionsArgs<ExtArgs>
    shares?: boolean | Protocol$sharesArgs<ExtArgs>
    _count?: boolean | ProtocolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProtocolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProtocolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Protocol"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs>
      blocks: Prisma.$BlockPayload<ExtArgs>[]
      templates: Prisma.$ProtocolTemplatePayload<ExtArgs>[]
      executions: Prisma.$ProtocolExecutionPayload<ExtArgs>[]
      permissions: Prisma.$ProtocolPermissionPayload<ExtArgs>[]
      shares: Prisma.$ProtocolSharePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      tenantId: string
      name: string
      version: string
      description: string | null
      category: string
      difficulty: string
      duration: number | null
      frequency: number | null
      ownerId: string
      visibility: $Enums.Visibility
      isActive: boolean
      isPublic: boolean
      overview: string | null
      principles: string[]
      requirements: string[]
    }, ExtArgs["result"]["protocol"]>
    composites: {}
  }

  type ProtocolGetPayload<S extends boolean | null | undefined | ProtocolDefaultArgs> = $Result.GetResult<Prisma.$ProtocolPayload, S>

  type ProtocolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProtocolFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProtocolCountAggregateInputType | true
    }

  export interface ProtocolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Protocol'], meta: { name: 'Protocol' } }
    /**
     * Find zero or one Protocol that matches the filter.
     * @param {ProtocolFindUniqueArgs} args - Arguments to find a Protocol
     * @example
     * // Get one Protocol
     * const protocol = await prisma.protocol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProtocolFindUniqueArgs>(args: SelectSubset<T, ProtocolFindUniqueArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Protocol that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProtocolFindUniqueOrThrowArgs} args - Arguments to find a Protocol
     * @example
     * // Get one Protocol
     * const protocol = await prisma.protocol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProtocolFindUniqueOrThrowArgs>(args: SelectSubset<T, ProtocolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Protocol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolFindFirstArgs} args - Arguments to find a Protocol
     * @example
     * // Get one Protocol
     * const protocol = await prisma.protocol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProtocolFindFirstArgs>(args?: SelectSubset<T, ProtocolFindFirstArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Protocol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolFindFirstOrThrowArgs} args - Arguments to find a Protocol
     * @example
     * // Get one Protocol
     * const protocol = await prisma.protocol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProtocolFindFirstOrThrowArgs>(args?: SelectSubset<T, ProtocolFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Protocols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Protocols
     * const protocols = await prisma.protocol.findMany()
     * 
     * // Get first 10 Protocols
     * const protocols = await prisma.protocol.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const protocolWithIdOnly = await prisma.protocol.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProtocolFindManyArgs>(args?: SelectSubset<T, ProtocolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Protocol.
     * @param {ProtocolCreateArgs} args - Arguments to create a Protocol.
     * @example
     * // Create one Protocol
     * const Protocol = await prisma.protocol.create({
     *   data: {
     *     // ... data to create a Protocol
     *   }
     * })
     * 
     */
    create<T extends ProtocolCreateArgs>(args: SelectSubset<T, ProtocolCreateArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Protocols.
     * @param {ProtocolCreateManyArgs} args - Arguments to create many Protocols.
     * @example
     * // Create many Protocols
     * const protocol = await prisma.protocol.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProtocolCreateManyArgs>(args?: SelectSubset<T, ProtocolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Protocols and returns the data saved in the database.
     * @param {ProtocolCreateManyAndReturnArgs} args - Arguments to create many Protocols.
     * @example
     * // Create many Protocols
     * const protocol = await prisma.protocol.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Protocols and only return the `id`
     * const protocolWithIdOnly = await prisma.protocol.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProtocolCreateManyAndReturnArgs>(args?: SelectSubset<T, ProtocolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Protocol.
     * @param {ProtocolDeleteArgs} args - Arguments to delete one Protocol.
     * @example
     * // Delete one Protocol
     * const Protocol = await prisma.protocol.delete({
     *   where: {
     *     // ... filter to delete one Protocol
     *   }
     * })
     * 
     */
    delete<T extends ProtocolDeleteArgs>(args: SelectSubset<T, ProtocolDeleteArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Protocol.
     * @param {ProtocolUpdateArgs} args - Arguments to update one Protocol.
     * @example
     * // Update one Protocol
     * const protocol = await prisma.protocol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProtocolUpdateArgs>(args: SelectSubset<T, ProtocolUpdateArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Protocols.
     * @param {ProtocolDeleteManyArgs} args - Arguments to filter Protocols to delete.
     * @example
     * // Delete a few Protocols
     * const { count } = await prisma.protocol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProtocolDeleteManyArgs>(args?: SelectSubset<T, ProtocolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Protocols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Protocols
     * const protocol = await prisma.protocol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProtocolUpdateManyArgs>(args: SelectSubset<T, ProtocolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Protocol.
     * @param {ProtocolUpsertArgs} args - Arguments to update or create a Protocol.
     * @example
     * // Update or create a Protocol
     * const protocol = await prisma.protocol.upsert({
     *   create: {
     *     // ... data to create a Protocol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Protocol we want to update
     *   }
     * })
     */
    upsert<T extends ProtocolUpsertArgs>(args: SelectSubset<T, ProtocolUpsertArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Protocols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolCountArgs} args - Arguments to filter Protocols to count.
     * @example
     * // Count the number of Protocols
     * const count = await prisma.protocol.count({
     *   where: {
     *     // ... the filter for the Protocols we want to count
     *   }
     * })
    **/
    count<T extends ProtocolCountArgs>(
      args?: Subset<T, ProtocolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProtocolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Protocol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProtocolAggregateArgs>(args: Subset<T, ProtocolAggregateArgs>): Prisma.PrismaPromise<GetProtocolAggregateType<T>>

    /**
     * Group by Protocol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProtocolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProtocolGroupByArgs['orderBy'] }
        : { orderBy?: ProtocolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProtocolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProtocolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Protocol model
   */
  readonly fields: ProtocolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Protocol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProtocolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    blocks<T extends Protocol$blocksArgs<ExtArgs> = {}>(args?: Subset<T, Protocol$blocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany"> | Null>
    templates<T extends Protocol$templatesArgs<ExtArgs> = {}>(args?: Subset<T, Protocol$templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    executions<T extends Protocol$executionsArgs<ExtArgs> = {}>(args?: Subset<T, Protocol$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    permissions<T extends Protocol$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Protocol$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolPermissionPayload<ExtArgs>, T, "findMany"> | Null>
    shares<T extends Protocol$sharesArgs<ExtArgs> = {}>(args?: Subset<T, Protocol$sharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolSharePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Protocol model
   */ 
  interface ProtocolFieldRefs {
    readonly id: FieldRef<"Protocol", 'String'>
    readonly createdAt: FieldRef<"Protocol", 'DateTime'>
    readonly updatedAt: FieldRef<"Protocol", 'DateTime'>
    readonly tenantId: FieldRef<"Protocol", 'String'>
    readonly name: FieldRef<"Protocol", 'String'>
    readonly version: FieldRef<"Protocol", 'String'>
    readonly description: FieldRef<"Protocol", 'String'>
    readonly category: FieldRef<"Protocol", 'String'>
    readonly difficulty: FieldRef<"Protocol", 'String'>
    readonly duration: FieldRef<"Protocol", 'Int'>
    readonly frequency: FieldRef<"Protocol", 'Int'>
    readonly ownerId: FieldRef<"Protocol", 'String'>
    readonly visibility: FieldRef<"Protocol", 'Visibility'>
    readonly isActive: FieldRef<"Protocol", 'Boolean'>
    readonly isPublic: FieldRef<"Protocol", 'Boolean'>
    readonly overview: FieldRef<"Protocol", 'String'>
    readonly principles: FieldRef<"Protocol", 'String[]'>
    readonly requirements: FieldRef<"Protocol", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Protocol findUnique
   */
  export type ProtocolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    /**
     * Filter, which Protocol to fetch.
     */
    where: ProtocolWhereUniqueInput
  }

  /**
   * Protocol findUniqueOrThrow
   */
  export type ProtocolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    /**
     * Filter, which Protocol to fetch.
     */
    where: ProtocolWhereUniqueInput
  }

  /**
   * Protocol findFirst
   */
  export type ProtocolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    /**
     * Filter, which Protocol to fetch.
     */
    where?: ProtocolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Protocols to fetch.
     */
    orderBy?: ProtocolOrderByWithRelationInput | ProtocolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Protocols.
     */
    cursor?: ProtocolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Protocols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Protocols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Protocols.
     */
    distinct?: ProtocolScalarFieldEnum | ProtocolScalarFieldEnum[]
  }

  /**
   * Protocol findFirstOrThrow
   */
  export type ProtocolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    /**
     * Filter, which Protocol to fetch.
     */
    where?: ProtocolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Protocols to fetch.
     */
    orderBy?: ProtocolOrderByWithRelationInput | ProtocolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Protocols.
     */
    cursor?: ProtocolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Protocols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Protocols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Protocols.
     */
    distinct?: ProtocolScalarFieldEnum | ProtocolScalarFieldEnum[]
  }

  /**
   * Protocol findMany
   */
  export type ProtocolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    /**
     * Filter, which Protocols to fetch.
     */
    where?: ProtocolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Protocols to fetch.
     */
    orderBy?: ProtocolOrderByWithRelationInput | ProtocolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Protocols.
     */
    cursor?: ProtocolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Protocols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Protocols.
     */
    skip?: number
    distinct?: ProtocolScalarFieldEnum | ProtocolScalarFieldEnum[]
  }

  /**
   * Protocol create
   */
  export type ProtocolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    /**
     * The data needed to create a Protocol.
     */
    data: XOR<ProtocolCreateInput, ProtocolUncheckedCreateInput>
  }

  /**
   * Protocol createMany
   */
  export type ProtocolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Protocols.
     */
    data: ProtocolCreateManyInput | ProtocolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Protocol createManyAndReturn
   */
  export type ProtocolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Protocols.
     */
    data: ProtocolCreateManyInput | ProtocolCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Protocol update
   */
  export type ProtocolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    /**
     * The data needed to update a Protocol.
     */
    data: XOR<ProtocolUpdateInput, ProtocolUncheckedUpdateInput>
    /**
     * Choose, which Protocol to update.
     */
    where: ProtocolWhereUniqueInput
  }

  /**
   * Protocol updateMany
   */
  export type ProtocolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Protocols.
     */
    data: XOR<ProtocolUpdateManyMutationInput, ProtocolUncheckedUpdateManyInput>
    /**
     * Filter which Protocols to update
     */
    where?: ProtocolWhereInput
  }

  /**
   * Protocol upsert
   */
  export type ProtocolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    /**
     * The filter to search for the Protocol to update in case it exists.
     */
    where: ProtocolWhereUniqueInput
    /**
     * In case the Protocol found by the `where` argument doesn't exist, create a new Protocol with this data.
     */
    create: XOR<ProtocolCreateInput, ProtocolUncheckedCreateInput>
    /**
     * In case the Protocol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProtocolUpdateInput, ProtocolUncheckedUpdateInput>
  }

  /**
   * Protocol delete
   */
  export type ProtocolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
    /**
     * Filter which Protocol to delete.
     */
    where: ProtocolWhereUniqueInput
  }

  /**
   * Protocol deleteMany
   */
  export type ProtocolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Protocols to delete
     */
    where?: ProtocolWhereInput
  }

  /**
   * Protocol.blocks
   */
  export type Protocol$blocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    cursor?: BlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Protocol.templates
   */
  export type Protocol$templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolTemplate
     */
    select?: ProtocolTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolTemplateInclude<ExtArgs> | null
    where?: ProtocolTemplateWhereInput
    orderBy?: ProtocolTemplateOrderByWithRelationInput | ProtocolTemplateOrderByWithRelationInput[]
    cursor?: ProtocolTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProtocolTemplateScalarFieldEnum | ProtocolTemplateScalarFieldEnum[]
  }

  /**
   * Protocol.executions
   */
  export type Protocol$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolExecution
     */
    select?: ProtocolExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolExecutionInclude<ExtArgs> | null
    where?: ProtocolExecutionWhereInput
    orderBy?: ProtocolExecutionOrderByWithRelationInput | ProtocolExecutionOrderByWithRelationInput[]
    cursor?: ProtocolExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProtocolExecutionScalarFieldEnum | ProtocolExecutionScalarFieldEnum[]
  }

  /**
   * Protocol.permissions
   */
  export type Protocol$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolPermission
     */
    select?: ProtocolPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolPermissionInclude<ExtArgs> | null
    where?: ProtocolPermissionWhereInput
    orderBy?: ProtocolPermissionOrderByWithRelationInput | ProtocolPermissionOrderByWithRelationInput[]
    cursor?: ProtocolPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProtocolPermissionScalarFieldEnum | ProtocolPermissionScalarFieldEnum[]
  }

  /**
   * Protocol.shares
   */
  export type Protocol$sharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolShare
     */
    select?: ProtocolShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolShareInclude<ExtArgs> | null
    where?: ProtocolShareWhereInput
    orderBy?: ProtocolShareOrderByWithRelationInput | ProtocolShareOrderByWithRelationInput[]
    cursor?: ProtocolShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProtocolShareScalarFieldEnum | ProtocolShareScalarFieldEnum[]
  }

  /**
   * Protocol without action
   */
  export type ProtocolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocol
     */
    select?: ProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolInclude<ExtArgs> | null
  }


  /**
   * Model Block
   */

  export type AggregateBlock = {
    _count: BlockCountAggregateOutputType | null
    _avg: BlockAvgAggregateOutputType | null
    _sum: BlockSumAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  export type BlockAvgAggregateOutputType = {
    order: number | null
    duration: number | null
  }

  export type BlockSumAggregateOutputType = {
    order: number | null
    duration: number | null
  }

  export type BlockMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    protocolId: string | null
    name: string | null
    description: string | null
    order: number | null
    duration: number | null
    phase: string | null
    intensity: string | null
    volume: string | null
  }

  export type BlockMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    protocolId: string | null
    name: string | null
    description: string | null
    order: number | null
    duration: number | null
    phase: string | null
    intensity: string | null
    volume: string | null
  }

  export type BlockCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    protocolId: number
    name: number
    description: number
    order: number
    duration: number
    phase: number
    intensity: number
    volume: number
    parameters: number
    rules: number
    _all: number
  }


  export type BlockAvgAggregateInputType = {
    order?: true
    duration?: true
  }

  export type BlockSumAggregateInputType = {
    order?: true
    duration?: true
  }

  export type BlockMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    protocolId?: true
    name?: true
    description?: true
    order?: true
    duration?: true
    phase?: true
    intensity?: true
    volume?: true
  }

  export type BlockMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    protocolId?: true
    name?: true
    description?: true
    order?: true
    duration?: true
    phase?: true
    intensity?: true
    volume?: true
  }

  export type BlockCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    protocolId?: true
    name?: true
    description?: true
    order?: true
    duration?: true
    phase?: true
    intensity?: true
    volume?: true
    parameters?: true
    rules?: true
    _all?: true
  }

  export type BlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Block to aggregate.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blocks
    **/
    _count?: true | BlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockMaxAggregateInputType
  }

  export type GetBlockAggregateType<T extends BlockAggregateArgs> = {
        [P in keyof T & keyof AggregateBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlock[P]>
      : GetScalarType<T[P], AggregateBlock[P]>
  }




  export type BlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithAggregationInput | BlockOrderByWithAggregationInput[]
    by: BlockScalarFieldEnum[] | BlockScalarFieldEnum
    having?: BlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockCountAggregateInputType | true
    _avg?: BlockAvgAggregateInputType
    _sum?: BlockSumAggregateInputType
    _min?: BlockMinAggregateInputType
    _max?: BlockMaxAggregateInputType
  }

  export type BlockGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    protocolId: string
    name: string
    description: string | null
    order: number
    duration: number
    phase: string
    intensity: string
    volume: string
    parameters: JsonValue | null
    rules: JsonValue | null
    _count: BlockCountAggregateOutputType | null
    _avg: BlockAvgAggregateOutputType | null
    _sum: BlockSumAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  type GetBlockGroupByPayload<T extends BlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockGroupByOutputType[P]>
            : GetScalarType<T[P], BlockGroupByOutputType[P]>
        }
      >
    >


  export type BlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    protocolId?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    duration?: boolean
    phase?: boolean
    intensity?: boolean
    volume?: boolean
    parameters?: boolean
    rules?: boolean
    protocol?: boolean | ProtocolDefaultArgs<ExtArgs>
    sessions?: boolean | Block$sessionsArgs<ExtArgs>
    progressions?: boolean | Block$progressionsArgs<ExtArgs>
    executions?: boolean | Block$executionsArgs<ExtArgs>
    _count?: boolean | BlockCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["block"]>

  export type BlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    protocolId?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    duration?: boolean
    phase?: boolean
    intensity?: boolean
    volume?: boolean
    parameters?: boolean
    rules?: boolean
    protocol?: boolean | ProtocolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["block"]>

  export type BlockSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    protocolId?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    duration?: boolean
    phase?: boolean
    intensity?: boolean
    volume?: boolean
    parameters?: boolean
    rules?: boolean
  }

  export type BlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    protocol?: boolean | ProtocolDefaultArgs<ExtArgs>
    sessions?: boolean | Block$sessionsArgs<ExtArgs>
    progressions?: boolean | Block$progressionsArgs<ExtArgs>
    executions?: boolean | Block$executionsArgs<ExtArgs>
    _count?: boolean | BlockCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    protocol?: boolean | ProtocolDefaultArgs<ExtArgs>
  }

  export type $BlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Block"
    objects: {
      protocol: Prisma.$ProtocolPayload<ExtArgs>
      sessions: Prisma.$BlockSessionPayload<ExtArgs>[]
      progressions: Prisma.$BlockProgressionPayload<ExtArgs>[]
      executions: Prisma.$BlockExecutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      protocolId: string
      name: string
      description: string | null
      order: number
      duration: number
      phase: string
      intensity: string
      volume: string
      parameters: Prisma.JsonValue | null
      rules: Prisma.JsonValue | null
    }, ExtArgs["result"]["block"]>
    composites: {}
  }

  type BlockGetPayload<S extends boolean | null | undefined | BlockDefaultArgs> = $Result.GetResult<Prisma.$BlockPayload, S>

  type BlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlockFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlockCountAggregateInputType | true
    }

  export interface BlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Block'], meta: { name: 'Block' } }
    /**
     * Find zero or one Block that matches the filter.
     * @param {BlockFindUniqueArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockFindUniqueArgs>(args: SelectSubset<T, BlockFindUniqueArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Block that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlockFindUniqueOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Block that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockFindFirstArgs>(args?: SelectSubset<T, BlockFindFirstArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Block that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blocks
     * const blocks = await prisma.block.findMany()
     * 
     * // Get first 10 Blocks
     * const blocks = await prisma.block.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockWithIdOnly = await prisma.block.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockFindManyArgs>(args?: SelectSubset<T, BlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Block.
     * @param {BlockCreateArgs} args - Arguments to create a Block.
     * @example
     * // Create one Block
     * const Block = await prisma.block.create({
     *   data: {
     *     // ... data to create a Block
     *   }
     * })
     * 
     */
    create<T extends BlockCreateArgs>(args: SelectSubset<T, BlockCreateArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Blocks.
     * @param {BlockCreateManyArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const block = await prisma.block.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockCreateManyArgs>(args?: SelectSubset<T, BlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blocks and returns the data saved in the database.
     * @param {BlockCreateManyAndReturnArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const block = await prisma.block.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blocks and only return the `id`
     * const blockWithIdOnly = await prisma.block.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Block.
     * @param {BlockDeleteArgs} args - Arguments to delete one Block.
     * @example
     * // Delete one Block
     * const Block = await prisma.block.delete({
     *   where: {
     *     // ... filter to delete one Block
     *   }
     * })
     * 
     */
    delete<T extends BlockDeleteArgs>(args: SelectSubset<T, BlockDeleteArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Block.
     * @param {BlockUpdateArgs} args - Arguments to update one Block.
     * @example
     * // Update one Block
     * const block = await prisma.block.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockUpdateArgs>(args: SelectSubset<T, BlockUpdateArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Blocks.
     * @param {BlockDeleteManyArgs} args - Arguments to filter Blocks to delete.
     * @example
     * // Delete a few Blocks
     * const { count } = await prisma.block.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockDeleteManyArgs>(args?: SelectSubset<T, BlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blocks
     * const block = await prisma.block.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockUpdateManyArgs>(args: SelectSubset<T, BlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Block.
     * @param {BlockUpsertArgs} args - Arguments to update or create a Block.
     * @example
     * // Update or create a Block
     * const block = await prisma.block.upsert({
     *   create: {
     *     // ... data to create a Block
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Block we want to update
     *   }
     * })
     */
    upsert<T extends BlockUpsertArgs>(args: SelectSubset<T, BlockUpsertArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockCountArgs} args - Arguments to filter Blocks to count.
     * @example
     * // Count the number of Blocks
     * const count = await prisma.block.count({
     *   where: {
     *     // ... the filter for the Blocks we want to count
     *   }
     * })
    **/
    count<T extends BlockCountArgs>(
      args?: Subset<T, BlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockAggregateArgs>(args: Subset<T, BlockAggregateArgs>): Prisma.PrismaPromise<GetBlockAggregateType<T>>

    /**
     * Group by Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockGroupByArgs['orderBy'] }
        : { orderBy?: BlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Block model
   */
  readonly fields: BlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Block.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    protocol<T extends ProtocolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProtocolDefaultArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sessions<T extends Block$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Block$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockSessionPayload<ExtArgs>, T, "findMany"> | Null>
    progressions<T extends Block$progressionsArgs<ExtArgs> = {}>(args?: Subset<T, Block$progressionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockProgressionPayload<ExtArgs>, T, "findMany"> | Null>
    executions<T extends Block$executionsArgs<ExtArgs> = {}>(args?: Subset<T, Block$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Block model
   */ 
  interface BlockFieldRefs {
    readonly id: FieldRef<"Block", 'String'>
    readonly createdAt: FieldRef<"Block", 'DateTime'>
    readonly updatedAt: FieldRef<"Block", 'DateTime'>
    readonly protocolId: FieldRef<"Block", 'String'>
    readonly name: FieldRef<"Block", 'String'>
    readonly description: FieldRef<"Block", 'String'>
    readonly order: FieldRef<"Block", 'Int'>
    readonly duration: FieldRef<"Block", 'Int'>
    readonly phase: FieldRef<"Block", 'String'>
    readonly intensity: FieldRef<"Block", 'String'>
    readonly volume: FieldRef<"Block", 'String'>
    readonly parameters: FieldRef<"Block", 'Json'>
    readonly rules: FieldRef<"Block", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Block findUnique
   */
  export type BlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block findUniqueOrThrow
   */
  export type BlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block findFirst
   */
  export type BlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block findFirstOrThrow
   */
  export type BlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block findMany
   */
  export type BlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Blocks to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block create
   */
  export type BlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The data needed to create a Block.
     */
    data: XOR<BlockCreateInput, BlockUncheckedCreateInput>
  }

  /**
   * Block createMany
   */
  export type BlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blocks.
     */
    data: BlockCreateManyInput | BlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Block createManyAndReturn
   */
  export type BlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Blocks.
     */
    data: BlockCreateManyInput | BlockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Block update
   */
  export type BlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The data needed to update a Block.
     */
    data: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
    /**
     * Choose, which Block to update.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block updateMany
   */
  export type BlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blocks.
     */
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyInput>
    /**
     * Filter which Blocks to update
     */
    where?: BlockWhereInput
  }

  /**
   * Block upsert
   */
  export type BlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The filter to search for the Block to update in case it exists.
     */
    where: BlockWhereUniqueInput
    /**
     * In case the Block found by the `where` argument doesn't exist, create a new Block with this data.
     */
    create: XOR<BlockCreateInput, BlockUncheckedCreateInput>
    /**
     * In case the Block was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
  }

  /**
   * Block delete
   */
  export type BlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter which Block to delete.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block deleteMany
   */
  export type BlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blocks to delete
     */
    where?: BlockWhereInput
  }

  /**
   * Block.sessions
   */
  export type Block$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockSession
     */
    select?: BlockSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockSessionInclude<ExtArgs> | null
    where?: BlockSessionWhereInput
    orderBy?: BlockSessionOrderByWithRelationInput | BlockSessionOrderByWithRelationInput[]
    cursor?: BlockSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockSessionScalarFieldEnum | BlockSessionScalarFieldEnum[]
  }

  /**
   * Block.progressions
   */
  export type Block$progressionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgression
     */
    select?: BlockProgressionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressionInclude<ExtArgs> | null
    where?: BlockProgressionWhereInput
    orderBy?: BlockProgressionOrderByWithRelationInput | BlockProgressionOrderByWithRelationInput[]
    cursor?: BlockProgressionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockProgressionScalarFieldEnum | BlockProgressionScalarFieldEnum[]
  }

  /**
   * Block.executions
   */
  export type Block$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
    where?: BlockExecutionWhereInput
    orderBy?: BlockExecutionOrderByWithRelationInput | BlockExecutionOrderByWithRelationInput[]
    cursor?: BlockExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockExecutionScalarFieldEnum | BlockExecutionScalarFieldEnum[]
  }

  /**
   * Block without action
   */
  export type BlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
  }


  /**
   * Model BlockSession
   */

  export type AggregateBlockSession = {
    _count: BlockSessionCountAggregateOutputType | null
    _avg: BlockSessionAvgAggregateOutputType | null
    _sum: BlockSessionSumAggregateOutputType | null
    _min: BlockSessionMinAggregateOutputType | null
    _max: BlockSessionMaxAggregateOutputType | null
  }

  export type BlockSessionAvgAggregateOutputType = {
    dayOfWeek: number | null
    order: number | null
    duration: number | null
    intensity: number | null
    volume: number | null
    rpe: number | null
  }

  export type BlockSessionSumAggregateOutputType = {
    dayOfWeek: number | null
    order: number | null
    duration: number | null
    intensity: number | null
    volume: number | null
    rpe: number | null
  }

  export type BlockSessionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    blockId: string | null
    name: string | null
    dayOfWeek: number | null
    order: number | null
    duration: number | null
    notes: string | null
    intensity: number | null
    volume: number | null
    rpe: number | null
  }

  export type BlockSessionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    blockId: string | null
    name: string | null
    dayOfWeek: number | null
    order: number | null
    duration: number | null
    notes: string | null
    intensity: number | null
    volume: number | null
    rpe: number | null
  }

  export type BlockSessionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    blockId: number
    name: number
    dayOfWeek: number
    order: number
    exercises: number
    duration: number
    notes: number
    intensity: number
    volume: number
    rpe: number
    _all: number
  }


  export type BlockSessionAvgAggregateInputType = {
    dayOfWeek?: true
    order?: true
    duration?: true
    intensity?: true
    volume?: true
    rpe?: true
  }

  export type BlockSessionSumAggregateInputType = {
    dayOfWeek?: true
    order?: true
    duration?: true
    intensity?: true
    volume?: true
    rpe?: true
  }

  export type BlockSessionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    blockId?: true
    name?: true
    dayOfWeek?: true
    order?: true
    duration?: true
    notes?: true
    intensity?: true
    volume?: true
    rpe?: true
  }

  export type BlockSessionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    blockId?: true
    name?: true
    dayOfWeek?: true
    order?: true
    duration?: true
    notes?: true
    intensity?: true
    volume?: true
    rpe?: true
  }

  export type BlockSessionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    blockId?: true
    name?: true
    dayOfWeek?: true
    order?: true
    exercises?: true
    duration?: true
    notes?: true
    intensity?: true
    volume?: true
    rpe?: true
    _all?: true
  }

  export type BlockSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockSession to aggregate.
     */
    where?: BlockSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockSessions to fetch.
     */
    orderBy?: BlockSessionOrderByWithRelationInput | BlockSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockSessions
    **/
    _count?: true | BlockSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlockSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlockSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockSessionMaxAggregateInputType
  }

  export type GetBlockSessionAggregateType<T extends BlockSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockSession[P]>
      : GetScalarType<T[P], AggregateBlockSession[P]>
  }




  export type BlockSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockSessionWhereInput
    orderBy?: BlockSessionOrderByWithAggregationInput | BlockSessionOrderByWithAggregationInput[]
    by: BlockSessionScalarFieldEnum[] | BlockSessionScalarFieldEnum
    having?: BlockSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockSessionCountAggregateInputType | true
    _avg?: BlockSessionAvgAggregateInputType
    _sum?: BlockSessionSumAggregateInputType
    _min?: BlockSessionMinAggregateInputType
    _max?: BlockSessionMaxAggregateInputType
  }

  export type BlockSessionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    blockId: string
    name: string
    dayOfWeek: number
    order: number
    exercises: JsonValue
    duration: number | null
    notes: string | null
    intensity: number | null
    volume: number | null
    rpe: number | null
    _count: BlockSessionCountAggregateOutputType | null
    _avg: BlockSessionAvgAggregateOutputType | null
    _sum: BlockSessionSumAggregateOutputType | null
    _min: BlockSessionMinAggregateOutputType | null
    _max: BlockSessionMaxAggregateOutputType | null
  }

  type GetBlockSessionGroupByPayload<T extends BlockSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockSessionGroupByOutputType[P]>
            : GetScalarType<T[P], BlockSessionGroupByOutputType[P]>
        }
      >
    >


  export type BlockSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    blockId?: boolean
    name?: boolean
    dayOfWeek?: boolean
    order?: boolean
    exercises?: boolean
    duration?: boolean
    notes?: boolean
    intensity?: boolean
    volume?: boolean
    rpe?: boolean
    block?: boolean | BlockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockSession"]>

  export type BlockSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    blockId?: boolean
    name?: boolean
    dayOfWeek?: boolean
    order?: boolean
    exercises?: boolean
    duration?: boolean
    notes?: boolean
    intensity?: boolean
    volume?: boolean
    rpe?: boolean
    block?: boolean | BlockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockSession"]>

  export type BlockSessionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    blockId?: boolean
    name?: boolean
    dayOfWeek?: boolean
    order?: boolean
    exercises?: boolean
    duration?: boolean
    notes?: boolean
    intensity?: boolean
    volume?: boolean
    rpe?: boolean
  }

  export type BlockSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    block?: boolean | BlockDefaultArgs<ExtArgs>
  }
  export type BlockSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    block?: boolean | BlockDefaultArgs<ExtArgs>
  }

  export type $BlockSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlockSession"
    objects: {
      block: Prisma.$BlockPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      blockId: string
      name: string
      dayOfWeek: number
      order: number
      exercises: Prisma.JsonValue
      duration: number | null
      notes: string | null
      intensity: number | null
      volume: number | null
      rpe: number | null
    }, ExtArgs["result"]["blockSession"]>
    composites: {}
  }

  type BlockSessionGetPayload<S extends boolean | null | undefined | BlockSessionDefaultArgs> = $Result.GetResult<Prisma.$BlockSessionPayload, S>

  type BlockSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlockSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlockSessionCountAggregateInputType | true
    }

  export interface BlockSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockSession'], meta: { name: 'BlockSession' } }
    /**
     * Find zero or one BlockSession that matches the filter.
     * @param {BlockSessionFindUniqueArgs} args - Arguments to find a BlockSession
     * @example
     * // Get one BlockSession
     * const blockSession = await prisma.blockSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockSessionFindUniqueArgs>(args: SelectSubset<T, BlockSessionFindUniqueArgs<ExtArgs>>): Prisma__BlockSessionClient<$Result.GetResult<Prisma.$BlockSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlockSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlockSessionFindUniqueOrThrowArgs} args - Arguments to find a BlockSession
     * @example
     * // Get one BlockSession
     * const blockSession = await prisma.blockSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockSessionClient<$Result.GetResult<Prisma.$BlockSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlockSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockSessionFindFirstArgs} args - Arguments to find a BlockSession
     * @example
     * // Get one BlockSession
     * const blockSession = await prisma.blockSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockSessionFindFirstArgs>(args?: SelectSubset<T, BlockSessionFindFirstArgs<ExtArgs>>): Prisma__BlockSessionClient<$Result.GetResult<Prisma.$BlockSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlockSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockSessionFindFirstOrThrowArgs} args - Arguments to find a BlockSession
     * @example
     * // Get one BlockSession
     * const blockSession = await prisma.blockSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockSessionClient<$Result.GetResult<Prisma.$BlockSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlockSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockSessions
     * const blockSessions = await prisma.blockSession.findMany()
     * 
     * // Get first 10 BlockSessions
     * const blockSessions = await prisma.blockSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockSessionWithIdOnly = await prisma.blockSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockSessionFindManyArgs>(args?: SelectSubset<T, BlockSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlockSession.
     * @param {BlockSessionCreateArgs} args - Arguments to create a BlockSession.
     * @example
     * // Create one BlockSession
     * const BlockSession = await prisma.blockSession.create({
     *   data: {
     *     // ... data to create a BlockSession
     *   }
     * })
     * 
     */
    create<T extends BlockSessionCreateArgs>(args: SelectSubset<T, BlockSessionCreateArgs<ExtArgs>>): Prisma__BlockSessionClient<$Result.GetResult<Prisma.$BlockSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlockSessions.
     * @param {BlockSessionCreateManyArgs} args - Arguments to create many BlockSessions.
     * @example
     * // Create many BlockSessions
     * const blockSession = await prisma.blockSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockSessionCreateManyArgs>(args?: SelectSubset<T, BlockSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlockSessions and returns the data saved in the database.
     * @param {BlockSessionCreateManyAndReturnArgs} args - Arguments to create many BlockSessions.
     * @example
     * // Create many BlockSessions
     * const blockSession = await prisma.blockSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlockSessions and only return the `id`
     * const blockSessionWithIdOnly = await prisma.blockSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlockSession.
     * @param {BlockSessionDeleteArgs} args - Arguments to delete one BlockSession.
     * @example
     * // Delete one BlockSession
     * const BlockSession = await prisma.blockSession.delete({
     *   where: {
     *     // ... filter to delete one BlockSession
     *   }
     * })
     * 
     */
    delete<T extends BlockSessionDeleteArgs>(args: SelectSubset<T, BlockSessionDeleteArgs<ExtArgs>>): Prisma__BlockSessionClient<$Result.GetResult<Prisma.$BlockSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlockSession.
     * @param {BlockSessionUpdateArgs} args - Arguments to update one BlockSession.
     * @example
     * // Update one BlockSession
     * const blockSession = await prisma.blockSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockSessionUpdateArgs>(args: SelectSubset<T, BlockSessionUpdateArgs<ExtArgs>>): Prisma__BlockSessionClient<$Result.GetResult<Prisma.$BlockSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlockSessions.
     * @param {BlockSessionDeleteManyArgs} args - Arguments to filter BlockSessions to delete.
     * @example
     * // Delete a few BlockSessions
     * const { count } = await prisma.blockSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockSessionDeleteManyArgs>(args?: SelectSubset<T, BlockSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockSessions
     * const blockSession = await prisma.blockSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockSessionUpdateManyArgs>(args: SelectSubset<T, BlockSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlockSession.
     * @param {BlockSessionUpsertArgs} args - Arguments to update or create a BlockSession.
     * @example
     * // Update or create a BlockSession
     * const blockSession = await prisma.blockSession.upsert({
     *   create: {
     *     // ... data to create a BlockSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockSession we want to update
     *   }
     * })
     */
    upsert<T extends BlockSessionUpsertArgs>(args: SelectSubset<T, BlockSessionUpsertArgs<ExtArgs>>): Prisma__BlockSessionClient<$Result.GetResult<Prisma.$BlockSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlockSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockSessionCountArgs} args - Arguments to filter BlockSessions to count.
     * @example
     * // Count the number of BlockSessions
     * const count = await prisma.blockSession.count({
     *   where: {
     *     // ... the filter for the BlockSessions we want to count
     *   }
     * })
    **/
    count<T extends BlockSessionCountArgs>(
      args?: Subset<T, BlockSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockSessionAggregateArgs>(args: Subset<T, BlockSessionAggregateArgs>): Prisma.PrismaPromise<GetBlockSessionAggregateType<T>>

    /**
     * Group by BlockSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockSessionGroupByArgs['orderBy'] }
        : { orderBy?: BlockSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlockSession model
   */
  readonly fields: BlockSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    block<T extends BlockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlockDefaultArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlockSession model
   */ 
  interface BlockSessionFieldRefs {
    readonly id: FieldRef<"BlockSession", 'String'>
    readonly createdAt: FieldRef<"BlockSession", 'DateTime'>
    readonly updatedAt: FieldRef<"BlockSession", 'DateTime'>
    readonly blockId: FieldRef<"BlockSession", 'String'>
    readonly name: FieldRef<"BlockSession", 'String'>
    readonly dayOfWeek: FieldRef<"BlockSession", 'Int'>
    readonly order: FieldRef<"BlockSession", 'Int'>
    readonly exercises: FieldRef<"BlockSession", 'Json'>
    readonly duration: FieldRef<"BlockSession", 'Int'>
    readonly notes: FieldRef<"BlockSession", 'String'>
    readonly intensity: FieldRef<"BlockSession", 'Float'>
    readonly volume: FieldRef<"BlockSession", 'Float'>
    readonly rpe: FieldRef<"BlockSession", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * BlockSession findUnique
   */
  export type BlockSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockSession
     */
    select?: BlockSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockSessionInclude<ExtArgs> | null
    /**
     * Filter, which BlockSession to fetch.
     */
    where: BlockSessionWhereUniqueInput
  }

  /**
   * BlockSession findUniqueOrThrow
   */
  export type BlockSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockSession
     */
    select?: BlockSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockSessionInclude<ExtArgs> | null
    /**
     * Filter, which BlockSession to fetch.
     */
    where: BlockSessionWhereUniqueInput
  }

  /**
   * BlockSession findFirst
   */
  export type BlockSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockSession
     */
    select?: BlockSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockSessionInclude<ExtArgs> | null
    /**
     * Filter, which BlockSession to fetch.
     */
    where?: BlockSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockSessions to fetch.
     */
    orderBy?: BlockSessionOrderByWithRelationInput | BlockSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockSessions.
     */
    cursor?: BlockSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockSessions.
     */
    distinct?: BlockSessionScalarFieldEnum | BlockSessionScalarFieldEnum[]
  }

  /**
   * BlockSession findFirstOrThrow
   */
  export type BlockSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockSession
     */
    select?: BlockSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockSessionInclude<ExtArgs> | null
    /**
     * Filter, which BlockSession to fetch.
     */
    where?: BlockSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockSessions to fetch.
     */
    orderBy?: BlockSessionOrderByWithRelationInput | BlockSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockSessions.
     */
    cursor?: BlockSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockSessions.
     */
    distinct?: BlockSessionScalarFieldEnum | BlockSessionScalarFieldEnum[]
  }

  /**
   * BlockSession findMany
   */
  export type BlockSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockSession
     */
    select?: BlockSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockSessionInclude<ExtArgs> | null
    /**
     * Filter, which BlockSessions to fetch.
     */
    where?: BlockSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockSessions to fetch.
     */
    orderBy?: BlockSessionOrderByWithRelationInput | BlockSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockSessions.
     */
    cursor?: BlockSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockSessions.
     */
    skip?: number
    distinct?: BlockSessionScalarFieldEnum | BlockSessionScalarFieldEnum[]
  }

  /**
   * BlockSession create
   */
  export type BlockSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockSession
     */
    select?: BlockSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a BlockSession.
     */
    data: XOR<BlockSessionCreateInput, BlockSessionUncheckedCreateInput>
  }

  /**
   * BlockSession createMany
   */
  export type BlockSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockSessions.
     */
    data: BlockSessionCreateManyInput | BlockSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockSession createManyAndReturn
   */
  export type BlockSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockSession
     */
    select?: BlockSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlockSessions.
     */
    data: BlockSessionCreateManyInput | BlockSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockSession update
   */
  export type BlockSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockSession
     */
    select?: BlockSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a BlockSession.
     */
    data: XOR<BlockSessionUpdateInput, BlockSessionUncheckedUpdateInput>
    /**
     * Choose, which BlockSession to update.
     */
    where: BlockSessionWhereUniqueInput
  }

  /**
   * BlockSession updateMany
   */
  export type BlockSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockSessions.
     */
    data: XOR<BlockSessionUpdateManyMutationInput, BlockSessionUncheckedUpdateManyInput>
    /**
     * Filter which BlockSessions to update
     */
    where?: BlockSessionWhereInput
  }

  /**
   * BlockSession upsert
   */
  export type BlockSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockSession
     */
    select?: BlockSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the BlockSession to update in case it exists.
     */
    where: BlockSessionWhereUniqueInput
    /**
     * In case the BlockSession found by the `where` argument doesn't exist, create a new BlockSession with this data.
     */
    create: XOR<BlockSessionCreateInput, BlockSessionUncheckedCreateInput>
    /**
     * In case the BlockSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockSessionUpdateInput, BlockSessionUncheckedUpdateInput>
  }

  /**
   * BlockSession delete
   */
  export type BlockSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockSession
     */
    select?: BlockSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockSessionInclude<ExtArgs> | null
    /**
     * Filter which BlockSession to delete.
     */
    where: BlockSessionWhereUniqueInput
  }

  /**
   * BlockSession deleteMany
   */
  export type BlockSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockSessions to delete
     */
    where?: BlockSessionWhereInput
  }

  /**
   * BlockSession without action
   */
  export type BlockSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockSession
     */
    select?: BlockSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockSessionInclude<ExtArgs> | null
  }


  /**
   * Model BlockProgression
   */

  export type AggregateBlockProgression = {
    _count: BlockProgressionCountAggregateOutputType | null
    _avg: BlockProgressionAvgAggregateOutputType | null
    _sum: BlockProgressionSumAggregateOutputType | null
    _min: BlockProgressionMinAggregateOutputType | null
    _max: BlockProgressionMaxAggregateOutputType | null
  }

  export type BlockProgressionAvgAggregateOutputType = {
    week: number | null
  }

  export type BlockProgressionSumAggregateOutputType = {
    week: number | null
  }

  export type BlockProgressionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    blockId: string | null
    week: number | null
  }

  export type BlockProgressionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    blockId: string | null
    week: number | null
  }

  export type BlockProgressionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    blockId: number
    week: number
    parameters: number
    rules: number
    triggers: number
    _all: number
  }


  export type BlockProgressionAvgAggregateInputType = {
    week?: true
  }

  export type BlockProgressionSumAggregateInputType = {
    week?: true
  }

  export type BlockProgressionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    blockId?: true
    week?: true
  }

  export type BlockProgressionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    blockId?: true
    week?: true
  }

  export type BlockProgressionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    blockId?: true
    week?: true
    parameters?: true
    rules?: true
    triggers?: true
    _all?: true
  }

  export type BlockProgressionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockProgression to aggregate.
     */
    where?: BlockProgressionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockProgressions to fetch.
     */
    orderBy?: BlockProgressionOrderByWithRelationInput | BlockProgressionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockProgressionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockProgressions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockProgressions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockProgressions
    **/
    _count?: true | BlockProgressionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlockProgressionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlockProgressionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockProgressionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockProgressionMaxAggregateInputType
  }

  export type GetBlockProgressionAggregateType<T extends BlockProgressionAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockProgression]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockProgression[P]>
      : GetScalarType<T[P], AggregateBlockProgression[P]>
  }




  export type BlockProgressionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockProgressionWhereInput
    orderBy?: BlockProgressionOrderByWithAggregationInput | BlockProgressionOrderByWithAggregationInput[]
    by: BlockProgressionScalarFieldEnum[] | BlockProgressionScalarFieldEnum
    having?: BlockProgressionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockProgressionCountAggregateInputType | true
    _avg?: BlockProgressionAvgAggregateInputType
    _sum?: BlockProgressionSumAggregateInputType
    _min?: BlockProgressionMinAggregateInputType
    _max?: BlockProgressionMaxAggregateInputType
  }

  export type BlockProgressionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    blockId: string
    week: number
    parameters: JsonValue
    rules: JsonValue | null
    triggers: JsonValue | null
    _count: BlockProgressionCountAggregateOutputType | null
    _avg: BlockProgressionAvgAggregateOutputType | null
    _sum: BlockProgressionSumAggregateOutputType | null
    _min: BlockProgressionMinAggregateOutputType | null
    _max: BlockProgressionMaxAggregateOutputType | null
  }

  type GetBlockProgressionGroupByPayload<T extends BlockProgressionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockProgressionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockProgressionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockProgressionGroupByOutputType[P]>
            : GetScalarType<T[P], BlockProgressionGroupByOutputType[P]>
        }
      >
    >


  export type BlockProgressionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    blockId?: boolean
    week?: boolean
    parameters?: boolean
    rules?: boolean
    triggers?: boolean
    block?: boolean | BlockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockProgression"]>

  export type BlockProgressionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    blockId?: boolean
    week?: boolean
    parameters?: boolean
    rules?: boolean
    triggers?: boolean
    block?: boolean | BlockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockProgression"]>

  export type BlockProgressionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    blockId?: boolean
    week?: boolean
    parameters?: boolean
    rules?: boolean
    triggers?: boolean
  }

  export type BlockProgressionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    block?: boolean | BlockDefaultArgs<ExtArgs>
  }
  export type BlockProgressionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    block?: boolean | BlockDefaultArgs<ExtArgs>
  }

  export type $BlockProgressionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlockProgression"
    objects: {
      block: Prisma.$BlockPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      blockId: string
      week: number
      parameters: Prisma.JsonValue
      rules: Prisma.JsonValue | null
      triggers: Prisma.JsonValue | null
    }, ExtArgs["result"]["blockProgression"]>
    composites: {}
  }

  type BlockProgressionGetPayload<S extends boolean | null | undefined | BlockProgressionDefaultArgs> = $Result.GetResult<Prisma.$BlockProgressionPayload, S>

  type BlockProgressionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlockProgressionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlockProgressionCountAggregateInputType | true
    }

  export interface BlockProgressionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockProgression'], meta: { name: 'BlockProgression' } }
    /**
     * Find zero or one BlockProgression that matches the filter.
     * @param {BlockProgressionFindUniqueArgs} args - Arguments to find a BlockProgression
     * @example
     * // Get one BlockProgression
     * const blockProgression = await prisma.blockProgression.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockProgressionFindUniqueArgs>(args: SelectSubset<T, BlockProgressionFindUniqueArgs<ExtArgs>>): Prisma__BlockProgressionClient<$Result.GetResult<Prisma.$BlockProgressionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlockProgression that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlockProgressionFindUniqueOrThrowArgs} args - Arguments to find a BlockProgression
     * @example
     * // Get one BlockProgression
     * const blockProgression = await prisma.blockProgression.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockProgressionFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockProgressionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockProgressionClient<$Result.GetResult<Prisma.$BlockProgressionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlockProgression that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockProgressionFindFirstArgs} args - Arguments to find a BlockProgression
     * @example
     * // Get one BlockProgression
     * const blockProgression = await prisma.blockProgression.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockProgressionFindFirstArgs>(args?: SelectSubset<T, BlockProgressionFindFirstArgs<ExtArgs>>): Prisma__BlockProgressionClient<$Result.GetResult<Prisma.$BlockProgressionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlockProgression that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockProgressionFindFirstOrThrowArgs} args - Arguments to find a BlockProgression
     * @example
     * // Get one BlockProgression
     * const blockProgression = await prisma.blockProgression.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockProgressionFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockProgressionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockProgressionClient<$Result.GetResult<Prisma.$BlockProgressionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlockProgressions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockProgressionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockProgressions
     * const blockProgressions = await prisma.blockProgression.findMany()
     * 
     * // Get first 10 BlockProgressions
     * const blockProgressions = await prisma.blockProgression.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockProgressionWithIdOnly = await prisma.blockProgression.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockProgressionFindManyArgs>(args?: SelectSubset<T, BlockProgressionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockProgressionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlockProgression.
     * @param {BlockProgressionCreateArgs} args - Arguments to create a BlockProgression.
     * @example
     * // Create one BlockProgression
     * const BlockProgression = await prisma.blockProgression.create({
     *   data: {
     *     // ... data to create a BlockProgression
     *   }
     * })
     * 
     */
    create<T extends BlockProgressionCreateArgs>(args: SelectSubset<T, BlockProgressionCreateArgs<ExtArgs>>): Prisma__BlockProgressionClient<$Result.GetResult<Prisma.$BlockProgressionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlockProgressions.
     * @param {BlockProgressionCreateManyArgs} args - Arguments to create many BlockProgressions.
     * @example
     * // Create many BlockProgressions
     * const blockProgression = await prisma.blockProgression.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockProgressionCreateManyArgs>(args?: SelectSubset<T, BlockProgressionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlockProgressions and returns the data saved in the database.
     * @param {BlockProgressionCreateManyAndReturnArgs} args - Arguments to create many BlockProgressions.
     * @example
     * // Create many BlockProgressions
     * const blockProgression = await prisma.blockProgression.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlockProgressions and only return the `id`
     * const blockProgressionWithIdOnly = await prisma.blockProgression.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockProgressionCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockProgressionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockProgressionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlockProgression.
     * @param {BlockProgressionDeleteArgs} args - Arguments to delete one BlockProgression.
     * @example
     * // Delete one BlockProgression
     * const BlockProgression = await prisma.blockProgression.delete({
     *   where: {
     *     // ... filter to delete one BlockProgression
     *   }
     * })
     * 
     */
    delete<T extends BlockProgressionDeleteArgs>(args: SelectSubset<T, BlockProgressionDeleteArgs<ExtArgs>>): Prisma__BlockProgressionClient<$Result.GetResult<Prisma.$BlockProgressionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlockProgression.
     * @param {BlockProgressionUpdateArgs} args - Arguments to update one BlockProgression.
     * @example
     * // Update one BlockProgression
     * const blockProgression = await prisma.blockProgression.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockProgressionUpdateArgs>(args: SelectSubset<T, BlockProgressionUpdateArgs<ExtArgs>>): Prisma__BlockProgressionClient<$Result.GetResult<Prisma.$BlockProgressionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlockProgressions.
     * @param {BlockProgressionDeleteManyArgs} args - Arguments to filter BlockProgressions to delete.
     * @example
     * // Delete a few BlockProgressions
     * const { count } = await prisma.blockProgression.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockProgressionDeleteManyArgs>(args?: SelectSubset<T, BlockProgressionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockProgressions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockProgressionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockProgressions
     * const blockProgression = await prisma.blockProgression.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockProgressionUpdateManyArgs>(args: SelectSubset<T, BlockProgressionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlockProgression.
     * @param {BlockProgressionUpsertArgs} args - Arguments to update or create a BlockProgression.
     * @example
     * // Update or create a BlockProgression
     * const blockProgression = await prisma.blockProgression.upsert({
     *   create: {
     *     // ... data to create a BlockProgression
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockProgression we want to update
     *   }
     * })
     */
    upsert<T extends BlockProgressionUpsertArgs>(args: SelectSubset<T, BlockProgressionUpsertArgs<ExtArgs>>): Prisma__BlockProgressionClient<$Result.GetResult<Prisma.$BlockProgressionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlockProgressions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockProgressionCountArgs} args - Arguments to filter BlockProgressions to count.
     * @example
     * // Count the number of BlockProgressions
     * const count = await prisma.blockProgression.count({
     *   where: {
     *     // ... the filter for the BlockProgressions we want to count
     *   }
     * })
    **/
    count<T extends BlockProgressionCountArgs>(
      args?: Subset<T, BlockProgressionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockProgressionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockProgression.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockProgressionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockProgressionAggregateArgs>(args: Subset<T, BlockProgressionAggregateArgs>): Prisma.PrismaPromise<GetBlockProgressionAggregateType<T>>

    /**
     * Group by BlockProgression.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockProgressionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockProgressionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockProgressionGroupByArgs['orderBy'] }
        : { orderBy?: BlockProgressionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockProgressionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockProgressionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlockProgression model
   */
  readonly fields: BlockProgressionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockProgression.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockProgressionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    block<T extends BlockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlockDefaultArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlockProgression model
   */ 
  interface BlockProgressionFieldRefs {
    readonly id: FieldRef<"BlockProgression", 'String'>
    readonly createdAt: FieldRef<"BlockProgression", 'DateTime'>
    readonly updatedAt: FieldRef<"BlockProgression", 'DateTime'>
    readonly blockId: FieldRef<"BlockProgression", 'String'>
    readonly week: FieldRef<"BlockProgression", 'Int'>
    readonly parameters: FieldRef<"BlockProgression", 'Json'>
    readonly rules: FieldRef<"BlockProgression", 'Json'>
    readonly triggers: FieldRef<"BlockProgression", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * BlockProgression findUnique
   */
  export type BlockProgressionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgression
     */
    select?: BlockProgressionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressionInclude<ExtArgs> | null
    /**
     * Filter, which BlockProgression to fetch.
     */
    where: BlockProgressionWhereUniqueInput
  }

  /**
   * BlockProgression findUniqueOrThrow
   */
  export type BlockProgressionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgression
     */
    select?: BlockProgressionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressionInclude<ExtArgs> | null
    /**
     * Filter, which BlockProgression to fetch.
     */
    where: BlockProgressionWhereUniqueInput
  }

  /**
   * BlockProgression findFirst
   */
  export type BlockProgressionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgression
     */
    select?: BlockProgressionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressionInclude<ExtArgs> | null
    /**
     * Filter, which BlockProgression to fetch.
     */
    where?: BlockProgressionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockProgressions to fetch.
     */
    orderBy?: BlockProgressionOrderByWithRelationInput | BlockProgressionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockProgressions.
     */
    cursor?: BlockProgressionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockProgressions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockProgressions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockProgressions.
     */
    distinct?: BlockProgressionScalarFieldEnum | BlockProgressionScalarFieldEnum[]
  }

  /**
   * BlockProgression findFirstOrThrow
   */
  export type BlockProgressionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgression
     */
    select?: BlockProgressionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressionInclude<ExtArgs> | null
    /**
     * Filter, which BlockProgression to fetch.
     */
    where?: BlockProgressionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockProgressions to fetch.
     */
    orderBy?: BlockProgressionOrderByWithRelationInput | BlockProgressionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockProgressions.
     */
    cursor?: BlockProgressionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockProgressions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockProgressions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockProgressions.
     */
    distinct?: BlockProgressionScalarFieldEnum | BlockProgressionScalarFieldEnum[]
  }

  /**
   * BlockProgression findMany
   */
  export type BlockProgressionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgression
     */
    select?: BlockProgressionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressionInclude<ExtArgs> | null
    /**
     * Filter, which BlockProgressions to fetch.
     */
    where?: BlockProgressionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockProgressions to fetch.
     */
    orderBy?: BlockProgressionOrderByWithRelationInput | BlockProgressionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockProgressions.
     */
    cursor?: BlockProgressionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockProgressions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockProgressions.
     */
    skip?: number
    distinct?: BlockProgressionScalarFieldEnum | BlockProgressionScalarFieldEnum[]
  }

  /**
   * BlockProgression create
   */
  export type BlockProgressionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgression
     */
    select?: BlockProgressionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressionInclude<ExtArgs> | null
    /**
     * The data needed to create a BlockProgression.
     */
    data: XOR<BlockProgressionCreateInput, BlockProgressionUncheckedCreateInput>
  }

  /**
   * BlockProgression createMany
   */
  export type BlockProgressionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockProgressions.
     */
    data: BlockProgressionCreateManyInput | BlockProgressionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockProgression createManyAndReturn
   */
  export type BlockProgressionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgression
     */
    select?: BlockProgressionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlockProgressions.
     */
    data: BlockProgressionCreateManyInput | BlockProgressionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockProgression update
   */
  export type BlockProgressionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgression
     */
    select?: BlockProgressionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressionInclude<ExtArgs> | null
    /**
     * The data needed to update a BlockProgression.
     */
    data: XOR<BlockProgressionUpdateInput, BlockProgressionUncheckedUpdateInput>
    /**
     * Choose, which BlockProgression to update.
     */
    where: BlockProgressionWhereUniqueInput
  }

  /**
   * BlockProgression updateMany
   */
  export type BlockProgressionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockProgressions.
     */
    data: XOR<BlockProgressionUpdateManyMutationInput, BlockProgressionUncheckedUpdateManyInput>
    /**
     * Filter which BlockProgressions to update
     */
    where?: BlockProgressionWhereInput
  }

  /**
   * BlockProgression upsert
   */
  export type BlockProgressionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgression
     */
    select?: BlockProgressionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressionInclude<ExtArgs> | null
    /**
     * The filter to search for the BlockProgression to update in case it exists.
     */
    where: BlockProgressionWhereUniqueInput
    /**
     * In case the BlockProgression found by the `where` argument doesn't exist, create a new BlockProgression with this data.
     */
    create: XOR<BlockProgressionCreateInput, BlockProgressionUncheckedCreateInput>
    /**
     * In case the BlockProgression was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockProgressionUpdateInput, BlockProgressionUncheckedUpdateInput>
  }

  /**
   * BlockProgression delete
   */
  export type BlockProgressionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgression
     */
    select?: BlockProgressionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressionInclude<ExtArgs> | null
    /**
     * Filter which BlockProgression to delete.
     */
    where: BlockProgressionWhereUniqueInput
  }

  /**
   * BlockProgression deleteMany
   */
  export type BlockProgressionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockProgressions to delete
     */
    where?: BlockProgressionWhereInput
  }

  /**
   * BlockProgression without action
   */
  export type BlockProgressionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgression
     */
    select?: BlockProgressionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressionInclude<ExtArgs> | null
  }


  /**
   * Model ProtocolPermission
   */

  export type AggregateProtocolPermission = {
    _count: ProtocolPermissionCountAggregateOutputType | null
    _min: ProtocolPermissionMinAggregateOutputType | null
    _max: ProtocolPermissionMaxAggregateOutputType | null
  }

  export type ProtocolPermissionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    protocolId: string | null
    userId: string | null
    role: $Enums.PermissionRole | null
    grantedBy: string | null
    grantedAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
  }

  export type ProtocolPermissionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    protocolId: string | null
    userId: string | null
    role: $Enums.PermissionRole | null
    grantedBy: string | null
    grantedAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
  }

  export type ProtocolPermissionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    protocolId: number
    userId: number
    role: number
    permissions: number
    grantedBy: number
    grantedAt: number
    expiresAt: number
    isActive: number
    _all: number
  }


  export type ProtocolPermissionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    protocolId?: true
    userId?: true
    role?: true
    grantedBy?: true
    grantedAt?: true
    expiresAt?: true
    isActive?: true
  }

  export type ProtocolPermissionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    protocolId?: true
    userId?: true
    role?: true
    grantedBy?: true
    grantedAt?: true
    expiresAt?: true
    isActive?: true
  }

  export type ProtocolPermissionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    protocolId?: true
    userId?: true
    role?: true
    permissions?: true
    grantedBy?: true
    grantedAt?: true
    expiresAt?: true
    isActive?: true
    _all?: true
  }

  export type ProtocolPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProtocolPermission to aggregate.
     */
    where?: ProtocolPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProtocolPermissions to fetch.
     */
    orderBy?: ProtocolPermissionOrderByWithRelationInput | ProtocolPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProtocolPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProtocolPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProtocolPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProtocolPermissions
    **/
    _count?: true | ProtocolPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProtocolPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProtocolPermissionMaxAggregateInputType
  }

  export type GetProtocolPermissionAggregateType<T extends ProtocolPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateProtocolPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProtocolPermission[P]>
      : GetScalarType<T[P], AggregateProtocolPermission[P]>
  }




  export type ProtocolPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProtocolPermissionWhereInput
    orderBy?: ProtocolPermissionOrderByWithAggregationInput | ProtocolPermissionOrderByWithAggregationInput[]
    by: ProtocolPermissionScalarFieldEnum[] | ProtocolPermissionScalarFieldEnum
    having?: ProtocolPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProtocolPermissionCountAggregateInputType | true
    _min?: ProtocolPermissionMinAggregateInputType
    _max?: ProtocolPermissionMaxAggregateInputType
  }

  export type ProtocolPermissionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    protocolId: string
    userId: string
    role: $Enums.PermissionRole
    permissions: $Enums.Permission[]
    grantedBy: string
    grantedAt: Date
    expiresAt: Date | null
    isActive: boolean
    _count: ProtocolPermissionCountAggregateOutputType | null
    _min: ProtocolPermissionMinAggregateOutputType | null
    _max: ProtocolPermissionMaxAggregateOutputType | null
  }

  type GetProtocolPermissionGroupByPayload<T extends ProtocolPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProtocolPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProtocolPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProtocolPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], ProtocolPermissionGroupByOutputType[P]>
        }
      >
    >


  export type ProtocolPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    protocolId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    grantedBy?: boolean
    grantedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    protocol?: boolean | ProtocolDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["protocolPermission"]>

  export type ProtocolPermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    protocolId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    grantedBy?: boolean
    grantedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    protocol?: boolean | ProtocolDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["protocolPermission"]>

  export type ProtocolPermissionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    protocolId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    grantedBy?: boolean
    grantedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
  }

  export type ProtocolPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    protocol?: boolean | ProtocolDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProtocolPermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    protocol?: boolean | ProtocolDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProtocolPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProtocolPermission"
    objects: {
      protocol: Prisma.$ProtocolPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      protocolId: string
      userId: string
      role: $Enums.PermissionRole
      permissions: $Enums.Permission[]
      grantedBy: string
      grantedAt: Date
      expiresAt: Date | null
      isActive: boolean
    }, ExtArgs["result"]["protocolPermission"]>
    composites: {}
  }

  type ProtocolPermissionGetPayload<S extends boolean | null | undefined | ProtocolPermissionDefaultArgs> = $Result.GetResult<Prisma.$ProtocolPermissionPayload, S>

  type ProtocolPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProtocolPermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProtocolPermissionCountAggregateInputType | true
    }

  export interface ProtocolPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProtocolPermission'], meta: { name: 'ProtocolPermission' } }
    /**
     * Find zero or one ProtocolPermission that matches the filter.
     * @param {ProtocolPermissionFindUniqueArgs} args - Arguments to find a ProtocolPermission
     * @example
     * // Get one ProtocolPermission
     * const protocolPermission = await prisma.protocolPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProtocolPermissionFindUniqueArgs>(args: SelectSubset<T, ProtocolPermissionFindUniqueArgs<ExtArgs>>): Prisma__ProtocolPermissionClient<$Result.GetResult<Prisma.$ProtocolPermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProtocolPermission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProtocolPermissionFindUniqueOrThrowArgs} args - Arguments to find a ProtocolPermission
     * @example
     * // Get one ProtocolPermission
     * const protocolPermission = await prisma.protocolPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProtocolPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, ProtocolPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProtocolPermissionClient<$Result.GetResult<Prisma.$ProtocolPermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProtocolPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolPermissionFindFirstArgs} args - Arguments to find a ProtocolPermission
     * @example
     * // Get one ProtocolPermission
     * const protocolPermission = await prisma.protocolPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProtocolPermissionFindFirstArgs>(args?: SelectSubset<T, ProtocolPermissionFindFirstArgs<ExtArgs>>): Prisma__ProtocolPermissionClient<$Result.GetResult<Prisma.$ProtocolPermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProtocolPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolPermissionFindFirstOrThrowArgs} args - Arguments to find a ProtocolPermission
     * @example
     * // Get one ProtocolPermission
     * const protocolPermission = await prisma.protocolPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProtocolPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, ProtocolPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProtocolPermissionClient<$Result.GetResult<Prisma.$ProtocolPermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProtocolPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProtocolPermissions
     * const protocolPermissions = await prisma.protocolPermission.findMany()
     * 
     * // Get first 10 ProtocolPermissions
     * const protocolPermissions = await prisma.protocolPermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const protocolPermissionWithIdOnly = await prisma.protocolPermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProtocolPermissionFindManyArgs>(args?: SelectSubset<T, ProtocolPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolPermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProtocolPermission.
     * @param {ProtocolPermissionCreateArgs} args - Arguments to create a ProtocolPermission.
     * @example
     * // Create one ProtocolPermission
     * const ProtocolPermission = await prisma.protocolPermission.create({
     *   data: {
     *     // ... data to create a ProtocolPermission
     *   }
     * })
     * 
     */
    create<T extends ProtocolPermissionCreateArgs>(args: SelectSubset<T, ProtocolPermissionCreateArgs<ExtArgs>>): Prisma__ProtocolPermissionClient<$Result.GetResult<Prisma.$ProtocolPermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProtocolPermissions.
     * @param {ProtocolPermissionCreateManyArgs} args - Arguments to create many ProtocolPermissions.
     * @example
     * // Create many ProtocolPermissions
     * const protocolPermission = await prisma.protocolPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProtocolPermissionCreateManyArgs>(args?: SelectSubset<T, ProtocolPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProtocolPermissions and returns the data saved in the database.
     * @param {ProtocolPermissionCreateManyAndReturnArgs} args - Arguments to create many ProtocolPermissions.
     * @example
     * // Create many ProtocolPermissions
     * const protocolPermission = await prisma.protocolPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProtocolPermissions and only return the `id`
     * const protocolPermissionWithIdOnly = await prisma.protocolPermission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProtocolPermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, ProtocolPermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolPermissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProtocolPermission.
     * @param {ProtocolPermissionDeleteArgs} args - Arguments to delete one ProtocolPermission.
     * @example
     * // Delete one ProtocolPermission
     * const ProtocolPermission = await prisma.protocolPermission.delete({
     *   where: {
     *     // ... filter to delete one ProtocolPermission
     *   }
     * })
     * 
     */
    delete<T extends ProtocolPermissionDeleteArgs>(args: SelectSubset<T, ProtocolPermissionDeleteArgs<ExtArgs>>): Prisma__ProtocolPermissionClient<$Result.GetResult<Prisma.$ProtocolPermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProtocolPermission.
     * @param {ProtocolPermissionUpdateArgs} args - Arguments to update one ProtocolPermission.
     * @example
     * // Update one ProtocolPermission
     * const protocolPermission = await prisma.protocolPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProtocolPermissionUpdateArgs>(args: SelectSubset<T, ProtocolPermissionUpdateArgs<ExtArgs>>): Prisma__ProtocolPermissionClient<$Result.GetResult<Prisma.$ProtocolPermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProtocolPermissions.
     * @param {ProtocolPermissionDeleteManyArgs} args - Arguments to filter ProtocolPermissions to delete.
     * @example
     * // Delete a few ProtocolPermissions
     * const { count } = await prisma.protocolPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProtocolPermissionDeleteManyArgs>(args?: SelectSubset<T, ProtocolPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProtocolPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProtocolPermissions
     * const protocolPermission = await prisma.protocolPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProtocolPermissionUpdateManyArgs>(args: SelectSubset<T, ProtocolPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProtocolPermission.
     * @param {ProtocolPermissionUpsertArgs} args - Arguments to update or create a ProtocolPermission.
     * @example
     * // Update or create a ProtocolPermission
     * const protocolPermission = await prisma.protocolPermission.upsert({
     *   create: {
     *     // ... data to create a ProtocolPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProtocolPermission we want to update
     *   }
     * })
     */
    upsert<T extends ProtocolPermissionUpsertArgs>(args: SelectSubset<T, ProtocolPermissionUpsertArgs<ExtArgs>>): Prisma__ProtocolPermissionClient<$Result.GetResult<Prisma.$ProtocolPermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProtocolPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolPermissionCountArgs} args - Arguments to filter ProtocolPermissions to count.
     * @example
     * // Count the number of ProtocolPermissions
     * const count = await prisma.protocolPermission.count({
     *   where: {
     *     // ... the filter for the ProtocolPermissions we want to count
     *   }
     * })
    **/
    count<T extends ProtocolPermissionCountArgs>(
      args?: Subset<T, ProtocolPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProtocolPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProtocolPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProtocolPermissionAggregateArgs>(args: Subset<T, ProtocolPermissionAggregateArgs>): Prisma.PrismaPromise<GetProtocolPermissionAggregateType<T>>

    /**
     * Group by ProtocolPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProtocolPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProtocolPermissionGroupByArgs['orderBy'] }
        : { orderBy?: ProtocolPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProtocolPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProtocolPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProtocolPermission model
   */
  readonly fields: ProtocolPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProtocolPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProtocolPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    protocol<T extends ProtocolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProtocolDefaultArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProtocolPermission model
   */ 
  interface ProtocolPermissionFieldRefs {
    readonly id: FieldRef<"ProtocolPermission", 'String'>
    readonly createdAt: FieldRef<"ProtocolPermission", 'DateTime'>
    readonly updatedAt: FieldRef<"ProtocolPermission", 'DateTime'>
    readonly protocolId: FieldRef<"ProtocolPermission", 'String'>
    readonly userId: FieldRef<"ProtocolPermission", 'String'>
    readonly role: FieldRef<"ProtocolPermission", 'PermissionRole'>
    readonly permissions: FieldRef<"ProtocolPermission", 'Permission[]'>
    readonly grantedBy: FieldRef<"ProtocolPermission", 'String'>
    readonly grantedAt: FieldRef<"ProtocolPermission", 'DateTime'>
    readonly expiresAt: FieldRef<"ProtocolPermission", 'DateTime'>
    readonly isActive: FieldRef<"ProtocolPermission", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ProtocolPermission findUnique
   */
  export type ProtocolPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolPermission
     */
    select?: ProtocolPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolPermissionInclude<ExtArgs> | null
    /**
     * Filter, which ProtocolPermission to fetch.
     */
    where: ProtocolPermissionWhereUniqueInput
  }

  /**
   * ProtocolPermission findUniqueOrThrow
   */
  export type ProtocolPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolPermission
     */
    select?: ProtocolPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolPermissionInclude<ExtArgs> | null
    /**
     * Filter, which ProtocolPermission to fetch.
     */
    where: ProtocolPermissionWhereUniqueInput
  }

  /**
   * ProtocolPermission findFirst
   */
  export type ProtocolPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolPermission
     */
    select?: ProtocolPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolPermissionInclude<ExtArgs> | null
    /**
     * Filter, which ProtocolPermission to fetch.
     */
    where?: ProtocolPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProtocolPermissions to fetch.
     */
    orderBy?: ProtocolPermissionOrderByWithRelationInput | ProtocolPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProtocolPermissions.
     */
    cursor?: ProtocolPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProtocolPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProtocolPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProtocolPermissions.
     */
    distinct?: ProtocolPermissionScalarFieldEnum | ProtocolPermissionScalarFieldEnum[]
  }

  /**
   * ProtocolPermission findFirstOrThrow
   */
  export type ProtocolPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolPermission
     */
    select?: ProtocolPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolPermissionInclude<ExtArgs> | null
    /**
     * Filter, which ProtocolPermission to fetch.
     */
    where?: ProtocolPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProtocolPermissions to fetch.
     */
    orderBy?: ProtocolPermissionOrderByWithRelationInput | ProtocolPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProtocolPermissions.
     */
    cursor?: ProtocolPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProtocolPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProtocolPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProtocolPermissions.
     */
    distinct?: ProtocolPermissionScalarFieldEnum | ProtocolPermissionScalarFieldEnum[]
  }

  /**
   * ProtocolPermission findMany
   */
  export type ProtocolPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolPermission
     */
    select?: ProtocolPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolPermissionInclude<ExtArgs> | null
    /**
     * Filter, which ProtocolPermissions to fetch.
     */
    where?: ProtocolPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProtocolPermissions to fetch.
     */
    orderBy?: ProtocolPermissionOrderByWithRelationInput | ProtocolPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProtocolPermissions.
     */
    cursor?: ProtocolPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProtocolPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProtocolPermissions.
     */
    skip?: number
    distinct?: ProtocolPermissionScalarFieldEnum | ProtocolPermissionScalarFieldEnum[]
  }

  /**
   * ProtocolPermission create
   */
  export type ProtocolPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolPermission
     */
    select?: ProtocolPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a ProtocolPermission.
     */
    data: XOR<ProtocolPermissionCreateInput, ProtocolPermissionUncheckedCreateInput>
  }

  /**
   * ProtocolPermission createMany
   */
  export type ProtocolPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProtocolPermissions.
     */
    data: ProtocolPermissionCreateManyInput | ProtocolPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProtocolPermission createManyAndReturn
   */
  export type ProtocolPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolPermission
     */
    select?: ProtocolPermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProtocolPermissions.
     */
    data: ProtocolPermissionCreateManyInput | ProtocolPermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolPermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProtocolPermission update
   */
  export type ProtocolPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolPermission
     */
    select?: ProtocolPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a ProtocolPermission.
     */
    data: XOR<ProtocolPermissionUpdateInput, ProtocolPermissionUncheckedUpdateInput>
    /**
     * Choose, which ProtocolPermission to update.
     */
    where: ProtocolPermissionWhereUniqueInput
  }

  /**
   * ProtocolPermission updateMany
   */
  export type ProtocolPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProtocolPermissions.
     */
    data: XOR<ProtocolPermissionUpdateManyMutationInput, ProtocolPermissionUncheckedUpdateManyInput>
    /**
     * Filter which ProtocolPermissions to update
     */
    where?: ProtocolPermissionWhereInput
  }

  /**
   * ProtocolPermission upsert
   */
  export type ProtocolPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolPermission
     */
    select?: ProtocolPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the ProtocolPermission to update in case it exists.
     */
    where: ProtocolPermissionWhereUniqueInput
    /**
     * In case the ProtocolPermission found by the `where` argument doesn't exist, create a new ProtocolPermission with this data.
     */
    create: XOR<ProtocolPermissionCreateInput, ProtocolPermissionUncheckedCreateInput>
    /**
     * In case the ProtocolPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProtocolPermissionUpdateInput, ProtocolPermissionUncheckedUpdateInput>
  }

  /**
   * ProtocolPermission delete
   */
  export type ProtocolPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolPermission
     */
    select?: ProtocolPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolPermissionInclude<ExtArgs> | null
    /**
     * Filter which ProtocolPermission to delete.
     */
    where: ProtocolPermissionWhereUniqueInput
  }

  /**
   * ProtocolPermission deleteMany
   */
  export type ProtocolPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProtocolPermissions to delete
     */
    where?: ProtocolPermissionWhereInput
  }

  /**
   * ProtocolPermission without action
   */
  export type ProtocolPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolPermission
     */
    select?: ProtocolPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolPermissionInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    action: string | null
    resourceType: string | null
    resourceId: string | null
    userId: string | null
    tenantId: string | null
    ip: string | null
    userAgent: string | null
    sessionId: string | null
    result: string | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    action: string | null
    resourceType: string | null
    resourceId: string | null
    userId: string | null
    tenantId: string | null
    ip: string | null
    userAgent: string | null
    sessionId: string | null
    result: string | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    createdAt: number
    action: number
    resourceType: number
    resourceId: number
    userId: number
    tenantId: number
    ip: number
    userAgent: number
    sessionId: number
    details: number
    result: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    createdAt?: true
    action?: true
    resourceType?: true
    resourceId?: true
    userId?: true
    tenantId?: true
    ip?: true
    userAgent?: true
    sessionId?: true
    result?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    createdAt?: true
    action?: true
    resourceType?: true
    resourceId?: true
    userId?: true
    tenantId?: true
    ip?: true
    userAgent?: true
    sessionId?: true
    result?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    createdAt?: true
    action?: true
    resourceType?: true
    resourceId?: true
    userId?: true
    tenantId?: true
    ip?: true
    userAgent?: true
    sessionId?: true
    details?: true
    result?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    createdAt: Date
    action: string
    resourceType: string
    resourceId: string
    userId: string
    tenantId: string
    ip: string | null
    userAgent: string | null
    sessionId: string | null
    details: JsonValue | null
    result: string
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    userId?: boolean
    tenantId?: boolean
    ip?: boolean
    userAgent?: boolean
    sessionId?: boolean
    details?: boolean
    result?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    userId?: boolean
    tenantId?: boolean
    ip?: boolean
    userAgent?: boolean
    sessionId?: boolean
    details?: boolean
    result?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    createdAt?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    userId?: boolean
    tenantId?: boolean
    ip?: boolean
    userAgent?: boolean
    sessionId?: boolean
    details?: boolean
    result?: boolean
  }


  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      action: string
      resourceType: string
      resourceId: string
      userId: string
      tenantId: string
      ip: string | null
      userAgent: string | null
      sessionId: string | null
      details: Prisma.JsonValue | null
      result: string
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resourceType: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly tenantId: FieldRef<"AuditLog", 'String'>
    readonly ip: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly sessionId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly result: FieldRef<"AuditLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
  }


  /**
   * Model ProtocolTemplate
   */

  export type AggregateProtocolTemplate = {
    _count: ProtocolTemplateCountAggregateOutputType | null
    _avg: ProtocolTemplateAvgAggregateOutputType | null
    _sum: ProtocolTemplateSumAggregateOutputType | null
    _min: ProtocolTemplateMinAggregateOutputType | null
    _max: ProtocolTemplateMaxAggregateOutputType | null
  }

  export type ProtocolTemplateAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type ProtocolTemplateSumAggregateOutputType = {
    usageCount: number | null
  }

  export type ProtocolTemplateMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    protocolId: string | null
    name: string | null
    description: string | null
    isDefault: boolean | null
    usageCount: number | null
  }

  export type ProtocolTemplateMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    protocolId: string | null
    name: string | null
    description: string | null
    isDefault: boolean | null
    usageCount: number | null
  }

  export type ProtocolTemplateCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    protocolId: number
    name: number
    description: number
    parameters: number
    isDefault: number
    usageCount: number
    _all: number
  }


  export type ProtocolTemplateAvgAggregateInputType = {
    usageCount?: true
  }

  export type ProtocolTemplateSumAggregateInputType = {
    usageCount?: true
  }

  export type ProtocolTemplateMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    protocolId?: true
    name?: true
    description?: true
    isDefault?: true
    usageCount?: true
  }

  export type ProtocolTemplateMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    protocolId?: true
    name?: true
    description?: true
    isDefault?: true
    usageCount?: true
  }

  export type ProtocolTemplateCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    protocolId?: true
    name?: true
    description?: true
    parameters?: true
    isDefault?: true
    usageCount?: true
    _all?: true
  }

  export type ProtocolTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProtocolTemplate to aggregate.
     */
    where?: ProtocolTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProtocolTemplates to fetch.
     */
    orderBy?: ProtocolTemplateOrderByWithRelationInput | ProtocolTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProtocolTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProtocolTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProtocolTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProtocolTemplates
    **/
    _count?: true | ProtocolTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProtocolTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProtocolTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProtocolTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProtocolTemplateMaxAggregateInputType
  }

  export type GetProtocolTemplateAggregateType<T extends ProtocolTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateProtocolTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProtocolTemplate[P]>
      : GetScalarType<T[P], AggregateProtocolTemplate[P]>
  }




  export type ProtocolTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProtocolTemplateWhereInput
    orderBy?: ProtocolTemplateOrderByWithAggregationInput | ProtocolTemplateOrderByWithAggregationInput[]
    by: ProtocolTemplateScalarFieldEnum[] | ProtocolTemplateScalarFieldEnum
    having?: ProtocolTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProtocolTemplateCountAggregateInputType | true
    _avg?: ProtocolTemplateAvgAggregateInputType
    _sum?: ProtocolTemplateSumAggregateInputType
    _min?: ProtocolTemplateMinAggregateInputType
    _max?: ProtocolTemplateMaxAggregateInputType
  }

  export type ProtocolTemplateGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    protocolId: string
    name: string
    description: string | null
    parameters: JsonValue
    isDefault: boolean
    usageCount: number
    _count: ProtocolTemplateCountAggregateOutputType | null
    _avg: ProtocolTemplateAvgAggregateOutputType | null
    _sum: ProtocolTemplateSumAggregateOutputType | null
    _min: ProtocolTemplateMinAggregateOutputType | null
    _max: ProtocolTemplateMaxAggregateOutputType | null
  }

  type GetProtocolTemplateGroupByPayload<T extends ProtocolTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProtocolTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProtocolTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProtocolTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ProtocolTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ProtocolTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    protocolId?: boolean
    name?: boolean
    description?: boolean
    parameters?: boolean
    isDefault?: boolean
    usageCount?: boolean
    protocol?: boolean | ProtocolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["protocolTemplate"]>

  export type ProtocolTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    protocolId?: boolean
    name?: boolean
    description?: boolean
    parameters?: boolean
    isDefault?: boolean
    usageCount?: boolean
    protocol?: boolean | ProtocolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["protocolTemplate"]>

  export type ProtocolTemplateSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    protocolId?: boolean
    name?: boolean
    description?: boolean
    parameters?: boolean
    isDefault?: boolean
    usageCount?: boolean
  }

  export type ProtocolTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    protocol?: boolean | ProtocolDefaultArgs<ExtArgs>
  }
  export type ProtocolTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    protocol?: boolean | ProtocolDefaultArgs<ExtArgs>
  }

  export type $ProtocolTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProtocolTemplate"
    objects: {
      protocol: Prisma.$ProtocolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      protocolId: string
      name: string
      description: string | null
      parameters: Prisma.JsonValue
      isDefault: boolean
      usageCount: number
    }, ExtArgs["result"]["protocolTemplate"]>
    composites: {}
  }

  type ProtocolTemplateGetPayload<S extends boolean | null | undefined | ProtocolTemplateDefaultArgs> = $Result.GetResult<Prisma.$ProtocolTemplatePayload, S>

  type ProtocolTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProtocolTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProtocolTemplateCountAggregateInputType | true
    }

  export interface ProtocolTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProtocolTemplate'], meta: { name: 'ProtocolTemplate' } }
    /**
     * Find zero or one ProtocolTemplate that matches the filter.
     * @param {ProtocolTemplateFindUniqueArgs} args - Arguments to find a ProtocolTemplate
     * @example
     * // Get one ProtocolTemplate
     * const protocolTemplate = await prisma.protocolTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProtocolTemplateFindUniqueArgs>(args: SelectSubset<T, ProtocolTemplateFindUniqueArgs<ExtArgs>>): Prisma__ProtocolTemplateClient<$Result.GetResult<Prisma.$ProtocolTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProtocolTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProtocolTemplateFindUniqueOrThrowArgs} args - Arguments to find a ProtocolTemplate
     * @example
     * // Get one ProtocolTemplate
     * const protocolTemplate = await prisma.protocolTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProtocolTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, ProtocolTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProtocolTemplateClient<$Result.GetResult<Prisma.$ProtocolTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProtocolTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolTemplateFindFirstArgs} args - Arguments to find a ProtocolTemplate
     * @example
     * // Get one ProtocolTemplate
     * const protocolTemplate = await prisma.protocolTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProtocolTemplateFindFirstArgs>(args?: SelectSubset<T, ProtocolTemplateFindFirstArgs<ExtArgs>>): Prisma__ProtocolTemplateClient<$Result.GetResult<Prisma.$ProtocolTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProtocolTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolTemplateFindFirstOrThrowArgs} args - Arguments to find a ProtocolTemplate
     * @example
     * // Get one ProtocolTemplate
     * const protocolTemplate = await prisma.protocolTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProtocolTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, ProtocolTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProtocolTemplateClient<$Result.GetResult<Prisma.$ProtocolTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProtocolTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProtocolTemplates
     * const protocolTemplates = await prisma.protocolTemplate.findMany()
     * 
     * // Get first 10 ProtocolTemplates
     * const protocolTemplates = await prisma.protocolTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const protocolTemplateWithIdOnly = await prisma.protocolTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProtocolTemplateFindManyArgs>(args?: SelectSubset<T, ProtocolTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProtocolTemplate.
     * @param {ProtocolTemplateCreateArgs} args - Arguments to create a ProtocolTemplate.
     * @example
     * // Create one ProtocolTemplate
     * const ProtocolTemplate = await prisma.protocolTemplate.create({
     *   data: {
     *     // ... data to create a ProtocolTemplate
     *   }
     * })
     * 
     */
    create<T extends ProtocolTemplateCreateArgs>(args: SelectSubset<T, ProtocolTemplateCreateArgs<ExtArgs>>): Prisma__ProtocolTemplateClient<$Result.GetResult<Prisma.$ProtocolTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProtocolTemplates.
     * @param {ProtocolTemplateCreateManyArgs} args - Arguments to create many ProtocolTemplates.
     * @example
     * // Create many ProtocolTemplates
     * const protocolTemplate = await prisma.protocolTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProtocolTemplateCreateManyArgs>(args?: SelectSubset<T, ProtocolTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProtocolTemplates and returns the data saved in the database.
     * @param {ProtocolTemplateCreateManyAndReturnArgs} args - Arguments to create many ProtocolTemplates.
     * @example
     * // Create many ProtocolTemplates
     * const protocolTemplate = await prisma.protocolTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProtocolTemplates and only return the `id`
     * const protocolTemplateWithIdOnly = await prisma.protocolTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProtocolTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, ProtocolTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProtocolTemplate.
     * @param {ProtocolTemplateDeleteArgs} args - Arguments to delete one ProtocolTemplate.
     * @example
     * // Delete one ProtocolTemplate
     * const ProtocolTemplate = await prisma.protocolTemplate.delete({
     *   where: {
     *     // ... filter to delete one ProtocolTemplate
     *   }
     * })
     * 
     */
    delete<T extends ProtocolTemplateDeleteArgs>(args: SelectSubset<T, ProtocolTemplateDeleteArgs<ExtArgs>>): Prisma__ProtocolTemplateClient<$Result.GetResult<Prisma.$ProtocolTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProtocolTemplate.
     * @param {ProtocolTemplateUpdateArgs} args - Arguments to update one ProtocolTemplate.
     * @example
     * // Update one ProtocolTemplate
     * const protocolTemplate = await prisma.protocolTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProtocolTemplateUpdateArgs>(args: SelectSubset<T, ProtocolTemplateUpdateArgs<ExtArgs>>): Prisma__ProtocolTemplateClient<$Result.GetResult<Prisma.$ProtocolTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProtocolTemplates.
     * @param {ProtocolTemplateDeleteManyArgs} args - Arguments to filter ProtocolTemplates to delete.
     * @example
     * // Delete a few ProtocolTemplates
     * const { count } = await prisma.protocolTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProtocolTemplateDeleteManyArgs>(args?: SelectSubset<T, ProtocolTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProtocolTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProtocolTemplates
     * const protocolTemplate = await prisma.protocolTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProtocolTemplateUpdateManyArgs>(args: SelectSubset<T, ProtocolTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProtocolTemplate.
     * @param {ProtocolTemplateUpsertArgs} args - Arguments to update or create a ProtocolTemplate.
     * @example
     * // Update or create a ProtocolTemplate
     * const protocolTemplate = await prisma.protocolTemplate.upsert({
     *   create: {
     *     // ... data to create a ProtocolTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProtocolTemplate we want to update
     *   }
     * })
     */
    upsert<T extends ProtocolTemplateUpsertArgs>(args: SelectSubset<T, ProtocolTemplateUpsertArgs<ExtArgs>>): Prisma__ProtocolTemplateClient<$Result.GetResult<Prisma.$ProtocolTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProtocolTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolTemplateCountArgs} args - Arguments to filter ProtocolTemplates to count.
     * @example
     * // Count the number of ProtocolTemplates
     * const count = await prisma.protocolTemplate.count({
     *   where: {
     *     // ... the filter for the ProtocolTemplates we want to count
     *   }
     * })
    **/
    count<T extends ProtocolTemplateCountArgs>(
      args?: Subset<T, ProtocolTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProtocolTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProtocolTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProtocolTemplateAggregateArgs>(args: Subset<T, ProtocolTemplateAggregateArgs>): Prisma.PrismaPromise<GetProtocolTemplateAggregateType<T>>

    /**
     * Group by ProtocolTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProtocolTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProtocolTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ProtocolTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProtocolTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProtocolTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProtocolTemplate model
   */
  readonly fields: ProtocolTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProtocolTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProtocolTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    protocol<T extends ProtocolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProtocolDefaultArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProtocolTemplate model
   */ 
  interface ProtocolTemplateFieldRefs {
    readonly id: FieldRef<"ProtocolTemplate", 'String'>
    readonly createdAt: FieldRef<"ProtocolTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"ProtocolTemplate", 'DateTime'>
    readonly protocolId: FieldRef<"ProtocolTemplate", 'String'>
    readonly name: FieldRef<"ProtocolTemplate", 'String'>
    readonly description: FieldRef<"ProtocolTemplate", 'String'>
    readonly parameters: FieldRef<"ProtocolTemplate", 'Json'>
    readonly isDefault: FieldRef<"ProtocolTemplate", 'Boolean'>
    readonly usageCount: FieldRef<"ProtocolTemplate", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProtocolTemplate findUnique
   */
  export type ProtocolTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolTemplate
     */
    select?: ProtocolTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ProtocolTemplate to fetch.
     */
    where: ProtocolTemplateWhereUniqueInput
  }

  /**
   * ProtocolTemplate findUniqueOrThrow
   */
  export type ProtocolTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolTemplate
     */
    select?: ProtocolTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ProtocolTemplate to fetch.
     */
    where: ProtocolTemplateWhereUniqueInput
  }

  /**
   * ProtocolTemplate findFirst
   */
  export type ProtocolTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolTemplate
     */
    select?: ProtocolTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ProtocolTemplate to fetch.
     */
    where?: ProtocolTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProtocolTemplates to fetch.
     */
    orderBy?: ProtocolTemplateOrderByWithRelationInput | ProtocolTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProtocolTemplates.
     */
    cursor?: ProtocolTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProtocolTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProtocolTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProtocolTemplates.
     */
    distinct?: ProtocolTemplateScalarFieldEnum | ProtocolTemplateScalarFieldEnum[]
  }

  /**
   * ProtocolTemplate findFirstOrThrow
   */
  export type ProtocolTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolTemplate
     */
    select?: ProtocolTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ProtocolTemplate to fetch.
     */
    where?: ProtocolTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProtocolTemplates to fetch.
     */
    orderBy?: ProtocolTemplateOrderByWithRelationInput | ProtocolTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProtocolTemplates.
     */
    cursor?: ProtocolTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProtocolTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProtocolTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProtocolTemplates.
     */
    distinct?: ProtocolTemplateScalarFieldEnum | ProtocolTemplateScalarFieldEnum[]
  }

  /**
   * ProtocolTemplate findMany
   */
  export type ProtocolTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolTemplate
     */
    select?: ProtocolTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ProtocolTemplates to fetch.
     */
    where?: ProtocolTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProtocolTemplates to fetch.
     */
    orderBy?: ProtocolTemplateOrderByWithRelationInput | ProtocolTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProtocolTemplates.
     */
    cursor?: ProtocolTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProtocolTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProtocolTemplates.
     */
    skip?: number
    distinct?: ProtocolTemplateScalarFieldEnum | ProtocolTemplateScalarFieldEnum[]
  }

  /**
   * ProtocolTemplate create
   */
  export type ProtocolTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolTemplate
     */
    select?: ProtocolTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a ProtocolTemplate.
     */
    data: XOR<ProtocolTemplateCreateInput, ProtocolTemplateUncheckedCreateInput>
  }

  /**
   * ProtocolTemplate createMany
   */
  export type ProtocolTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProtocolTemplates.
     */
    data: ProtocolTemplateCreateManyInput | ProtocolTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProtocolTemplate createManyAndReturn
   */
  export type ProtocolTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolTemplate
     */
    select?: ProtocolTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProtocolTemplates.
     */
    data: ProtocolTemplateCreateManyInput | ProtocolTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProtocolTemplate update
   */
  export type ProtocolTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolTemplate
     */
    select?: ProtocolTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a ProtocolTemplate.
     */
    data: XOR<ProtocolTemplateUpdateInput, ProtocolTemplateUncheckedUpdateInput>
    /**
     * Choose, which ProtocolTemplate to update.
     */
    where: ProtocolTemplateWhereUniqueInput
  }

  /**
   * ProtocolTemplate updateMany
   */
  export type ProtocolTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProtocolTemplates.
     */
    data: XOR<ProtocolTemplateUpdateManyMutationInput, ProtocolTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ProtocolTemplates to update
     */
    where?: ProtocolTemplateWhereInput
  }

  /**
   * ProtocolTemplate upsert
   */
  export type ProtocolTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolTemplate
     */
    select?: ProtocolTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the ProtocolTemplate to update in case it exists.
     */
    where: ProtocolTemplateWhereUniqueInput
    /**
     * In case the ProtocolTemplate found by the `where` argument doesn't exist, create a new ProtocolTemplate with this data.
     */
    create: XOR<ProtocolTemplateCreateInput, ProtocolTemplateUncheckedCreateInput>
    /**
     * In case the ProtocolTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProtocolTemplateUpdateInput, ProtocolTemplateUncheckedUpdateInput>
  }

  /**
   * ProtocolTemplate delete
   */
  export type ProtocolTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolTemplate
     */
    select?: ProtocolTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolTemplateInclude<ExtArgs> | null
    /**
     * Filter which ProtocolTemplate to delete.
     */
    where: ProtocolTemplateWhereUniqueInput
  }

  /**
   * ProtocolTemplate deleteMany
   */
  export type ProtocolTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProtocolTemplates to delete
     */
    where?: ProtocolTemplateWhereInput
  }

  /**
   * ProtocolTemplate without action
   */
  export type ProtocolTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolTemplate
     */
    select?: ProtocolTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolTemplateInclude<ExtArgs> | null
  }


  /**
   * Model ProtocolExecution
   */

  export type AggregateProtocolExecution = {
    _count: ProtocolExecutionCountAggregateOutputType | null
    _avg: ProtocolExecutionAvgAggregateOutputType | null
    _sum: ProtocolExecutionSumAggregateOutputType | null
    _min: ProtocolExecutionMinAggregateOutputType | null
    _max: ProtocolExecutionMaxAggregateOutputType | null
  }

  export type ProtocolExecutionAvgAggregateOutputType = {
    currentWeek: number | null
    progress: number | null
  }

  export type ProtocolExecutionSumAggregateOutputType = {
    currentWeek: number | null
    progress: number | null
  }

  export type ProtocolExecutionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    tenantId: string | null
    protocolId: string | null
    userId: string | null
    templateId: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    dataClassification: $Enums.DataClassification | null
    retentionUntil: Date | null
    currentBlockId: string | null
    currentWeek: number | null
    progress: number | null
  }

  export type ProtocolExecutionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    tenantId: string | null
    protocolId: string | null
    userId: string | null
    templateId: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    dataClassification: $Enums.DataClassification | null
    retentionUntil: Date | null
    currentBlockId: string | null
    currentWeek: number | null
    progress: number | null
  }

  export type ProtocolExecutionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    tenantId: number
    protocolId: number
    userId: number
    templateId: number
    status: number
    startDate: number
    endDate: number
    parameters: number
    adaptations: number
    dataClassification: number
    retentionUntil: number
    currentBlockId: number
    currentWeek: number
    progress: number
    _all: number
  }


  export type ProtocolExecutionAvgAggregateInputType = {
    currentWeek?: true
    progress?: true
  }

  export type ProtocolExecutionSumAggregateInputType = {
    currentWeek?: true
    progress?: true
  }

  export type ProtocolExecutionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    tenantId?: true
    protocolId?: true
    userId?: true
    templateId?: true
    status?: true
    startDate?: true
    endDate?: true
    dataClassification?: true
    retentionUntil?: true
    currentBlockId?: true
    currentWeek?: true
    progress?: true
  }

  export type ProtocolExecutionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    tenantId?: true
    protocolId?: true
    userId?: true
    templateId?: true
    status?: true
    startDate?: true
    endDate?: true
    dataClassification?: true
    retentionUntil?: true
    currentBlockId?: true
    currentWeek?: true
    progress?: true
  }

  export type ProtocolExecutionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    tenantId?: true
    protocolId?: true
    userId?: true
    templateId?: true
    status?: true
    startDate?: true
    endDate?: true
    parameters?: true
    adaptations?: true
    dataClassification?: true
    retentionUntil?: true
    currentBlockId?: true
    currentWeek?: true
    progress?: true
    _all?: true
  }

  export type ProtocolExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProtocolExecution to aggregate.
     */
    where?: ProtocolExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProtocolExecutions to fetch.
     */
    orderBy?: ProtocolExecutionOrderByWithRelationInput | ProtocolExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProtocolExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProtocolExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProtocolExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProtocolExecutions
    **/
    _count?: true | ProtocolExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProtocolExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProtocolExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProtocolExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProtocolExecutionMaxAggregateInputType
  }

  export type GetProtocolExecutionAggregateType<T extends ProtocolExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateProtocolExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProtocolExecution[P]>
      : GetScalarType<T[P], AggregateProtocolExecution[P]>
  }




  export type ProtocolExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProtocolExecutionWhereInput
    orderBy?: ProtocolExecutionOrderByWithAggregationInput | ProtocolExecutionOrderByWithAggregationInput[]
    by: ProtocolExecutionScalarFieldEnum[] | ProtocolExecutionScalarFieldEnum
    having?: ProtocolExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProtocolExecutionCountAggregateInputType | true
    _avg?: ProtocolExecutionAvgAggregateInputType
    _sum?: ProtocolExecutionSumAggregateInputType
    _min?: ProtocolExecutionMinAggregateInputType
    _max?: ProtocolExecutionMaxAggregateInputType
  }

  export type ProtocolExecutionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    tenantId: string
    protocolId: string
    userId: string
    templateId: string | null
    status: string
    startDate: Date
    endDate: Date | null
    parameters: JsonValue
    adaptations: JsonValue | null
    dataClassification: $Enums.DataClassification
    retentionUntil: Date | null
    currentBlockId: string | null
    currentWeek: number
    progress: number
    _count: ProtocolExecutionCountAggregateOutputType | null
    _avg: ProtocolExecutionAvgAggregateOutputType | null
    _sum: ProtocolExecutionSumAggregateOutputType | null
    _min: ProtocolExecutionMinAggregateOutputType | null
    _max: ProtocolExecutionMaxAggregateOutputType | null
  }

  type GetProtocolExecutionGroupByPayload<T extends ProtocolExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProtocolExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProtocolExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProtocolExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], ProtocolExecutionGroupByOutputType[P]>
        }
      >
    >


  export type ProtocolExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenantId?: boolean
    protocolId?: boolean
    userId?: boolean
    templateId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    parameters?: boolean
    adaptations?: boolean
    dataClassification?: boolean
    retentionUntil?: boolean
    currentBlockId?: boolean
    currentWeek?: boolean
    progress?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    protocol?: boolean | ProtocolDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    blockExecutions?: boolean | ProtocolExecution$blockExecutionsArgs<ExtArgs>
    sessions?: boolean | ProtocolExecution$sessionsArgs<ExtArgs>
    _count?: boolean | ProtocolExecutionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["protocolExecution"]>

  export type ProtocolExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenantId?: boolean
    protocolId?: boolean
    userId?: boolean
    templateId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    parameters?: boolean
    adaptations?: boolean
    dataClassification?: boolean
    retentionUntil?: boolean
    currentBlockId?: boolean
    currentWeek?: boolean
    progress?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    protocol?: boolean | ProtocolDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["protocolExecution"]>

  export type ProtocolExecutionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenantId?: boolean
    protocolId?: boolean
    userId?: boolean
    templateId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    parameters?: boolean
    adaptations?: boolean
    dataClassification?: boolean
    retentionUntil?: boolean
    currentBlockId?: boolean
    currentWeek?: boolean
    progress?: boolean
  }

  export type ProtocolExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    protocol?: boolean | ProtocolDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    blockExecutions?: boolean | ProtocolExecution$blockExecutionsArgs<ExtArgs>
    sessions?: boolean | ProtocolExecution$sessionsArgs<ExtArgs>
    _count?: boolean | ProtocolExecutionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProtocolExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    protocol?: boolean | ProtocolDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProtocolExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProtocolExecution"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      protocol: Prisma.$ProtocolPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      blockExecutions: Prisma.$BlockExecutionPayload<ExtArgs>[]
      sessions: Prisma.$SessionExecutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      tenantId: string
      protocolId: string
      userId: string
      templateId: string | null
      status: string
      startDate: Date
      endDate: Date | null
      parameters: Prisma.JsonValue
      adaptations: Prisma.JsonValue | null
      dataClassification: $Enums.DataClassification
      retentionUntil: Date | null
      currentBlockId: string | null
      currentWeek: number
      progress: number
    }, ExtArgs["result"]["protocolExecution"]>
    composites: {}
  }

  type ProtocolExecutionGetPayload<S extends boolean | null | undefined | ProtocolExecutionDefaultArgs> = $Result.GetResult<Prisma.$ProtocolExecutionPayload, S>

  type ProtocolExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProtocolExecutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProtocolExecutionCountAggregateInputType | true
    }

  export interface ProtocolExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProtocolExecution'], meta: { name: 'ProtocolExecution' } }
    /**
     * Find zero or one ProtocolExecution that matches the filter.
     * @param {ProtocolExecutionFindUniqueArgs} args - Arguments to find a ProtocolExecution
     * @example
     * // Get one ProtocolExecution
     * const protocolExecution = await prisma.protocolExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProtocolExecutionFindUniqueArgs>(args: SelectSubset<T, ProtocolExecutionFindUniqueArgs<ExtArgs>>): Prisma__ProtocolExecutionClient<$Result.GetResult<Prisma.$ProtocolExecutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProtocolExecution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProtocolExecutionFindUniqueOrThrowArgs} args - Arguments to find a ProtocolExecution
     * @example
     * // Get one ProtocolExecution
     * const protocolExecution = await prisma.protocolExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProtocolExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, ProtocolExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProtocolExecutionClient<$Result.GetResult<Prisma.$ProtocolExecutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProtocolExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolExecutionFindFirstArgs} args - Arguments to find a ProtocolExecution
     * @example
     * // Get one ProtocolExecution
     * const protocolExecution = await prisma.protocolExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProtocolExecutionFindFirstArgs>(args?: SelectSubset<T, ProtocolExecutionFindFirstArgs<ExtArgs>>): Prisma__ProtocolExecutionClient<$Result.GetResult<Prisma.$ProtocolExecutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProtocolExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolExecutionFindFirstOrThrowArgs} args - Arguments to find a ProtocolExecution
     * @example
     * // Get one ProtocolExecution
     * const protocolExecution = await prisma.protocolExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProtocolExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, ProtocolExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProtocolExecutionClient<$Result.GetResult<Prisma.$ProtocolExecutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProtocolExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProtocolExecutions
     * const protocolExecutions = await prisma.protocolExecution.findMany()
     * 
     * // Get first 10 ProtocolExecutions
     * const protocolExecutions = await prisma.protocolExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const protocolExecutionWithIdOnly = await prisma.protocolExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProtocolExecutionFindManyArgs>(args?: SelectSubset<T, ProtocolExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolExecutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProtocolExecution.
     * @param {ProtocolExecutionCreateArgs} args - Arguments to create a ProtocolExecution.
     * @example
     * // Create one ProtocolExecution
     * const ProtocolExecution = await prisma.protocolExecution.create({
     *   data: {
     *     // ... data to create a ProtocolExecution
     *   }
     * })
     * 
     */
    create<T extends ProtocolExecutionCreateArgs>(args: SelectSubset<T, ProtocolExecutionCreateArgs<ExtArgs>>): Prisma__ProtocolExecutionClient<$Result.GetResult<Prisma.$ProtocolExecutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProtocolExecutions.
     * @param {ProtocolExecutionCreateManyArgs} args - Arguments to create many ProtocolExecutions.
     * @example
     * // Create many ProtocolExecutions
     * const protocolExecution = await prisma.protocolExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProtocolExecutionCreateManyArgs>(args?: SelectSubset<T, ProtocolExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProtocolExecutions and returns the data saved in the database.
     * @param {ProtocolExecutionCreateManyAndReturnArgs} args - Arguments to create many ProtocolExecutions.
     * @example
     * // Create many ProtocolExecutions
     * const protocolExecution = await prisma.protocolExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProtocolExecutions and only return the `id`
     * const protocolExecutionWithIdOnly = await prisma.protocolExecution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProtocolExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, ProtocolExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolExecutionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProtocolExecution.
     * @param {ProtocolExecutionDeleteArgs} args - Arguments to delete one ProtocolExecution.
     * @example
     * // Delete one ProtocolExecution
     * const ProtocolExecution = await prisma.protocolExecution.delete({
     *   where: {
     *     // ... filter to delete one ProtocolExecution
     *   }
     * })
     * 
     */
    delete<T extends ProtocolExecutionDeleteArgs>(args: SelectSubset<T, ProtocolExecutionDeleteArgs<ExtArgs>>): Prisma__ProtocolExecutionClient<$Result.GetResult<Prisma.$ProtocolExecutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProtocolExecution.
     * @param {ProtocolExecutionUpdateArgs} args - Arguments to update one ProtocolExecution.
     * @example
     * // Update one ProtocolExecution
     * const protocolExecution = await prisma.protocolExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProtocolExecutionUpdateArgs>(args: SelectSubset<T, ProtocolExecutionUpdateArgs<ExtArgs>>): Prisma__ProtocolExecutionClient<$Result.GetResult<Prisma.$ProtocolExecutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProtocolExecutions.
     * @param {ProtocolExecutionDeleteManyArgs} args - Arguments to filter ProtocolExecutions to delete.
     * @example
     * // Delete a few ProtocolExecutions
     * const { count } = await prisma.protocolExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProtocolExecutionDeleteManyArgs>(args?: SelectSubset<T, ProtocolExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProtocolExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProtocolExecutions
     * const protocolExecution = await prisma.protocolExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProtocolExecutionUpdateManyArgs>(args: SelectSubset<T, ProtocolExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProtocolExecution.
     * @param {ProtocolExecutionUpsertArgs} args - Arguments to update or create a ProtocolExecution.
     * @example
     * // Update or create a ProtocolExecution
     * const protocolExecution = await prisma.protocolExecution.upsert({
     *   create: {
     *     // ... data to create a ProtocolExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProtocolExecution we want to update
     *   }
     * })
     */
    upsert<T extends ProtocolExecutionUpsertArgs>(args: SelectSubset<T, ProtocolExecutionUpsertArgs<ExtArgs>>): Prisma__ProtocolExecutionClient<$Result.GetResult<Prisma.$ProtocolExecutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProtocolExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolExecutionCountArgs} args - Arguments to filter ProtocolExecutions to count.
     * @example
     * // Count the number of ProtocolExecutions
     * const count = await prisma.protocolExecution.count({
     *   where: {
     *     // ... the filter for the ProtocolExecutions we want to count
     *   }
     * })
    **/
    count<T extends ProtocolExecutionCountArgs>(
      args?: Subset<T, ProtocolExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProtocolExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProtocolExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProtocolExecutionAggregateArgs>(args: Subset<T, ProtocolExecutionAggregateArgs>): Prisma.PrismaPromise<GetProtocolExecutionAggregateType<T>>

    /**
     * Group by ProtocolExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProtocolExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProtocolExecutionGroupByArgs['orderBy'] }
        : { orderBy?: ProtocolExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProtocolExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProtocolExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProtocolExecution model
   */
  readonly fields: ProtocolExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProtocolExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProtocolExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    protocol<T extends ProtocolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProtocolDefaultArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    blockExecutions<T extends ProtocolExecution$blockExecutionsArgs<ExtArgs> = {}>(args?: Subset<T, ProtocolExecution$blockExecutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends ProtocolExecution$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, ProtocolExecution$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProtocolExecution model
   */ 
  interface ProtocolExecutionFieldRefs {
    readonly id: FieldRef<"ProtocolExecution", 'String'>
    readonly createdAt: FieldRef<"ProtocolExecution", 'DateTime'>
    readonly updatedAt: FieldRef<"ProtocolExecution", 'DateTime'>
    readonly tenantId: FieldRef<"ProtocolExecution", 'String'>
    readonly protocolId: FieldRef<"ProtocolExecution", 'String'>
    readonly userId: FieldRef<"ProtocolExecution", 'String'>
    readonly templateId: FieldRef<"ProtocolExecution", 'String'>
    readonly status: FieldRef<"ProtocolExecution", 'String'>
    readonly startDate: FieldRef<"ProtocolExecution", 'DateTime'>
    readonly endDate: FieldRef<"ProtocolExecution", 'DateTime'>
    readonly parameters: FieldRef<"ProtocolExecution", 'Json'>
    readonly adaptations: FieldRef<"ProtocolExecution", 'Json'>
    readonly dataClassification: FieldRef<"ProtocolExecution", 'DataClassification'>
    readonly retentionUntil: FieldRef<"ProtocolExecution", 'DateTime'>
    readonly currentBlockId: FieldRef<"ProtocolExecution", 'String'>
    readonly currentWeek: FieldRef<"ProtocolExecution", 'Int'>
    readonly progress: FieldRef<"ProtocolExecution", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ProtocolExecution findUnique
   */
  export type ProtocolExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolExecution
     */
    select?: ProtocolExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ProtocolExecution to fetch.
     */
    where: ProtocolExecutionWhereUniqueInput
  }

  /**
   * ProtocolExecution findUniqueOrThrow
   */
  export type ProtocolExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolExecution
     */
    select?: ProtocolExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ProtocolExecution to fetch.
     */
    where: ProtocolExecutionWhereUniqueInput
  }

  /**
   * ProtocolExecution findFirst
   */
  export type ProtocolExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolExecution
     */
    select?: ProtocolExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ProtocolExecution to fetch.
     */
    where?: ProtocolExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProtocolExecutions to fetch.
     */
    orderBy?: ProtocolExecutionOrderByWithRelationInput | ProtocolExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProtocolExecutions.
     */
    cursor?: ProtocolExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProtocolExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProtocolExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProtocolExecutions.
     */
    distinct?: ProtocolExecutionScalarFieldEnum | ProtocolExecutionScalarFieldEnum[]
  }

  /**
   * ProtocolExecution findFirstOrThrow
   */
  export type ProtocolExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolExecution
     */
    select?: ProtocolExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ProtocolExecution to fetch.
     */
    where?: ProtocolExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProtocolExecutions to fetch.
     */
    orderBy?: ProtocolExecutionOrderByWithRelationInput | ProtocolExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProtocolExecutions.
     */
    cursor?: ProtocolExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProtocolExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProtocolExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProtocolExecutions.
     */
    distinct?: ProtocolExecutionScalarFieldEnum | ProtocolExecutionScalarFieldEnum[]
  }

  /**
   * ProtocolExecution findMany
   */
  export type ProtocolExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolExecution
     */
    select?: ProtocolExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ProtocolExecutions to fetch.
     */
    where?: ProtocolExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProtocolExecutions to fetch.
     */
    orderBy?: ProtocolExecutionOrderByWithRelationInput | ProtocolExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProtocolExecutions.
     */
    cursor?: ProtocolExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProtocolExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProtocolExecutions.
     */
    skip?: number
    distinct?: ProtocolExecutionScalarFieldEnum | ProtocolExecutionScalarFieldEnum[]
  }

  /**
   * ProtocolExecution create
   */
  export type ProtocolExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolExecution
     */
    select?: ProtocolExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a ProtocolExecution.
     */
    data: XOR<ProtocolExecutionCreateInput, ProtocolExecutionUncheckedCreateInput>
  }

  /**
   * ProtocolExecution createMany
   */
  export type ProtocolExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProtocolExecutions.
     */
    data: ProtocolExecutionCreateManyInput | ProtocolExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProtocolExecution createManyAndReturn
   */
  export type ProtocolExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolExecution
     */
    select?: ProtocolExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProtocolExecutions.
     */
    data: ProtocolExecutionCreateManyInput | ProtocolExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProtocolExecution update
   */
  export type ProtocolExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolExecution
     */
    select?: ProtocolExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a ProtocolExecution.
     */
    data: XOR<ProtocolExecutionUpdateInput, ProtocolExecutionUncheckedUpdateInput>
    /**
     * Choose, which ProtocolExecution to update.
     */
    where: ProtocolExecutionWhereUniqueInput
  }

  /**
   * ProtocolExecution updateMany
   */
  export type ProtocolExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProtocolExecutions.
     */
    data: XOR<ProtocolExecutionUpdateManyMutationInput, ProtocolExecutionUncheckedUpdateManyInput>
    /**
     * Filter which ProtocolExecutions to update
     */
    where?: ProtocolExecutionWhereInput
  }

  /**
   * ProtocolExecution upsert
   */
  export type ProtocolExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolExecution
     */
    select?: ProtocolExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the ProtocolExecution to update in case it exists.
     */
    where: ProtocolExecutionWhereUniqueInput
    /**
     * In case the ProtocolExecution found by the `where` argument doesn't exist, create a new ProtocolExecution with this data.
     */
    create: XOR<ProtocolExecutionCreateInput, ProtocolExecutionUncheckedCreateInput>
    /**
     * In case the ProtocolExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProtocolExecutionUpdateInput, ProtocolExecutionUncheckedUpdateInput>
  }

  /**
   * ProtocolExecution delete
   */
  export type ProtocolExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolExecution
     */
    select?: ProtocolExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolExecutionInclude<ExtArgs> | null
    /**
     * Filter which ProtocolExecution to delete.
     */
    where: ProtocolExecutionWhereUniqueInput
  }

  /**
   * ProtocolExecution deleteMany
   */
  export type ProtocolExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProtocolExecutions to delete
     */
    where?: ProtocolExecutionWhereInput
  }

  /**
   * ProtocolExecution.blockExecutions
   */
  export type ProtocolExecution$blockExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
    where?: BlockExecutionWhereInput
    orderBy?: BlockExecutionOrderByWithRelationInput | BlockExecutionOrderByWithRelationInput[]
    cursor?: BlockExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockExecutionScalarFieldEnum | BlockExecutionScalarFieldEnum[]
  }

  /**
   * ProtocolExecution.sessions
   */
  export type ProtocolExecution$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExecution
     */
    select?: SessionExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExecutionInclude<ExtArgs> | null
    where?: SessionExecutionWhereInput
    orderBy?: SessionExecutionOrderByWithRelationInput | SessionExecutionOrderByWithRelationInput[]
    cursor?: SessionExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionExecutionScalarFieldEnum | SessionExecutionScalarFieldEnum[]
  }

  /**
   * ProtocolExecution without action
   */
  export type ProtocolExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolExecution
     */
    select?: ProtocolExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolExecutionInclude<ExtArgs> | null
  }


  /**
   * Model BlockExecution
   */

  export type AggregateBlockExecution = {
    _count: BlockExecutionCountAggregateOutputType | null
    _avg: BlockExecutionAvgAggregateOutputType | null
    _sum: BlockExecutionSumAggregateOutputType | null
    _min: BlockExecutionMinAggregateOutputType | null
    _max: BlockExecutionMaxAggregateOutputType | null
  }

  export type BlockExecutionAvgAggregateOutputType = {
    currentWeek: number | null
    progress: number | null
  }

  export type BlockExecutionSumAggregateOutputType = {
    currentWeek: number | null
    progress: number | null
  }

  export type BlockExecutionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    executionId: string | null
    blockId: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    notes: string | null
    currentWeek: number | null
    progress: number | null
  }

  export type BlockExecutionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    executionId: string | null
    blockId: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    notes: string | null
    currentWeek: number | null
    progress: number | null
  }

  export type BlockExecutionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    executionId: number
    blockId: number
    status: number
    startDate: number
    endDate: number
    adaptations: number
    notes: number
    currentWeek: number
    progress: number
    _all: number
  }


  export type BlockExecutionAvgAggregateInputType = {
    currentWeek?: true
    progress?: true
  }

  export type BlockExecutionSumAggregateInputType = {
    currentWeek?: true
    progress?: true
  }

  export type BlockExecutionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    executionId?: true
    blockId?: true
    status?: true
    startDate?: true
    endDate?: true
    notes?: true
    currentWeek?: true
    progress?: true
  }

  export type BlockExecutionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    executionId?: true
    blockId?: true
    status?: true
    startDate?: true
    endDate?: true
    notes?: true
    currentWeek?: true
    progress?: true
  }

  export type BlockExecutionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    executionId?: true
    blockId?: true
    status?: true
    startDate?: true
    endDate?: true
    adaptations?: true
    notes?: true
    currentWeek?: true
    progress?: true
    _all?: true
  }

  export type BlockExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockExecution to aggregate.
     */
    where?: BlockExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockExecutions to fetch.
     */
    orderBy?: BlockExecutionOrderByWithRelationInput | BlockExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockExecutions
    **/
    _count?: true | BlockExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlockExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlockExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockExecutionMaxAggregateInputType
  }

  export type GetBlockExecutionAggregateType<T extends BlockExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockExecution[P]>
      : GetScalarType<T[P], AggregateBlockExecution[P]>
  }




  export type BlockExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockExecutionWhereInput
    orderBy?: BlockExecutionOrderByWithAggregationInput | BlockExecutionOrderByWithAggregationInput[]
    by: BlockExecutionScalarFieldEnum[] | BlockExecutionScalarFieldEnum
    having?: BlockExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockExecutionCountAggregateInputType | true
    _avg?: BlockExecutionAvgAggregateInputType
    _sum?: BlockExecutionSumAggregateInputType
    _min?: BlockExecutionMinAggregateInputType
    _max?: BlockExecutionMaxAggregateInputType
  }

  export type BlockExecutionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    executionId: string
    blockId: string
    status: string
    startDate: Date | null
    endDate: Date | null
    adaptations: JsonValue | null
    notes: string | null
    currentWeek: number
    progress: number
    _count: BlockExecutionCountAggregateOutputType | null
    _avg: BlockExecutionAvgAggregateOutputType | null
    _sum: BlockExecutionSumAggregateOutputType | null
    _min: BlockExecutionMinAggregateOutputType | null
    _max: BlockExecutionMaxAggregateOutputType | null
  }

  type GetBlockExecutionGroupByPayload<T extends BlockExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], BlockExecutionGroupByOutputType[P]>
        }
      >
    >


  export type BlockExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    executionId?: boolean
    blockId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    adaptations?: boolean
    notes?: boolean
    currentWeek?: boolean
    progress?: boolean
    execution?: boolean | ProtocolExecutionDefaultArgs<ExtArgs>
    block?: boolean | BlockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockExecution"]>

  export type BlockExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    executionId?: boolean
    blockId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    adaptations?: boolean
    notes?: boolean
    currentWeek?: boolean
    progress?: boolean
    execution?: boolean | ProtocolExecutionDefaultArgs<ExtArgs>
    block?: boolean | BlockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockExecution"]>

  export type BlockExecutionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    executionId?: boolean
    blockId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    adaptations?: boolean
    notes?: boolean
    currentWeek?: boolean
    progress?: boolean
  }

  export type BlockExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    execution?: boolean | ProtocolExecutionDefaultArgs<ExtArgs>
    block?: boolean | BlockDefaultArgs<ExtArgs>
  }
  export type BlockExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    execution?: boolean | ProtocolExecutionDefaultArgs<ExtArgs>
    block?: boolean | BlockDefaultArgs<ExtArgs>
  }

  export type $BlockExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlockExecution"
    objects: {
      execution: Prisma.$ProtocolExecutionPayload<ExtArgs>
      block: Prisma.$BlockPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      executionId: string
      blockId: string
      status: string
      startDate: Date | null
      endDate: Date | null
      adaptations: Prisma.JsonValue | null
      notes: string | null
      currentWeek: number
      progress: number
    }, ExtArgs["result"]["blockExecution"]>
    composites: {}
  }

  type BlockExecutionGetPayload<S extends boolean | null | undefined | BlockExecutionDefaultArgs> = $Result.GetResult<Prisma.$BlockExecutionPayload, S>

  type BlockExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlockExecutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlockExecutionCountAggregateInputType | true
    }

  export interface BlockExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockExecution'], meta: { name: 'BlockExecution' } }
    /**
     * Find zero or one BlockExecution that matches the filter.
     * @param {BlockExecutionFindUniqueArgs} args - Arguments to find a BlockExecution
     * @example
     * // Get one BlockExecution
     * const blockExecution = await prisma.blockExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockExecutionFindUniqueArgs>(args: SelectSubset<T, BlockExecutionFindUniqueArgs<ExtArgs>>): Prisma__BlockExecutionClient<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlockExecution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlockExecutionFindUniqueOrThrowArgs} args - Arguments to find a BlockExecution
     * @example
     * // Get one BlockExecution
     * const blockExecution = await prisma.blockExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockExecutionClient<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlockExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockExecutionFindFirstArgs} args - Arguments to find a BlockExecution
     * @example
     * // Get one BlockExecution
     * const blockExecution = await prisma.blockExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockExecutionFindFirstArgs>(args?: SelectSubset<T, BlockExecutionFindFirstArgs<ExtArgs>>): Prisma__BlockExecutionClient<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlockExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockExecutionFindFirstOrThrowArgs} args - Arguments to find a BlockExecution
     * @example
     * // Get one BlockExecution
     * const blockExecution = await prisma.blockExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockExecutionClient<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlockExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockExecutions
     * const blockExecutions = await prisma.blockExecution.findMany()
     * 
     * // Get first 10 BlockExecutions
     * const blockExecutions = await prisma.blockExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockExecutionWithIdOnly = await prisma.blockExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockExecutionFindManyArgs>(args?: SelectSubset<T, BlockExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlockExecution.
     * @param {BlockExecutionCreateArgs} args - Arguments to create a BlockExecution.
     * @example
     * // Create one BlockExecution
     * const BlockExecution = await prisma.blockExecution.create({
     *   data: {
     *     // ... data to create a BlockExecution
     *   }
     * })
     * 
     */
    create<T extends BlockExecutionCreateArgs>(args: SelectSubset<T, BlockExecutionCreateArgs<ExtArgs>>): Prisma__BlockExecutionClient<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlockExecutions.
     * @param {BlockExecutionCreateManyArgs} args - Arguments to create many BlockExecutions.
     * @example
     * // Create many BlockExecutions
     * const blockExecution = await prisma.blockExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockExecutionCreateManyArgs>(args?: SelectSubset<T, BlockExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlockExecutions and returns the data saved in the database.
     * @param {BlockExecutionCreateManyAndReturnArgs} args - Arguments to create many BlockExecutions.
     * @example
     * // Create many BlockExecutions
     * const blockExecution = await prisma.blockExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlockExecutions and only return the `id`
     * const blockExecutionWithIdOnly = await prisma.blockExecution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlockExecution.
     * @param {BlockExecutionDeleteArgs} args - Arguments to delete one BlockExecution.
     * @example
     * // Delete one BlockExecution
     * const BlockExecution = await prisma.blockExecution.delete({
     *   where: {
     *     // ... filter to delete one BlockExecution
     *   }
     * })
     * 
     */
    delete<T extends BlockExecutionDeleteArgs>(args: SelectSubset<T, BlockExecutionDeleteArgs<ExtArgs>>): Prisma__BlockExecutionClient<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlockExecution.
     * @param {BlockExecutionUpdateArgs} args - Arguments to update one BlockExecution.
     * @example
     * // Update one BlockExecution
     * const blockExecution = await prisma.blockExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockExecutionUpdateArgs>(args: SelectSubset<T, BlockExecutionUpdateArgs<ExtArgs>>): Prisma__BlockExecutionClient<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlockExecutions.
     * @param {BlockExecutionDeleteManyArgs} args - Arguments to filter BlockExecutions to delete.
     * @example
     * // Delete a few BlockExecutions
     * const { count } = await prisma.blockExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockExecutionDeleteManyArgs>(args?: SelectSubset<T, BlockExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockExecutions
     * const blockExecution = await prisma.blockExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockExecutionUpdateManyArgs>(args: SelectSubset<T, BlockExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlockExecution.
     * @param {BlockExecutionUpsertArgs} args - Arguments to update or create a BlockExecution.
     * @example
     * // Update or create a BlockExecution
     * const blockExecution = await prisma.blockExecution.upsert({
     *   create: {
     *     // ... data to create a BlockExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockExecution we want to update
     *   }
     * })
     */
    upsert<T extends BlockExecutionUpsertArgs>(args: SelectSubset<T, BlockExecutionUpsertArgs<ExtArgs>>): Prisma__BlockExecutionClient<$Result.GetResult<Prisma.$BlockExecutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlockExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockExecutionCountArgs} args - Arguments to filter BlockExecutions to count.
     * @example
     * // Count the number of BlockExecutions
     * const count = await prisma.blockExecution.count({
     *   where: {
     *     // ... the filter for the BlockExecutions we want to count
     *   }
     * })
    **/
    count<T extends BlockExecutionCountArgs>(
      args?: Subset<T, BlockExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockExecutionAggregateArgs>(args: Subset<T, BlockExecutionAggregateArgs>): Prisma.PrismaPromise<GetBlockExecutionAggregateType<T>>

    /**
     * Group by BlockExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockExecutionGroupByArgs['orderBy'] }
        : { orderBy?: BlockExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlockExecution model
   */
  readonly fields: BlockExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    execution<T extends ProtocolExecutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProtocolExecutionDefaultArgs<ExtArgs>>): Prisma__ProtocolExecutionClient<$Result.GetResult<Prisma.$ProtocolExecutionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    block<T extends BlockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlockDefaultArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlockExecution model
   */ 
  interface BlockExecutionFieldRefs {
    readonly id: FieldRef<"BlockExecution", 'String'>
    readonly createdAt: FieldRef<"BlockExecution", 'DateTime'>
    readonly updatedAt: FieldRef<"BlockExecution", 'DateTime'>
    readonly executionId: FieldRef<"BlockExecution", 'String'>
    readonly blockId: FieldRef<"BlockExecution", 'String'>
    readonly status: FieldRef<"BlockExecution", 'String'>
    readonly startDate: FieldRef<"BlockExecution", 'DateTime'>
    readonly endDate: FieldRef<"BlockExecution", 'DateTime'>
    readonly adaptations: FieldRef<"BlockExecution", 'Json'>
    readonly notes: FieldRef<"BlockExecution", 'String'>
    readonly currentWeek: FieldRef<"BlockExecution", 'Int'>
    readonly progress: FieldRef<"BlockExecution", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * BlockExecution findUnique
   */
  export type BlockExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
    /**
     * Filter, which BlockExecution to fetch.
     */
    where: BlockExecutionWhereUniqueInput
  }

  /**
   * BlockExecution findUniqueOrThrow
   */
  export type BlockExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
    /**
     * Filter, which BlockExecution to fetch.
     */
    where: BlockExecutionWhereUniqueInput
  }

  /**
   * BlockExecution findFirst
   */
  export type BlockExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
    /**
     * Filter, which BlockExecution to fetch.
     */
    where?: BlockExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockExecutions to fetch.
     */
    orderBy?: BlockExecutionOrderByWithRelationInput | BlockExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockExecutions.
     */
    cursor?: BlockExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockExecutions.
     */
    distinct?: BlockExecutionScalarFieldEnum | BlockExecutionScalarFieldEnum[]
  }

  /**
   * BlockExecution findFirstOrThrow
   */
  export type BlockExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
    /**
     * Filter, which BlockExecution to fetch.
     */
    where?: BlockExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockExecutions to fetch.
     */
    orderBy?: BlockExecutionOrderByWithRelationInput | BlockExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockExecutions.
     */
    cursor?: BlockExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockExecutions.
     */
    distinct?: BlockExecutionScalarFieldEnum | BlockExecutionScalarFieldEnum[]
  }

  /**
   * BlockExecution findMany
   */
  export type BlockExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
    /**
     * Filter, which BlockExecutions to fetch.
     */
    where?: BlockExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockExecutions to fetch.
     */
    orderBy?: BlockExecutionOrderByWithRelationInput | BlockExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockExecutions.
     */
    cursor?: BlockExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockExecutions.
     */
    skip?: number
    distinct?: BlockExecutionScalarFieldEnum | BlockExecutionScalarFieldEnum[]
  }

  /**
   * BlockExecution create
   */
  export type BlockExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a BlockExecution.
     */
    data: XOR<BlockExecutionCreateInput, BlockExecutionUncheckedCreateInput>
  }

  /**
   * BlockExecution createMany
   */
  export type BlockExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockExecutions.
     */
    data: BlockExecutionCreateManyInput | BlockExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockExecution createManyAndReturn
   */
  export type BlockExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlockExecutions.
     */
    data: BlockExecutionCreateManyInput | BlockExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockExecution update
   */
  export type BlockExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a BlockExecution.
     */
    data: XOR<BlockExecutionUpdateInput, BlockExecutionUncheckedUpdateInput>
    /**
     * Choose, which BlockExecution to update.
     */
    where: BlockExecutionWhereUniqueInput
  }

  /**
   * BlockExecution updateMany
   */
  export type BlockExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockExecutions.
     */
    data: XOR<BlockExecutionUpdateManyMutationInput, BlockExecutionUncheckedUpdateManyInput>
    /**
     * Filter which BlockExecutions to update
     */
    where?: BlockExecutionWhereInput
  }

  /**
   * BlockExecution upsert
   */
  export type BlockExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the BlockExecution to update in case it exists.
     */
    where: BlockExecutionWhereUniqueInput
    /**
     * In case the BlockExecution found by the `where` argument doesn't exist, create a new BlockExecution with this data.
     */
    create: XOR<BlockExecutionCreateInput, BlockExecutionUncheckedCreateInput>
    /**
     * In case the BlockExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockExecutionUpdateInput, BlockExecutionUncheckedUpdateInput>
  }

  /**
   * BlockExecution delete
   */
  export type BlockExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
    /**
     * Filter which BlockExecution to delete.
     */
    where: BlockExecutionWhereUniqueInput
  }

  /**
   * BlockExecution deleteMany
   */
  export type BlockExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockExecutions to delete
     */
    where?: BlockExecutionWhereInput
  }

  /**
   * BlockExecution without action
   */
  export type BlockExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockExecution
     */
    select?: BlockExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockExecutionInclude<ExtArgs> | null
  }


  /**
   * Model SessionExecution
   */

  export type AggregateSessionExecution = {
    _count: SessionExecutionCountAggregateOutputType | null
    _avg: SessionExecutionAvgAggregateOutputType | null
    _sum: SessionExecutionSumAggregateOutputType | null
    _min: SessionExecutionMinAggregateOutputType | null
    _max: SessionExecutionMaxAggregateOutputType | null
  }

  export type SessionExecutionAvgAggregateOutputType = {
    duration: number | null
    rpe: number | null
    volume: number | null
  }

  export type SessionExecutionSumAggregateOutputType = {
    duration: number | null
    rpe: number | null
    volume: number | null
  }

  export type SessionExecutionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    executionId: string | null
    sessionId: string | null
    status: string | null
    scheduledDate: Date | null
    actualDate: Date | null
    notes: string | null
    duration: number | null
    rpe: number | null
    volume: number | null
  }

  export type SessionExecutionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    executionId: string | null
    sessionId: string | null
    status: string | null
    scheduledDate: Date | null
    actualDate: Date | null
    notes: string | null
    duration: number | null
    rpe: number | null
    volume: number | null
  }

  export type SessionExecutionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    executionId: number
    sessionId: number
    status: number
    scheduledDate: number
    actualDate: number
    exercises: number
    adaptations: number
    notes: number
    duration: number
    rpe: number
    volume: number
    _all: number
  }


  export type SessionExecutionAvgAggregateInputType = {
    duration?: true
    rpe?: true
    volume?: true
  }

  export type SessionExecutionSumAggregateInputType = {
    duration?: true
    rpe?: true
    volume?: true
  }

  export type SessionExecutionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    executionId?: true
    sessionId?: true
    status?: true
    scheduledDate?: true
    actualDate?: true
    notes?: true
    duration?: true
    rpe?: true
    volume?: true
  }

  export type SessionExecutionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    executionId?: true
    sessionId?: true
    status?: true
    scheduledDate?: true
    actualDate?: true
    notes?: true
    duration?: true
    rpe?: true
    volume?: true
  }

  export type SessionExecutionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    executionId?: true
    sessionId?: true
    status?: true
    scheduledDate?: true
    actualDate?: true
    exercises?: true
    adaptations?: true
    notes?: true
    duration?: true
    rpe?: true
    volume?: true
    _all?: true
  }

  export type SessionExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionExecution to aggregate.
     */
    where?: SessionExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionExecutions to fetch.
     */
    orderBy?: SessionExecutionOrderByWithRelationInput | SessionExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionExecutions
    **/
    _count?: true | SessionExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionExecutionMaxAggregateInputType
  }

  export type GetSessionExecutionAggregateType<T extends SessionExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionExecution[P]>
      : GetScalarType<T[P], AggregateSessionExecution[P]>
  }




  export type SessionExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionExecutionWhereInput
    orderBy?: SessionExecutionOrderByWithAggregationInput | SessionExecutionOrderByWithAggregationInput[]
    by: SessionExecutionScalarFieldEnum[] | SessionExecutionScalarFieldEnum
    having?: SessionExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionExecutionCountAggregateInputType | true
    _avg?: SessionExecutionAvgAggregateInputType
    _sum?: SessionExecutionSumAggregateInputType
    _min?: SessionExecutionMinAggregateInputType
    _max?: SessionExecutionMaxAggregateInputType
  }

  export type SessionExecutionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    executionId: string
    sessionId: string
    status: string
    scheduledDate: Date
    actualDate: Date | null
    exercises: JsonValue | null
    adaptations: JsonValue | null
    notes: string | null
    duration: number | null
    rpe: number | null
    volume: number | null
    _count: SessionExecutionCountAggregateOutputType | null
    _avg: SessionExecutionAvgAggregateOutputType | null
    _sum: SessionExecutionSumAggregateOutputType | null
    _min: SessionExecutionMinAggregateOutputType | null
    _max: SessionExecutionMaxAggregateOutputType | null
  }

  type GetSessionExecutionGroupByPayload<T extends SessionExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionExecutionGroupByOutputType[P]>
        }
      >
    >


  export type SessionExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    executionId?: boolean
    sessionId?: boolean
    status?: boolean
    scheduledDate?: boolean
    actualDate?: boolean
    exercises?: boolean
    adaptations?: boolean
    notes?: boolean
    duration?: boolean
    rpe?: boolean
    volume?: boolean
    execution?: boolean | ProtocolExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionExecution"]>

  export type SessionExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    executionId?: boolean
    sessionId?: boolean
    status?: boolean
    scheduledDate?: boolean
    actualDate?: boolean
    exercises?: boolean
    adaptations?: boolean
    notes?: boolean
    duration?: boolean
    rpe?: boolean
    volume?: boolean
    execution?: boolean | ProtocolExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionExecution"]>

  export type SessionExecutionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    executionId?: boolean
    sessionId?: boolean
    status?: boolean
    scheduledDate?: boolean
    actualDate?: boolean
    exercises?: boolean
    adaptations?: boolean
    notes?: boolean
    duration?: boolean
    rpe?: boolean
    volume?: boolean
  }

  export type SessionExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    execution?: boolean | ProtocolExecutionDefaultArgs<ExtArgs>
  }
  export type SessionExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    execution?: boolean | ProtocolExecutionDefaultArgs<ExtArgs>
  }

  export type $SessionExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionExecution"
    objects: {
      execution: Prisma.$ProtocolExecutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      executionId: string
      sessionId: string
      status: string
      scheduledDate: Date
      actualDate: Date | null
      exercises: Prisma.JsonValue | null
      adaptations: Prisma.JsonValue | null
      notes: string | null
      duration: number | null
      rpe: number | null
      volume: number | null
    }, ExtArgs["result"]["sessionExecution"]>
    composites: {}
  }

  type SessionExecutionGetPayload<S extends boolean | null | undefined | SessionExecutionDefaultArgs> = $Result.GetResult<Prisma.$SessionExecutionPayload, S>

  type SessionExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionExecutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionExecutionCountAggregateInputType | true
    }

  export interface SessionExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionExecution'], meta: { name: 'SessionExecution' } }
    /**
     * Find zero or one SessionExecution that matches the filter.
     * @param {SessionExecutionFindUniqueArgs} args - Arguments to find a SessionExecution
     * @example
     * // Get one SessionExecution
     * const sessionExecution = await prisma.sessionExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionExecutionFindUniqueArgs>(args: SelectSubset<T, SessionExecutionFindUniqueArgs<ExtArgs>>): Prisma__SessionExecutionClient<$Result.GetResult<Prisma.$SessionExecutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SessionExecution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionExecutionFindUniqueOrThrowArgs} args - Arguments to find a SessionExecution
     * @example
     * // Get one SessionExecution
     * const sessionExecution = await prisma.sessionExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionExecutionClient<$Result.GetResult<Prisma.$SessionExecutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SessionExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionExecutionFindFirstArgs} args - Arguments to find a SessionExecution
     * @example
     * // Get one SessionExecution
     * const sessionExecution = await prisma.sessionExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionExecutionFindFirstArgs>(args?: SelectSubset<T, SessionExecutionFindFirstArgs<ExtArgs>>): Prisma__SessionExecutionClient<$Result.GetResult<Prisma.$SessionExecutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SessionExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionExecutionFindFirstOrThrowArgs} args - Arguments to find a SessionExecution
     * @example
     * // Get one SessionExecution
     * const sessionExecution = await prisma.sessionExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionExecutionClient<$Result.GetResult<Prisma.$SessionExecutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SessionExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionExecutions
     * const sessionExecutions = await prisma.sessionExecution.findMany()
     * 
     * // Get first 10 SessionExecutions
     * const sessionExecutions = await prisma.sessionExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionExecutionWithIdOnly = await prisma.sessionExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionExecutionFindManyArgs>(args?: SelectSubset<T, SessionExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionExecutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SessionExecution.
     * @param {SessionExecutionCreateArgs} args - Arguments to create a SessionExecution.
     * @example
     * // Create one SessionExecution
     * const SessionExecution = await prisma.sessionExecution.create({
     *   data: {
     *     // ... data to create a SessionExecution
     *   }
     * })
     * 
     */
    create<T extends SessionExecutionCreateArgs>(args: SelectSubset<T, SessionExecutionCreateArgs<ExtArgs>>): Prisma__SessionExecutionClient<$Result.GetResult<Prisma.$SessionExecutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SessionExecutions.
     * @param {SessionExecutionCreateManyArgs} args - Arguments to create many SessionExecutions.
     * @example
     * // Create many SessionExecutions
     * const sessionExecution = await prisma.sessionExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionExecutionCreateManyArgs>(args?: SelectSubset<T, SessionExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionExecutions and returns the data saved in the database.
     * @param {SessionExecutionCreateManyAndReturnArgs} args - Arguments to create many SessionExecutions.
     * @example
     * // Create many SessionExecutions
     * const sessionExecution = await prisma.sessionExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionExecutions and only return the `id`
     * const sessionExecutionWithIdOnly = await prisma.sessionExecution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionExecutionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SessionExecution.
     * @param {SessionExecutionDeleteArgs} args - Arguments to delete one SessionExecution.
     * @example
     * // Delete one SessionExecution
     * const SessionExecution = await prisma.sessionExecution.delete({
     *   where: {
     *     // ... filter to delete one SessionExecution
     *   }
     * })
     * 
     */
    delete<T extends SessionExecutionDeleteArgs>(args: SelectSubset<T, SessionExecutionDeleteArgs<ExtArgs>>): Prisma__SessionExecutionClient<$Result.GetResult<Prisma.$SessionExecutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SessionExecution.
     * @param {SessionExecutionUpdateArgs} args - Arguments to update one SessionExecution.
     * @example
     * // Update one SessionExecution
     * const sessionExecution = await prisma.sessionExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionExecutionUpdateArgs>(args: SelectSubset<T, SessionExecutionUpdateArgs<ExtArgs>>): Prisma__SessionExecutionClient<$Result.GetResult<Prisma.$SessionExecutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SessionExecutions.
     * @param {SessionExecutionDeleteManyArgs} args - Arguments to filter SessionExecutions to delete.
     * @example
     * // Delete a few SessionExecutions
     * const { count } = await prisma.sessionExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionExecutionDeleteManyArgs>(args?: SelectSubset<T, SessionExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionExecutions
     * const sessionExecution = await prisma.sessionExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionExecutionUpdateManyArgs>(args: SelectSubset<T, SessionExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SessionExecution.
     * @param {SessionExecutionUpsertArgs} args - Arguments to update or create a SessionExecution.
     * @example
     * // Update or create a SessionExecution
     * const sessionExecution = await prisma.sessionExecution.upsert({
     *   create: {
     *     // ... data to create a SessionExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionExecution we want to update
     *   }
     * })
     */
    upsert<T extends SessionExecutionUpsertArgs>(args: SelectSubset<T, SessionExecutionUpsertArgs<ExtArgs>>): Prisma__SessionExecutionClient<$Result.GetResult<Prisma.$SessionExecutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SessionExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionExecutionCountArgs} args - Arguments to filter SessionExecutions to count.
     * @example
     * // Count the number of SessionExecutions
     * const count = await prisma.sessionExecution.count({
     *   where: {
     *     // ... the filter for the SessionExecutions we want to count
     *   }
     * })
    **/
    count<T extends SessionExecutionCountArgs>(
      args?: Subset<T, SessionExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionExecutionAggregateArgs>(args: Subset<T, SessionExecutionAggregateArgs>): Prisma.PrismaPromise<GetSessionExecutionAggregateType<T>>

    /**
     * Group by SessionExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionExecutionGroupByArgs['orderBy'] }
        : { orderBy?: SessionExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionExecution model
   */
  readonly fields: SessionExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    execution<T extends ProtocolExecutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProtocolExecutionDefaultArgs<ExtArgs>>): Prisma__ProtocolExecutionClient<$Result.GetResult<Prisma.$ProtocolExecutionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionExecution model
   */ 
  interface SessionExecutionFieldRefs {
    readonly id: FieldRef<"SessionExecution", 'String'>
    readonly createdAt: FieldRef<"SessionExecution", 'DateTime'>
    readonly updatedAt: FieldRef<"SessionExecution", 'DateTime'>
    readonly executionId: FieldRef<"SessionExecution", 'String'>
    readonly sessionId: FieldRef<"SessionExecution", 'String'>
    readonly status: FieldRef<"SessionExecution", 'String'>
    readonly scheduledDate: FieldRef<"SessionExecution", 'DateTime'>
    readonly actualDate: FieldRef<"SessionExecution", 'DateTime'>
    readonly exercises: FieldRef<"SessionExecution", 'Json'>
    readonly adaptations: FieldRef<"SessionExecution", 'Json'>
    readonly notes: FieldRef<"SessionExecution", 'String'>
    readonly duration: FieldRef<"SessionExecution", 'Int'>
    readonly rpe: FieldRef<"SessionExecution", 'Float'>
    readonly volume: FieldRef<"SessionExecution", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * SessionExecution findUnique
   */
  export type SessionExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExecution
     */
    select?: SessionExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExecutionInclude<ExtArgs> | null
    /**
     * Filter, which SessionExecution to fetch.
     */
    where: SessionExecutionWhereUniqueInput
  }

  /**
   * SessionExecution findUniqueOrThrow
   */
  export type SessionExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExecution
     */
    select?: SessionExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExecutionInclude<ExtArgs> | null
    /**
     * Filter, which SessionExecution to fetch.
     */
    where: SessionExecutionWhereUniqueInput
  }

  /**
   * SessionExecution findFirst
   */
  export type SessionExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExecution
     */
    select?: SessionExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExecutionInclude<ExtArgs> | null
    /**
     * Filter, which SessionExecution to fetch.
     */
    where?: SessionExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionExecutions to fetch.
     */
    orderBy?: SessionExecutionOrderByWithRelationInput | SessionExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionExecutions.
     */
    cursor?: SessionExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionExecutions.
     */
    distinct?: SessionExecutionScalarFieldEnum | SessionExecutionScalarFieldEnum[]
  }

  /**
   * SessionExecution findFirstOrThrow
   */
  export type SessionExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExecution
     */
    select?: SessionExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExecutionInclude<ExtArgs> | null
    /**
     * Filter, which SessionExecution to fetch.
     */
    where?: SessionExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionExecutions to fetch.
     */
    orderBy?: SessionExecutionOrderByWithRelationInput | SessionExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionExecutions.
     */
    cursor?: SessionExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionExecutions.
     */
    distinct?: SessionExecutionScalarFieldEnum | SessionExecutionScalarFieldEnum[]
  }

  /**
   * SessionExecution findMany
   */
  export type SessionExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExecution
     */
    select?: SessionExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExecutionInclude<ExtArgs> | null
    /**
     * Filter, which SessionExecutions to fetch.
     */
    where?: SessionExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionExecutions to fetch.
     */
    orderBy?: SessionExecutionOrderByWithRelationInput | SessionExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionExecutions.
     */
    cursor?: SessionExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionExecutions.
     */
    skip?: number
    distinct?: SessionExecutionScalarFieldEnum | SessionExecutionScalarFieldEnum[]
  }

  /**
   * SessionExecution create
   */
  export type SessionExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExecution
     */
    select?: SessionExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionExecution.
     */
    data: XOR<SessionExecutionCreateInput, SessionExecutionUncheckedCreateInput>
  }

  /**
   * SessionExecution createMany
   */
  export type SessionExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionExecutions.
     */
    data: SessionExecutionCreateManyInput | SessionExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionExecution createManyAndReturn
   */
  export type SessionExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExecution
     */
    select?: SessionExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SessionExecutions.
     */
    data: SessionExecutionCreateManyInput | SessionExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionExecution update
   */
  export type SessionExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExecution
     */
    select?: SessionExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionExecution.
     */
    data: XOR<SessionExecutionUpdateInput, SessionExecutionUncheckedUpdateInput>
    /**
     * Choose, which SessionExecution to update.
     */
    where: SessionExecutionWhereUniqueInput
  }

  /**
   * SessionExecution updateMany
   */
  export type SessionExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionExecutions.
     */
    data: XOR<SessionExecutionUpdateManyMutationInput, SessionExecutionUncheckedUpdateManyInput>
    /**
     * Filter which SessionExecutions to update
     */
    where?: SessionExecutionWhereInput
  }

  /**
   * SessionExecution upsert
   */
  export type SessionExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExecution
     */
    select?: SessionExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionExecution to update in case it exists.
     */
    where: SessionExecutionWhereUniqueInput
    /**
     * In case the SessionExecution found by the `where` argument doesn't exist, create a new SessionExecution with this data.
     */
    create: XOR<SessionExecutionCreateInput, SessionExecutionUncheckedCreateInput>
    /**
     * In case the SessionExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionExecutionUpdateInput, SessionExecutionUncheckedUpdateInput>
  }

  /**
   * SessionExecution delete
   */
  export type SessionExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExecution
     */
    select?: SessionExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExecutionInclude<ExtArgs> | null
    /**
     * Filter which SessionExecution to delete.
     */
    where: SessionExecutionWhereUniqueInput
  }

  /**
   * SessionExecution deleteMany
   */
  export type SessionExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionExecutions to delete
     */
    where?: SessionExecutionWhereInput
  }

  /**
   * SessionExecution without action
   */
  export type SessionExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionExecution
     */
    select?: SessionExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionExecutionInclude<ExtArgs> | null
  }


  /**
   * Model ProtocolAnalytics
   */

  export type AggregateProtocolAnalytics = {
    _count: ProtocolAnalyticsCountAggregateOutputType | null
    _min: ProtocolAnalyticsMinAggregateOutputType | null
    _max: ProtocolAnalyticsMaxAggregateOutputType | null
  }

  export type ProtocolAnalyticsMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    protocolId: string | null
    userId: string | null
    periodStart: Date | null
    periodEnd: Date | null
  }

  export type ProtocolAnalyticsMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    protocolId: string | null
    userId: string | null
    periodStart: Date | null
    periodEnd: Date | null
  }

  export type ProtocolAnalyticsCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    protocolId: number
    userId: number
    metrics: number
    insights: number
    recommendations: number
    periodStart: number
    periodEnd: number
    _all: number
  }


  export type ProtocolAnalyticsMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    protocolId?: true
    userId?: true
    periodStart?: true
    periodEnd?: true
  }

  export type ProtocolAnalyticsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    protocolId?: true
    userId?: true
    periodStart?: true
    periodEnd?: true
  }

  export type ProtocolAnalyticsCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    protocolId?: true
    userId?: true
    metrics?: true
    insights?: true
    recommendations?: true
    periodStart?: true
    periodEnd?: true
    _all?: true
  }

  export type ProtocolAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProtocolAnalytics to aggregate.
     */
    where?: ProtocolAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProtocolAnalytics to fetch.
     */
    orderBy?: ProtocolAnalyticsOrderByWithRelationInput | ProtocolAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProtocolAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProtocolAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProtocolAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProtocolAnalytics
    **/
    _count?: true | ProtocolAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProtocolAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProtocolAnalyticsMaxAggregateInputType
  }

  export type GetProtocolAnalyticsAggregateType<T extends ProtocolAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateProtocolAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProtocolAnalytics[P]>
      : GetScalarType<T[P], AggregateProtocolAnalytics[P]>
  }




  export type ProtocolAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProtocolAnalyticsWhereInput
    orderBy?: ProtocolAnalyticsOrderByWithAggregationInput | ProtocolAnalyticsOrderByWithAggregationInput[]
    by: ProtocolAnalyticsScalarFieldEnum[] | ProtocolAnalyticsScalarFieldEnum
    having?: ProtocolAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProtocolAnalyticsCountAggregateInputType | true
    _min?: ProtocolAnalyticsMinAggregateInputType
    _max?: ProtocolAnalyticsMaxAggregateInputType
  }

  export type ProtocolAnalyticsGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    protocolId: string
    userId: string | null
    metrics: JsonValue
    insights: JsonValue | null
    recommendations: JsonValue | null
    periodStart: Date
    periodEnd: Date
    _count: ProtocolAnalyticsCountAggregateOutputType | null
    _min: ProtocolAnalyticsMinAggregateOutputType | null
    _max: ProtocolAnalyticsMaxAggregateOutputType | null
  }

  type GetProtocolAnalyticsGroupByPayload<T extends ProtocolAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProtocolAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProtocolAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProtocolAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], ProtocolAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type ProtocolAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    protocolId?: boolean
    userId?: boolean
    metrics?: boolean
    insights?: boolean
    recommendations?: boolean
    periodStart?: boolean
    periodEnd?: boolean
  }, ExtArgs["result"]["protocolAnalytics"]>

  export type ProtocolAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    protocolId?: boolean
    userId?: boolean
    metrics?: boolean
    insights?: boolean
    recommendations?: boolean
    periodStart?: boolean
    periodEnd?: boolean
  }, ExtArgs["result"]["protocolAnalytics"]>

  export type ProtocolAnalyticsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    protocolId?: boolean
    userId?: boolean
    metrics?: boolean
    insights?: boolean
    recommendations?: boolean
    periodStart?: boolean
    periodEnd?: boolean
  }


  export type $ProtocolAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProtocolAnalytics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      protocolId: string
      userId: string | null
      metrics: Prisma.JsonValue
      insights: Prisma.JsonValue | null
      recommendations: Prisma.JsonValue | null
      periodStart: Date
      periodEnd: Date
    }, ExtArgs["result"]["protocolAnalytics"]>
    composites: {}
  }

  type ProtocolAnalyticsGetPayload<S extends boolean | null | undefined | ProtocolAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$ProtocolAnalyticsPayload, S>

  type ProtocolAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProtocolAnalyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProtocolAnalyticsCountAggregateInputType | true
    }

  export interface ProtocolAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProtocolAnalytics'], meta: { name: 'ProtocolAnalytics' } }
    /**
     * Find zero or one ProtocolAnalytics that matches the filter.
     * @param {ProtocolAnalyticsFindUniqueArgs} args - Arguments to find a ProtocolAnalytics
     * @example
     * // Get one ProtocolAnalytics
     * const protocolAnalytics = await prisma.protocolAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProtocolAnalyticsFindUniqueArgs>(args: SelectSubset<T, ProtocolAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__ProtocolAnalyticsClient<$Result.GetResult<Prisma.$ProtocolAnalyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProtocolAnalytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProtocolAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a ProtocolAnalytics
     * @example
     * // Get one ProtocolAnalytics
     * const protocolAnalytics = await prisma.protocolAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProtocolAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProtocolAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProtocolAnalyticsClient<$Result.GetResult<Prisma.$ProtocolAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProtocolAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolAnalyticsFindFirstArgs} args - Arguments to find a ProtocolAnalytics
     * @example
     * // Get one ProtocolAnalytics
     * const protocolAnalytics = await prisma.protocolAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProtocolAnalyticsFindFirstArgs>(args?: SelectSubset<T, ProtocolAnalyticsFindFirstArgs<ExtArgs>>): Prisma__ProtocolAnalyticsClient<$Result.GetResult<Prisma.$ProtocolAnalyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProtocolAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolAnalyticsFindFirstOrThrowArgs} args - Arguments to find a ProtocolAnalytics
     * @example
     * // Get one ProtocolAnalytics
     * const protocolAnalytics = await prisma.protocolAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProtocolAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProtocolAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProtocolAnalyticsClient<$Result.GetResult<Prisma.$ProtocolAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProtocolAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProtocolAnalytics
     * const protocolAnalytics = await prisma.protocolAnalytics.findMany()
     * 
     * // Get first 10 ProtocolAnalytics
     * const protocolAnalytics = await prisma.protocolAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const protocolAnalyticsWithIdOnly = await prisma.protocolAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProtocolAnalyticsFindManyArgs>(args?: SelectSubset<T, ProtocolAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolAnalyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProtocolAnalytics.
     * @param {ProtocolAnalyticsCreateArgs} args - Arguments to create a ProtocolAnalytics.
     * @example
     * // Create one ProtocolAnalytics
     * const ProtocolAnalytics = await prisma.protocolAnalytics.create({
     *   data: {
     *     // ... data to create a ProtocolAnalytics
     *   }
     * })
     * 
     */
    create<T extends ProtocolAnalyticsCreateArgs>(args: SelectSubset<T, ProtocolAnalyticsCreateArgs<ExtArgs>>): Prisma__ProtocolAnalyticsClient<$Result.GetResult<Prisma.$ProtocolAnalyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProtocolAnalytics.
     * @param {ProtocolAnalyticsCreateManyArgs} args - Arguments to create many ProtocolAnalytics.
     * @example
     * // Create many ProtocolAnalytics
     * const protocolAnalytics = await prisma.protocolAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProtocolAnalyticsCreateManyArgs>(args?: SelectSubset<T, ProtocolAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProtocolAnalytics and returns the data saved in the database.
     * @param {ProtocolAnalyticsCreateManyAndReturnArgs} args - Arguments to create many ProtocolAnalytics.
     * @example
     * // Create many ProtocolAnalytics
     * const protocolAnalytics = await prisma.protocolAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProtocolAnalytics and only return the `id`
     * const protocolAnalyticsWithIdOnly = await prisma.protocolAnalytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProtocolAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, ProtocolAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolAnalyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProtocolAnalytics.
     * @param {ProtocolAnalyticsDeleteArgs} args - Arguments to delete one ProtocolAnalytics.
     * @example
     * // Delete one ProtocolAnalytics
     * const ProtocolAnalytics = await prisma.protocolAnalytics.delete({
     *   where: {
     *     // ... filter to delete one ProtocolAnalytics
     *   }
     * })
     * 
     */
    delete<T extends ProtocolAnalyticsDeleteArgs>(args: SelectSubset<T, ProtocolAnalyticsDeleteArgs<ExtArgs>>): Prisma__ProtocolAnalyticsClient<$Result.GetResult<Prisma.$ProtocolAnalyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProtocolAnalytics.
     * @param {ProtocolAnalyticsUpdateArgs} args - Arguments to update one ProtocolAnalytics.
     * @example
     * // Update one ProtocolAnalytics
     * const protocolAnalytics = await prisma.protocolAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProtocolAnalyticsUpdateArgs>(args: SelectSubset<T, ProtocolAnalyticsUpdateArgs<ExtArgs>>): Prisma__ProtocolAnalyticsClient<$Result.GetResult<Prisma.$ProtocolAnalyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProtocolAnalytics.
     * @param {ProtocolAnalyticsDeleteManyArgs} args - Arguments to filter ProtocolAnalytics to delete.
     * @example
     * // Delete a few ProtocolAnalytics
     * const { count } = await prisma.protocolAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProtocolAnalyticsDeleteManyArgs>(args?: SelectSubset<T, ProtocolAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProtocolAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProtocolAnalytics
     * const protocolAnalytics = await prisma.protocolAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProtocolAnalyticsUpdateManyArgs>(args: SelectSubset<T, ProtocolAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProtocolAnalytics.
     * @param {ProtocolAnalyticsUpsertArgs} args - Arguments to update or create a ProtocolAnalytics.
     * @example
     * // Update or create a ProtocolAnalytics
     * const protocolAnalytics = await prisma.protocolAnalytics.upsert({
     *   create: {
     *     // ... data to create a ProtocolAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProtocolAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends ProtocolAnalyticsUpsertArgs>(args: SelectSubset<T, ProtocolAnalyticsUpsertArgs<ExtArgs>>): Prisma__ProtocolAnalyticsClient<$Result.GetResult<Prisma.$ProtocolAnalyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProtocolAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolAnalyticsCountArgs} args - Arguments to filter ProtocolAnalytics to count.
     * @example
     * // Count the number of ProtocolAnalytics
     * const count = await prisma.protocolAnalytics.count({
     *   where: {
     *     // ... the filter for the ProtocolAnalytics we want to count
     *   }
     * })
    **/
    count<T extends ProtocolAnalyticsCountArgs>(
      args?: Subset<T, ProtocolAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProtocolAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProtocolAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProtocolAnalyticsAggregateArgs>(args: Subset<T, ProtocolAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetProtocolAnalyticsAggregateType<T>>

    /**
     * Group by ProtocolAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProtocolAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProtocolAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: ProtocolAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProtocolAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProtocolAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProtocolAnalytics model
   */
  readonly fields: ProtocolAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProtocolAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProtocolAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProtocolAnalytics model
   */ 
  interface ProtocolAnalyticsFieldRefs {
    readonly id: FieldRef<"ProtocolAnalytics", 'String'>
    readonly createdAt: FieldRef<"ProtocolAnalytics", 'DateTime'>
    readonly updatedAt: FieldRef<"ProtocolAnalytics", 'DateTime'>
    readonly protocolId: FieldRef<"ProtocolAnalytics", 'String'>
    readonly userId: FieldRef<"ProtocolAnalytics", 'String'>
    readonly metrics: FieldRef<"ProtocolAnalytics", 'Json'>
    readonly insights: FieldRef<"ProtocolAnalytics", 'Json'>
    readonly recommendations: FieldRef<"ProtocolAnalytics", 'Json'>
    readonly periodStart: FieldRef<"ProtocolAnalytics", 'DateTime'>
    readonly periodEnd: FieldRef<"ProtocolAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProtocolAnalytics findUnique
   */
  export type ProtocolAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolAnalytics
     */
    select?: ProtocolAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which ProtocolAnalytics to fetch.
     */
    where: ProtocolAnalyticsWhereUniqueInput
  }

  /**
   * ProtocolAnalytics findUniqueOrThrow
   */
  export type ProtocolAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolAnalytics
     */
    select?: ProtocolAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which ProtocolAnalytics to fetch.
     */
    where: ProtocolAnalyticsWhereUniqueInput
  }

  /**
   * ProtocolAnalytics findFirst
   */
  export type ProtocolAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolAnalytics
     */
    select?: ProtocolAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which ProtocolAnalytics to fetch.
     */
    where?: ProtocolAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProtocolAnalytics to fetch.
     */
    orderBy?: ProtocolAnalyticsOrderByWithRelationInput | ProtocolAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProtocolAnalytics.
     */
    cursor?: ProtocolAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProtocolAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProtocolAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProtocolAnalytics.
     */
    distinct?: ProtocolAnalyticsScalarFieldEnum | ProtocolAnalyticsScalarFieldEnum[]
  }

  /**
   * ProtocolAnalytics findFirstOrThrow
   */
  export type ProtocolAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolAnalytics
     */
    select?: ProtocolAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which ProtocolAnalytics to fetch.
     */
    where?: ProtocolAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProtocolAnalytics to fetch.
     */
    orderBy?: ProtocolAnalyticsOrderByWithRelationInput | ProtocolAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProtocolAnalytics.
     */
    cursor?: ProtocolAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProtocolAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProtocolAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProtocolAnalytics.
     */
    distinct?: ProtocolAnalyticsScalarFieldEnum | ProtocolAnalyticsScalarFieldEnum[]
  }

  /**
   * ProtocolAnalytics findMany
   */
  export type ProtocolAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolAnalytics
     */
    select?: ProtocolAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which ProtocolAnalytics to fetch.
     */
    where?: ProtocolAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProtocolAnalytics to fetch.
     */
    orderBy?: ProtocolAnalyticsOrderByWithRelationInput | ProtocolAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProtocolAnalytics.
     */
    cursor?: ProtocolAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProtocolAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProtocolAnalytics.
     */
    skip?: number
    distinct?: ProtocolAnalyticsScalarFieldEnum | ProtocolAnalyticsScalarFieldEnum[]
  }

  /**
   * ProtocolAnalytics create
   */
  export type ProtocolAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolAnalytics
     */
    select?: ProtocolAnalyticsSelect<ExtArgs> | null
    /**
     * The data needed to create a ProtocolAnalytics.
     */
    data: XOR<ProtocolAnalyticsCreateInput, ProtocolAnalyticsUncheckedCreateInput>
  }

  /**
   * ProtocolAnalytics createMany
   */
  export type ProtocolAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProtocolAnalytics.
     */
    data: ProtocolAnalyticsCreateManyInput | ProtocolAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProtocolAnalytics createManyAndReturn
   */
  export type ProtocolAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolAnalytics
     */
    select?: ProtocolAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProtocolAnalytics.
     */
    data: ProtocolAnalyticsCreateManyInput | ProtocolAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProtocolAnalytics update
   */
  export type ProtocolAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolAnalytics
     */
    select?: ProtocolAnalyticsSelect<ExtArgs> | null
    /**
     * The data needed to update a ProtocolAnalytics.
     */
    data: XOR<ProtocolAnalyticsUpdateInput, ProtocolAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which ProtocolAnalytics to update.
     */
    where: ProtocolAnalyticsWhereUniqueInput
  }

  /**
   * ProtocolAnalytics updateMany
   */
  export type ProtocolAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProtocolAnalytics.
     */
    data: XOR<ProtocolAnalyticsUpdateManyMutationInput, ProtocolAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which ProtocolAnalytics to update
     */
    where?: ProtocolAnalyticsWhereInput
  }

  /**
   * ProtocolAnalytics upsert
   */
  export type ProtocolAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolAnalytics
     */
    select?: ProtocolAnalyticsSelect<ExtArgs> | null
    /**
     * The filter to search for the ProtocolAnalytics to update in case it exists.
     */
    where: ProtocolAnalyticsWhereUniqueInput
    /**
     * In case the ProtocolAnalytics found by the `where` argument doesn't exist, create a new ProtocolAnalytics with this data.
     */
    create: XOR<ProtocolAnalyticsCreateInput, ProtocolAnalyticsUncheckedCreateInput>
    /**
     * In case the ProtocolAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProtocolAnalyticsUpdateInput, ProtocolAnalyticsUncheckedUpdateInput>
  }

  /**
   * ProtocolAnalytics delete
   */
  export type ProtocolAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolAnalytics
     */
    select?: ProtocolAnalyticsSelect<ExtArgs> | null
    /**
     * Filter which ProtocolAnalytics to delete.
     */
    where: ProtocolAnalyticsWhereUniqueInput
  }

  /**
   * ProtocolAnalytics deleteMany
   */
  export type ProtocolAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProtocolAnalytics to delete
     */
    where?: ProtocolAnalyticsWhereInput
  }

  /**
   * ProtocolAnalytics without action
   */
  export type ProtocolAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolAnalytics
     */
    select?: ProtocolAnalyticsSelect<ExtArgs> | null
  }


  /**
   * Model ProtocolShare
   */

  export type AggregateProtocolShare = {
    _count: ProtocolShareCountAggregateOutputType | null
    _min: ProtocolShareMinAggregateOutputType | null
    _max: ProtocolShareMaxAggregateOutputType | null
  }

  export type ProtocolShareMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    protocolId: string | null
    sharedBy: string | null
    sharedWith: string | null
    expiresAt: Date | null
    isActive: boolean | null
    acceptedAt: Date | null
  }

  export type ProtocolShareMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    protocolId: string | null
    sharedBy: string | null
    sharedWith: string | null
    expiresAt: Date | null
    isActive: boolean | null
    acceptedAt: Date | null
  }

  export type ProtocolShareCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    protocolId: number
    sharedBy: number
    sharedWith: number
    permissions: number
    expiresAt: number
    isActive: number
    acceptedAt: number
    _all: number
  }


  export type ProtocolShareMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    protocolId?: true
    sharedBy?: true
    sharedWith?: true
    expiresAt?: true
    isActive?: true
    acceptedAt?: true
  }

  export type ProtocolShareMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    protocolId?: true
    sharedBy?: true
    sharedWith?: true
    expiresAt?: true
    isActive?: true
    acceptedAt?: true
  }

  export type ProtocolShareCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    protocolId?: true
    sharedBy?: true
    sharedWith?: true
    permissions?: true
    expiresAt?: true
    isActive?: true
    acceptedAt?: true
    _all?: true
  }

  export type ProtocolShareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProtocolShare to aggregate.
     */
    where?: ProtocolShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProtocolShares to fetch.
     */
    orderBy?: ProtocolShareOrderByWithRelationInput | ProtocolShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProtocolShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProtocolShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProtocolShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProtocolShares
    **/
    _count?: true | ProtocolShareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProtocolShareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProtocolShareMaxAggregateInputType
  }

  export type GetProtocolShareAggregateType<T extends ProtocolShareAggregateArgs> = {
        [P in keyof T & keyof AggregateProtocolShare]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProtocolShare[P]>
      : GetScalarType<T[P], AggregateProtocolShare[P]>
  }




  export type ProtocolShareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProtocolShareWhereInput
    orderBy?: ProtocolShareOrderByWithAggregationInput | ProtocolShareOrderByWithAggregationInput[]
    by: ProtocolShareScalarFieldEnum[] | ProtocolShareScalarFieldEnum
    having?: ProtocolShareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProtocolShareCountAggregateInputType | true
    _min?: ProtocolShareMinAggregateInputType
    _max?: ProtocolShareMaxAggregateInputType
  }

  export type ProtocolShareGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    protocolId: string
    sharedBy: string
    sharedWith: string
    permissions: $Enums.Permission[]
    expiresAt: Date | null
    isActive: boolean
    acceptedAt: Date | null
    _count: ProtocolShareCountAggregateOutputType | null
    _min: ProtocolShareMinAggregateOutputType | null
    _max: ProtocolShareMaxAggregateOutputType | null
  }

  type GetProtocolShareGroupByPayload<T extends ProtocolShareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProtocolShareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProtocolShareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProtocolShareGroupByOutputType[P]>
            : GetScalarType<T[P], ProtocolShareGroupByOutputType[P]>
        }
      >
    >


  export type ProtocolShareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    protocolId?: boolean
    sharedBy?: boolean
    sharedWith?: boolean
    permissions?: boolean
    expiresAt?: boolean
    isActive?: boolean
    acceptedAt?: boolean
    protocol?: boolean | ProtocolDefaultArgs<ExtArgs>
    sharedByUser?: boolean | UserDefaultArgs<ExtArgs>
    sharedWithUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["protocolShare"]>

  export type ProtocolShareSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    protocolId?: boolean
    sharedBy?: boolean
    sharedWith?: boolean
    permissions?: boolean
    expiresAt?: boolean
    isActive?: boolean
    acceptedAt?: boolean
    protocol?: boolean | ProtocolDefaultArgs<ExtArgs>
    sharedByUser?: boolean | UserDefaultArgs<ExtArgs>
    sharedWithUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["protocolShare"]>

  export type ProtocolShareSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    protocolId?: boolean
    sharedBy?: boolean
    sharedWith?: boolean
    permissions?: boolean
    expiresAt?: boolean
    isActive?: boolean
    acceptedAt?: boolean
  }

  export type ProtocolShareInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    protocol?: boolean | ProtocolDefaultArgs<ExtArgs>
    sharedByUser?: boolean | UserDefaultArgs<ExtArgs>
    sharedWithUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProtocolShareIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    protocol?: boolean | ProtocolDefaultArgs<ExtArgs>
    sharedByUser?: boolean | UserDefaultArgs<ExtArgs>
    sharedWithUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProtocolSharePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProtocolShare"
    objects: {
      protocol: Prisma.$ProtocolPayload<ExtArgs>
      sharedByUser: Prisma.$UserPayload<ExtArgs>
      sharedWithUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      protocolId: string
      sharedBy: string
      sharedWith: string
      permissions: $Enums.Permission[]
      expiresAt: Date | null
      isActive: boolean
      acceptedAt: Date | null
    }, ExtArgs["result"]["protocolShare"]>
    composites: {}
  }

  type ProtocolShareGetPayload<S extends boolean | null | undefined | ProtocolShareDefaultArgs> = $Result.GetResult<Prisma.$ProtocolSharePayload, S>

  type ProtocolShareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProtocolShareFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProtocolShareCountAggregateInputType | true
    }

  export interface ProtocolShareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProtocolShare'], meta: { name: 'ProtocolShare' } }
    /**
     * Find zero or one ProtocolShare that matches the filter.
     * @param {ProtocolShareFindUniqueArgs} args - Arguments to find a ProtocolShare
     * @example
     * // Get one ProtocolShare
     * const protocolShare = await prisma.protocolShare.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProtocolShareFindUniqueArgs>(args: SelectSubset<T, ProtocolShareFindUniqueArgs<ExtArgs>>): Prisma__ProtocolShareClient<$Result.GetResult<Prisma.$ProtocolSharePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProtocolShare that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProtocolShareFindUniqueOrThrowArgs} args - Arguments to find a ProtocolShare
     * @example
     * // Get one ProtocolShare
     * const protocolShare = await prisma.protocolShare.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProtocolShareFindUniqueOrThrowArgs>(args: SelectSubset<T, ProtocolShareFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProtocolShareClient<$Result.GetResult<Prisma.$ProtocolSharePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProtocolShare that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolShareFindFirstArgs} args - Arguments to find a ProtocolShare
     * @example
     * // Get one ProtocolShare
     * const protocolShare = await prisma.protocolShare.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProtocolShareFindFirstArgs>(args?: SelectSubset<T, ProtocolShareFindFirstArgs<ExtArgs>>): Prisma__ProtocolShareClient<$Result.GetResult<Prisma.$ProtocolSharePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProtocolShare that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolShareFindFirstOrThrowArgs} args - Arguments to find a ProtocolShare
     * @example
     * // Get one ProtocolShare
     * const protocolShare = await prisma.protocolShare.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProtocolShareFindFirstOrThrowArgs>(args?: SelectSubset<T, ProtocolShareFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProtocolShareClient<$Result.GetResult<Prisma.$ProtocolSharePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProtocolShares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolShareFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProtocolShares
     * const protocolShares = await prisma.protocolShare.findMany()
     * 
     * // Get first 10 ProtocolShares
     * const protocolShares = await prisma.protocolShare.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const protocolShareWithIdOnly = await prisma.protocolShare.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProtocolShareFindManyArgs>(args?: SelectSubset<T, ProtocolShareFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolSharePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProtocolShare.
     * @param {ProtocolShareCreateArgs} args - Arguments to create a ProtocolShare.
     * @example
     * // Create one ProtocolShare
     * const ProtocolShare = await prisma.protocolShare.create({
     *   data: {
     *     // ... data to create a ProtocolShare
     *   }
     * })
     * 
     */
    create<T extends ProtocolShareCreateArgs>(args: SelectSubset<T, ProtocolShareCreateArgs<ExtArgs>>): Prisma__ProtocolShareClient<$Result.GetResult<Prisma.$ProtocolSharePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProtocolShares.
     * @param {ProtocolShareCreateManyArgs} args - Arguments to create many ProtocolShares.
     * @example
     * // Create many ProtocolShares
     * const protocolShare = await prisma.protocolShare.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProtocolShareCreateManyArgs>(args?: SelectSubset<T, ProtocolShareCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProtocolShares and returns the data saved in the database.
     * @param {ProtocolShareCreateManyAndReturnArgs} args - Arguments to create many ProtocolShares.
     * @example
     * // Create many ProtocolShares
     * const protocolShare = await prisma.protocolShare.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProtocolShares and only return the `id`
     * const protocolShareWithIdOnly = await prisma.protocolShare.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProtocolShareCreateManyAndReturnArgs>(args?: SelectSubset<T, ProtocolShareCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocolSharePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProtocolShare.
     * @param {ProtocolShareDeleteArgs} args - Arguments to delete one ProtocolShare.
     * @example
     * // Delete one ProtocolShare
     * const ProtocolShare = await prisma.protocolShare.delete({
     *   where: {
     *     // ... filter to delete one ProtocolShare
     *   }
     * })
     * 
     */
    delete<T extends ProtocolShareDeleteArgs>(args: SelectSubset<T, ProtocolShareDeleteArgs<ExtArgs>>): Prisma__ProtocolShareClient<$Result.GetResult<Prisma.$ProtocolSharePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProtocolShare.
     * @param {ProtocolShareUpdateArgs} args - Arguments to update one ProtocolShare.
     * @example
     * // Update one ProtocolShare
     * const protocolShare = await prisma.protocolShare.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProtocolShareUpdateArgs>(args: SelectSubset<T, ProtocolShareUpdateArgs<ExtArgs>>): Prisma__ProtocolShareClient<$Result.GetResult<Prisma.$ProtocolSharePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProtocolShares.
     * @param {ProtocolShareDeleteManyArgs} args - Arguments to filter ProtocolShares to delete.
     * @example
     * // Delete a few ProtocolShares
     * const { count } = await prisma.protocolShare.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProtocolShareDeleteManyArgs>(args?: SelectSubset<T, ProtocolShareDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProtocolShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolShareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProtocolShares
     * const protocolShare = await prisma.protocolShare.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProtocolShareUpdateManyArgs>(args: SelectSubset<T, ProtocolShareUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProtocolShare.
     * @param {ProtocolShareUpsertArgs} args - Arguments to update or create a ProtocolShare.
     * @example
     * // Update or create a ProtocolShare
     * const protocolShare = await prisma.protocolShare.upsert({
     *   create: {
     *     // ... data to create a ProtocolShare
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProtocolShare we want to update
     *   }
     * })
     */
    upsert<T extends ProtocolShareUpsertArgs>(args: SelectSubset<T, ProtocolShareUpsertArgs<ExtArgs>>): Prisma__ProtocolShareClient<$Result.GetResult<Prisma.$ProtocolSharePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProtocolShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolShareCountArgs} args - Arguments to filter ProtocolShares to count.
     * @example
     * // Count the number of ProtocolShares
     * const count = await prisma.protocolShare.count({
     *   where: {
     *     // ... the filter for the ProtocolShares we want to count
     *   }
     * })
    **/
    count<T extends ProtocolShareCountArgs>(
      args?: Subset<T, ProtocolShareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProtocolShareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProtocolShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolShareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProtocolShareAggregateArgs>(args: Subset<T, ProtocolShareAggregateArgs>): Prisma.PrismaPromise<GetProtocolShareAggregateType<T>>

    /**
     * Group by ProtocolShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocolShareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProtocolShareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProtocolShareGroupByArgs['orderBy'] }
        : { orderBy?: ProtocolShareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProtocolShareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProtocolShareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProtocolShare model
   */
  readonly fields: ProtocolShareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProtocolShare.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProtocolShareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    protocol<T extends ProtocolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProtocolDefaultArgs<ExtArgs>>): Prisma__ProtocolClient<$Result.GetResult<Prisma.$ProtocolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sharedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sharedWithUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProtocolShare model
   */ 
  interface ProtocolShareFieldRefs {
    readonly id: FieldRef<"ProtocolShare", 'String'>
    readonly createdAt: FieldRef<"ProtocolShare", 'DateTime'>
    readonly updatedAt: FieldRef<"ProtocolShare", 'DateTime'>
    readonly protocolId: FieldRef<"ProtocolShare", 'String'>
    readonly sharedBy: FieldRef<"ProtocolShare", 'String'>
    readonly sharedWith: FieldRef<"ProtocolShare", 'String'>
    readonly permissions: FieldRef<"ProtocolShare", 'Permission[]'>
    readonly expiresAt: FieldRef<"ProtocolShare", 'DateTime'>
    readonly isActive: FieldRef<"ProtocolShare", 'Boolean'>
    readonly acceptedAt: FieldRef<"ProtocolShare", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProtocolShare findUnique
   */
  export type ProtocolShareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolShare
     */
    select?: ProtocolShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolShareInclude<ExtArgs> | null
    /**
     * Filter, which ProtocolShare to fetch.
     */
    where: ProtocolShareWhereUniqueInput
  }

  /**
   * ProtocolShare findUniqueOrThrow
   */
  export type ProtocolShareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolShare
     */
    select?: ProtocolShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolShareInclude<ExtArgs> | null
    /**
     * Filter, which ProtocolShare to fetch.
     */
    where: ProtocolShareWhereUniqueInput
  }

  /**
   * ProtocolShare findFirst
   */
  export type ProtocolShareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolShare
     */
    select?: ProtocolShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolShareInclude<ExtArgs> | null
    /**
     * Filter, which ProtocolShare to fetch.
     */
    where?: ProtocolShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProtocolShares to fetch.
     */
    orderBy?: ProtocolShareOrderByWithRelationInput | ProtocolShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProtocolShares.
     */
    cursor?: ProtocolShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProtocolShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProtocolShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProtocolShares.
     */
    distinct?: ProtocolShareScalarFieldEnum | ProtocolShareScalarFieldEnum[]
  }

  /**
   * ProtocolShare findFirstOrThrow
   */
  export type ProtocolShareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolShare
     */
    select?: ProtocolShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolShareInclude<ExtArgs> | null
    /**
     * Filter, which ProtocolShare to fetch.
     */
    where?: ProtocolShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProtocolShares to fetch.
     */
    orderBy?: ProtocolShareOrderByWithRelationInput | ProtocolShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProtocolShares.
     */
    cursor?: ProtocolShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProtocolShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProtocolShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProtocolShares.
     */
    distinct?: ProtocolShareScalarFieldEnum | ProtocolShareScalarFieldEnum[]
  }

  /**
   * ProtocolShare findMany
   */
  export type ProtocolShareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolShare
     */
    select?: ProtocolShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolShareInclude<ExtArgs> | null
    /**
     * Filter, which ProtocolShares to fetch.
     */
    where?: ProtocolShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProtocolShares to fetch.
     */
    orderBy?: ProtocolShareOrderByWithRelationInput | ProtocolShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProtocolShares.
     */
    cursor?: ProtocolShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProtocolShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProtocolShares.
     */
    skip?: number
    distinct?: ProtocolShareScalarFieldEnum | ProtocolShareScalarFieldEnum[]
  }

  /**
   * ProtocolShare create
   */
  export type ProtocolShareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolShare
     */
    select?: ProtocolShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolShareInclude<ExtArgs> | null
    /**
     * The data needed to create a ProtocolShare.
     */
    data: XOR<ProtocolShareCreateInput, ProtocolShareUncheckedCreateInput>
  }

  /**
   * ProtocolShare createMany
   */
  export type ProtocolShareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProtocolShares.
     */
    data: ProtocolShareCreateManyInput | ProtocolShareCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProtocolShare createManyAndReturn
   */
  export type ProtocolShareCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolShare
     */
    select?: ProtocolShareSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProtocolShares.
     */
    data: ProtocolShareCreateManyInput | ProtocolShareCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolShareIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProtocolShare update
   */
  export type ProtocolShareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolShare
     */
    select?: ProtocolShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolShareInclude<ExtArgs> | null
    /**
     * The data needed to update a ProtocolShare.
     */
    data: XOR<ProtocolShareUpdateInput, ProtocolShareUncheckedUpdateInput>
    /**
     * Choose, which ProtocolShare to update.
     */
    where: ProtocolShareWhereUniqueInput
  }

  /**
   * ProtocolShare updateMany
   */
  export type ProtocolShareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProtocolShares.
     */
    data: XOR<ProtocolShareUpdateManyMutationInput, ProtocolShareUncheckedUpdateManyInput>
    /**
     * Filter which ProtocolShares to update
     */
    where?: ProtocolShareWhereInput
  }

  /**
   * ProtocolShare upsert
   */
  export type ProtocolShareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolShare
     */
    select?: ProtocolShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolShareInclude<ExtArgs> | null
    /**
     * The filter to search for the ProtocolShare to update in case it exists.
     */
    where: ProtocolShareWhereUniqueInput
    /**
     * In case the ProtocolShare found by the `where` argument doesn't exist, create a new ProtocolShare with this data.
     */
    create: XOR<ProtocolShareCreateInput, ProtocolShareUncheckedCreateInput>
    /**
     * In case the ProtocolShare was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProtocolShareUpdateInput, ProtocolShareUncheckedUpdateInput>
  }

  /**
   * ProtocolShare delete
   */
  export type ProtocolShareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolShare
     */
    select?: ProtocolShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolShareInclude<ExtArgs> | null
    /**
     * Filter which ProtocolShare to delete.
     */
    where: ProtocolShareWhereUniqueInput
  }

  /**
   * ProtocolShare deleteMany
   */
  export type ProtocolShareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProtocolShares to delete
     */
    where?: ProtocolShareWhereInput
  }

  /**
   * ProtocolShare without action
   */
  export type ProtocolShareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocolShare
     */
    select?: ProtocolShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocolShareInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    domain: 'domain',
    isActive: 'isActive',
    settings: 'settings',
    maxUsers: 'maxUsers',
    maxProtocols: 'maxProtocols'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    email: 'email',
    name: 'name',
    tenantId: 'tenantId',
    isActive: 'isActive',
    lastLoginAt: 'lastLoginAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProtocolScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    tenantId: 'tenantId',
    name: 'name',
    version: 'version',
    description: 'description',
    category: 'category',
    difficulty: 'difficulty',
    duration: 'duration',
    frequency: 'frequency',
    ownerId: 'ownerId',
    visibility: 'visibility',
    isActive: 'isActive',
    isPublic: 'isPublic',
    overview: 'overview',
    principles: 'principles',
    requirements: 'requirements'
  };

  export type ProtocolScalarFieldEnum = (typeof ProtocolScalarFieldEnum)[keyof typeof ProtocolScalarFieldEnum]


  export const BlockScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    protocolId: 'protocolId',
    name: 'name',
    description: 'description',
    order: 'order',
    duration: 'duration',
    phase: 'phase',
    intensity: 'intensity',
    volume: 'volume',
    parameters: 'parameters',
    rules: 'rules'
  };

  export type BlockScalarFieldEnum = (typeof BlockScalarFieldEnum)[keyof typeof BlockScalarFieldEnum]


  export const BlockSessionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    blockId: 'blockId',
    name: 'name',
    dayOfWeek: 'dayOfWeek',
    order: 'order',
    exercises: 'exercises',
    duration: 'duration',
    notes: 'notes',
    intensity: 'intensity',
    volume: 'volume',
    rpe: 'rpe'
  };

  export type BlockSessionScalarFieldEnum = (typeof BlockSessionScalarFieldEnum)[keyof typeof BlockSessionScalarFieldEnum]


  export const BlockProgressionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    blockId: 'blockId',
    week: 'week',
    parameters: 'parameters',
    rules: 'rules',
    triggers: 'triggers'
  };

  export type BlockProgressionScalarFieldEnum = (typeof BlockProgressionScalarFieldEnum)[keyof typeof BlockProgressionScalarFieldEnum]


  export const ProtocolPermissionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    protocolId: 'protocolId',
    userId: 'userId',
    role: 'role',
    permissions: 'permissions',
    grantedBy: 'grantedBy',
    grantedAt: 'grantedAt',
    expiresAt: 'expiresAt',
    isActive: 'isActive'
  };

  export type ProtocolPermissionScalarFieldEnum = (typeof ProtocolPermissionScalarFieldEnum)[keyof typeof ProtocolPermissionScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    action: 'action',
    resourceType: 'resourceType',
    resourceId: 'resourceId',
    userId: 'userId',
    tenantId: 'tenantId',
    ip: 'ip',
    userAgent: 'userAgent',
    sessionId: 'sessionId',
    details: 'details',
    result: 'result'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const ProtocolTemplateScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    protocolId: 'protocolId',
    name: 'name',
    description: 'description',
    parameters: 'parameters',
    isDefault: 'isDefault',
    usageCount: 'usageCount'
  };

  export type ProtocolTemplateScalarFieldEnum = (typeof ProtocolTemplateScalarFieldEnum)[keyof typeof ProtocolTemplateScalarFieldEnum]


  export const ProtocolExecutionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    tenantId: 'tenantId',
    protocolId: 'protocolId',
    userId: 'userId',
    templateId: 'templateId',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    parameters: 'parameters',
    adaptations: 'adaptations',
    dataClassification: 'dataClassification',
    retentionUntil: 'retentionUntil',
    currentBlockId: 'currentBlockId',
    currentWeek: 'currentWeek',
    progress: 'progress'
  };

  export type ProtocolExecutionScalarFieldEnum = (typeof ProtocolExecutionScalarFieldEnum)[keyof typeof ProtocolExecutionScalarFieldEnum]


  export const BlockExecutionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    executionId: 'executionId',
    blockId: 'blockId',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    adaptations: 'adaptations',
    notes: 'notes',
    currentWeek: 'currentWeek',
    progress: 'progress'
  };

  export type BlockExecutionScalarFieldEnum = (typeof BlockExecutionScalarFieldEnum)[keyof typeof BlockExecutionScalarFieldEnum]


  export const SessionExecutionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    executionId: 'executionId',
    sessionId: 'sessionId',
    status: 'status',
    scheduledDate: 'scheduledDate',
    actualDate: 'actualDate',
    exercises: 'exercises',
    adaptations: 'adaptations',
    notes: 'notes',
    duration: 'duration',
    rpe: 'rpe',
    volume: 'volume'
  };

  export type SessionExecutionScalarFieldEnum = (typeof SessionExecutionScalarFieldEnum)[keyof typeof SessionExecutionScalarFieldEnum]


  export const ProtocolAnalyticsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    protocolId: 'protocolId',
    userId: 'userId',
    metrics: 'metrics',
    insights: 'insights',
    recommendations: 'recommendations',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd'
  };

  export type ProtocolAnalyticsScalarFieldEnum = (typeof ProtocolAnalyticsScalarFieldEnum)[keyof typeof ProtocolAnalyticsScalarFieldEnum]


  export const ProtocolShareScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    protocolId: 'protocolId',
    sharedBy: 'sharedBy',
    sharedWith: 'sharedWith',
    permissions: 'permissions',
    expiresAt: 'expiresAt',
    isActive: 'isActive',
    acceptedAt: 'acceptedAt'
  };

  export type ProtocolShareScalarFieldEnum = (typeof ProtocolShareScalarFieldEnum)[keyof typeof ProtocolShareScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Visibility'
   */
  export type EnumVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Visibility'>
    


  /**
   * Reference to a field of type 'Visibility[]'
   */
  export type ListEnumVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Visibility[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'PermissionRole'
   */
  export type EnumPermissionRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PermissionRole'>
    


  /**
   * Reference to a field of type 'PermissionRole[]'
   */
  export type ListEnumPermissionRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PermissionRole[]'>
    


  /**
   * Reference to a field of type 'Permission[]'
   */
  export type ListEnumPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Permission[]'>
    


  /**
   * Reference to a field of type 'Permission'
   */
  export type EnumPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Permission'>
    


  /**
   * Reference to a field of type 'DataClassification'
   */
  export type EnumDataClassificationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataClassification'>
    


  /**
   * Reference to a field of type 'DataClassification[]'
   */
  export type ListEnumDataClassificationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataClassification[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    name?: StringFilter<"Tenant"> | string
    domain?: StringNullableFilter<"Tenant"> | string | null
    isActive?: BoolFilter<"Tenant"> | boolean
    settings?: JsonNullableFilter<"Tenant">
    maxUsers?: IntFilter<"Tenant"> | number
    maxProtocols?: IntFilter<"Tenant"> | number
    protocols?: ProtocolListRelationFilter
    users?: UserListRelationFilter
    executions?: ProtocolExecutionListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    isActive?: SortOrder
    settings?: SortOrderInput | SortOrder
    maxUsers?: SortOrder
    maxProtocols?: SortOrder
    protocols?: ProtocolOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    executions?: ProtocolExecutionOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    domain?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    isActive?: BoolFilter<"Tenant"> | boolean
    settings?: JsonNullableFilter<"Tenant">
    maxUsers?: IntFilter<"Tenant"> | number
    maxProtocols?: IntFilter<"Tenant"> | number
    protocols?: ProtocolListRelationFilter
    users?: UserListRelationFilter
    executions?: ProtocolExecutionListRelationFilter
  }, "id" | "name" | "domain">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    isActive?: SortOrder
    settings?: SortOrderInput | SortOrder
    maxUsers?: SortOrder
    maxProtocols?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _avg?: TenantAvgOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
    _sum?: TenantSumOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    domain?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    isActive?: BoolWithAggregatesFilter<"Tenant"> | boolean
    settings?: JsonNullableWithAggregatesFilter<"Tenant">
    maxUsers?: IntWithAggregatesFilter<"Tenant"> | number
    maxProtocols?: IntWithAggregatesFilter<"Tenant"> | number
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    tenantId?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    protocols?: ProtocolListRelationFilter
    executions?: ProtocolExecutionListRelationFilter
    permissions?: ProtocolPermissionListRelationFilter
    sharedProtocols?: ProtocolShareListRelationFilter
    receivedProtocols?: ProtocolShareListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    protocols?: ProtocolOrderByRelationAggregateInput
    executions?: ProtocolExecutionOrderByRelationAggregateInput
    permissions?: ProtocolPermissionOrderByRelationAggregateInput
    sharedProtocols?: ProtocolShareOrderByRelationAggregateInput
    receivedProtocols?: ProtocolShareOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    name?: StringNullableFilter<"User"> | string | null
    tenantId?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    protocols?: ProtocolListRelationFilter
    executions?: ProtocolExecutionListRelationFilter
    permissions?: ProtocolPermissionListRelationFilter
    sharedProtocols?: ProtocolShareListRelationFilter
    receivedProtocols?: ProtocolShareListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    tenantId?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type ProtocolWhereInput = {
    AND?: ProtocolWhereInput | ProtocolWhereInput[]
    OR?: ProtocolWhereInput[]
    NOT?: ProtocolWhereInput | ProtocolWhereInput[]
    id?: StringFilter<"Protocol"> | string
    createdAt?: DateTimeFilter<"Protocol"> | Date | string
    updatedAt?: DateTimeFilter<"Protocol"> | Date | string
    tenantId?: StringFilter<"Protocol"> | string
    name?: StringFilter<"Protocol"> | string
    version?: StringFilter<"Protocol"> | string
    description?: StringNullableFilter<"Protocol"> | string | null
    category?: StringFilter<"Protocol"> | string
    difficulty?: StringFilter<"Protocol"> | string
    duration?: IntNullableFilter<"Protocol"> | number | null
    frequency?: IntNullableFilter<"Protocol"> | number | null
    ownerId?: StringFilter<"Protocol"> | string
    visibility?: EnumVisibilityFilter<"Protocol"> | $Enums.Visibility
    isActive?: BoolFilter<"Protocol"> | boolean
    isPublic?: BoolFilter<"Protocol"> | boolean
    overview?: StringNullableFilter<"Protocol"> | string | null
    principles?: StringNullableListFilter<"Protocol">
    requirements?: StringNullableListFilter<"Protocol">
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    owner?: XOR<UserRelationFilter, UserWhereInput>
    blocks?: BlockListRelationFilter
    templates?: ProtocolTemplateListRelationFilter
    executions?: ProtocolExecutionListRelationFilter
    permissions?: ProtocolPermissionListRelationFilter
    shares?: ProtocolShareListRelationFilter
  }

  export type ProtocolOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    version?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    visibility?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    overview?: SortOrderInput | SortOrder
    principles?: SortOrder
    requirements?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    blocks?: BlockOrderByRelationAggregateInput
    templates?: ProtocolTemplateOrderByRelationAggregateInput
    executions?: ProtocolExecutionOrderByRelationAggregateInput
    permissions?: ProtocolPermissionOrderByRelationAggregateInput
    shares?: ProtocolShareOrderByRelationAggregateInput
  }

  export type ProtocolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ProtocolWhereInput | ProtocolWhereInput[]
    OR?: ProtocolWhereInput[]
    NOT?: ProtocolWhereInput | ProtocolWhereInput[]
    createdAt?: DateTimeFilter<"Protocol"> | Date | string
    updatedAt?: DateTimeFilter<"Protocol"> | Date | string
    tenantId?: StringFilter<"Protocol"> | string
    version?: StringFilter<"Protocol"> | string
    description?: StringNullableFilter<"Protocol"> | string | null
    category?: StringFilter<"Protocol"> | string
    difficulty?: StringFilter<"Protocol"> | string
    duration?: IntNullableFilter<"Protocol"> | number | null
    frequency?: IntNullableFilter<"Protocol"> | number | null
    ownerId?: StringFilter<"Protocol"> | string
    visibility?: EnumVisibilityFilter<"Protocol"> | $Enums.Visibility
    isActive?: BoolFilter<"Protocol"> | boolean
    isPublic?: BoolFilter<"Protocol"> | boolean
    overview?: StringNullableFilter<"Protocol"> | string | null
    principles?: StringNullableListFilter<"Protocol">
    requirements?: StringNullableListFilter<"Protocol">
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    owner?: XOR<UserRelationFilter, UserWhereInput>
    blocks?: BlockListRelationFilter
    templates?: ProtocolTemplateListRelationFilter
    executions?: ProtocolExecutionListRelationFilter
    permissions?: ProtocolPermissionListRelationFilter
    shares?: ProtocolShareListRelationFilter
  }, "id" | "name">

  export type ProtocolOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    version?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    visibility?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    overview?: SortOrderInput | SortOrder
    principles?: SortOrder
    requirements?: SortOrder
    _count?: ProtocolCountOrderByAggregateInput
    _avg?: ProtocolAvgOrderByAggregateInput
    _max?: ProtocolMaxOrderByAggregateInput
    _min?: ProtocolMinOrderByAggregateInput
    _sum?: ProtocolSumOrderByAggregateInput
  }

  export type ProtocolScalarWhereWithAggregatesInput = {
    AND?: ProtocolScalarWhereWithAggregatesInput | ProtocolScalarWhereWithAggregatesInput[]
    OR?: ProtocolScalarWhereWithAggregatesInput[]
    NOT?: ProtocolScalarWhereWithAggregatesInput | ProtocolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Protocol"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Protocol"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Protocol"> | Date | string
    tenantId?: StringWithAggregatesFilter<"Protocol"> | string
    name?: StringWithAggregatesFilter<"Protocol"> | string
    version?: StringWithAggregatesFilter<"Protocol"> | string
    description?: StringNullableWithAggregatesFilter<"Protocol"> | string | null
    category?: StringWithAggregatesFilter<"Protocol"> | string
    difficulty?: StringWithAggregatesFilter<"Protocol"> | string
    duration?: IntNullableWithAggregatesFilter<"Protocol"> | number | null
    frequency?: IntNullableWithAggregatesFilter<"Protocol"> | number | null
    ownerId?: StringWithAggregatesFilter<"Protocol"> | string
    visibility?: EnumVisibilityWithAggregatesFilter<"Protocol"> | $Enums.Visibility
    isActive?: BoolWithAggregatesFilter<"Protocol"> | boolean
    isPublic?: BoolWithAggregatesFilter<"Protocol"> | boolean
    overview?: StringNullableWithAggregatesFilter<"Protocol"> | string | null
    principles?: StringNullableListFilter<"Protocol">
    requirements?: StringNullableListFilter<"Protocol">
  }

  export type BlockWhereInput = {
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    id?: StringFilter<"Block"> | string
    createdAt?: DateTimeFilter<"Block"> | Date | string
    updatedAt?: DateTimeFilter<"Block"> | Date | string
    protocolId?: StringFilter<"Block"> | string
    name?: StringFilter<"Block"> | string
    description?: StringNullableFilter<"Block"> | string | null
    order?: IntFilter<"Block"> | number
    duration?: IntFilter<"Block"> | number
    phase?: StringFilter<"Block"> | string
    intensity?: StringFilter<"Block"> | string
    volume?: StringFilter<"Block"> | string
    parameters?: JsonNullableFilter<"Block">
    rules?: JsonNullableFilter<"Block">
    protocol?: XOR<ProtocolRelationFilter, ProtocolWhereInput>
    sessions?: BlockSessionListRelationFilter
    progressions?: BlockProgressionListRelationFilter
    executions?: BlockExecutionListRelationFilter
  }

  export type BlockOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    duration?: SortOrder
    phase?: SortOrder
    intensity?: SortOrder
    volume?: SortOrder
    parameters?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    protocol?: ProtocolOrderByWithRelationInput
    sessions?: BlockSessionOrderByRelationAggregateInput
    progressions?: BlockProgressionOrderByRelationAggregateInput
    executions?: BlockExecutionOrderByRelationAggregateInput
  }

  export type BlockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    createdAt?: DateTimeFilter<"Block"> | Date | string
    updatedAt?: DateTimeFilter<"Block"> | Date | string
    protocolId?: StringFilter<"Block"> | string
    name?: StringFilter<"Block"> | string
    description?: StringNullableFilter<"Block"> | string | null
    order?: IntFilter<"Block"> | number
    duration?: IntFilter<"Block"> | number
    phase?: StringFilter<"Block"> | string
    intensity?: StringFilter<"Block"> | string
    volume?: StringFilter<"Block"> | string
    parameters?: JsonNullableFilter<"Block">
    rules?: JsonNullableFilter<"Block">
    protocol?: XOR<ProtocolRelationFilter, ProtocolWhereInput>
    sessions?: BlockSessionListRelationFilter
    progressions?: BlockProgressionListRelationFilter
    executions?: BlockExecutionListRelationFilter
  }, "id">

  export type BlockOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    duration?: SortOrder
    phase?: SortOrder
    intensity?: SortOrder
    volume?: SortOrder
    parameters?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    _count?: BlockCountOrderByAggregateInput
    _avg?: BlockAvgOrderByAggregateInput
    _max?: BlockMaxOrderByAggregateInput
    _min?: BlockMinOrderByAggregateInput
    _sum?: BlockSumOrderByAggregateInput
  }

  export type BlockScalarWhereWithAggregatesInput = {
    AND?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    OR?: BlockScalarWhereWithAggregatesInput[]
    NOT?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Block"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Block"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Block"> | Date | string
    protocolId?: StringWithAggregatesFilter<"Block"> | string
    name?: StringWithAggregatesFilter<"Block"> | string
    description?: StringNullableWithAggregatesFilter<"Block"> | string | null
    order?: IntWithAggregatesFilter<"Block"> | number
    duration?: IntWithAggregatesFilter<"Block"> | number
    phase?: StringWithAggregatesFilter<"Block"> | string
    intensity?: StringWithAggregatesFilter<"Block"> | string
    volume?: StringWithAggregatesFilter<"Block"> | string
    parameters?: JsonNullableWithAggregatesFilter<"Block">
    rules?: JsonNullableWithAggregatesFilter<"Block">
  }

  export type BlockSessionWhereInput = {
    AND?: BlockSessionWhereInput | BlockSessionWhereInput[]
    OR?: BlockSessionWhereInput[]
    NOT?: BlockSessionWhereInput | BlockSessionWhereInput[]
    id?: StringFilter<"BlockSession"> | string
    createdAt?: DateTimeFilter<"BlockSession"> | Date | string
    updatedAt?: DateTimeFilter<"BlockSession"> | Date | string
    blockId?: StringFilter<"BlockSession"> | string
    name?: StringFilter<"BlockSession"> | string
    dayOfWeek?: IntFilter<"BlockSession"> | number
    order?: IntFilter<"BlockSession"> | number
    exercises?: JsonFilter<"BlockSession">
    duration?: IntNullableFilter<"BlockSession"> | number | null
    notes?: StringNullableFilter<"BlockSession"> | string | null
    intensity?: FloatNullableFilter<"BlockSession"> | number | null
    volume?: FloatNullableFilter<"BlockSession"> | number | null
    rpe?: FloatNullableFilter<"BlockSession"> | number | null
    block?: XOR<BlockRelationFilter, BlockWhereInput>
  }

  export type BlockSessionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    blockId?: SortOrder
    name?: SortOrder
    dayOfWeek?: SortOrder
    order?: SortOrder
    exercises?: SortOrder
    duration?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    intensity?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    rpe?: SortOrderInput | SortOrder
    block?: BlockOrderByWithRelationInput
  }

  export type BlockSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlockSessionWhereInput | BlockSessionWhereInput[]
    OR?: BlockSessionWhereInput[]
    NOT?: BlockSessionWhereInput | BlockSessionWhereInput[]
    createdAt?: DateTimeFilter<"BlockSession"> | Date | string
    updatedAt?: DateTimeFilter<"BlockSession"> | Date | string
    blockId?: StringFilter<"BlockSession"> | string
    name?: StringFilter<"BlockSession"> | string
    dayOfWeek?: IntFilter<"BlockSession"> | number
    order?: IntFilter<"BlockSession"> | number
    exercises?: JsonFilter<"BlockSession">
    duration?: IntNullableFilter<"BlockSession"> | number | null
    notes?: StringNullableFilter<"BlockSession"> | string | null
    intensity?: FloatNullableFilter<"BlockSession"> | number | null
    volume?: FloatNullableFilter<"BlockSession"> | number | null
    rpe?: FloatNullableFilter<"BlockSession"> | number | null
    block?: XOR<BlockRelationFilter, BlockWhereInput>
  }, "id">

  export type BlockSessionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    blockId?: SortOrder
    name?: SortOrder
    dayOfWeek?: SortOrder
    order?: SortOrder
    exercises?: SortOrder
    duration?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    intensity?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    rpe?: SortOrderInput | SortOrder
    _count?: BlockSessionCountOrderByAggregateInput
    _avg?: BlockSessionAvgOrderByAggregateInput
    _max?: BlockSessionMaxOrderByAggregateInput
    _min?: BlockSessionMinOrderByAggregateInput
    _sum?: BlockSessionSumOrderByAggregateInput
  }

  export type BlockSessionScalarWhereWithAggregatesInput = {
    AND?: BlockSessionScalarWhereWithAggregatesInput | BlockSessionScalarWhereWithAggregatesInput[]
    OR?: BlockSessionScalarWhereWithAggregatesInput[]
    NOT?: BlockSessionScalarWhereWithAggregatesInput | BlockSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlockSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BlockSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlockSession"> | Date | string
    blockId?: StringWithAggregatesFilter<"BlockSession"> | string
    name?: StringWithAggregatesFilter<"BlockSession"> | string
    dayOfWeek?: IntWithAggregatesFilter<"BlockSession"> | number
    order?: IntWithAggregatesFilter<"BlockSession"> | number
    exercises?: JsonWithAggregatesFilter<"BlockSession">
    duration?: IntNullableWithAggregatesFilter<"BlockSession"> | number | null
    notes?: StringNullableWithAggregatesFilter<"BlockSession"> | string | null
    intensity?: FloatNullableWithAggregatesFilter<"BlockSession"> | number | null
    volume?: FloatNullableWithAggregatesFilter<"BlockSession"> | number | null
    rpe?: FloatNullableWithAggregatesFilter<"BlockSession"> | number | null
  }

  export type BlockProgressionWhereInput = {
    AND?: BlockProgressionWhereInput | BlockProgressionWhereInput[]
    OR?: BlockProgressionWhereInput[]
    NOT?: BlockProgressionWhereInput | BlockProgressionWhereInput[]
    id?: StringFilter<"BlockProgression"> | string
    createdAt?: DateTimeFilter<"BlockProgression"> | Date | string
    updatedAt?: DateTimeFilter<"BlockProgression"> | Date | string
    blockId?: StringFilter<"BlockProgression"> | string
    week?: IntFilter<"BlockProgression"> | number
    parameters?: JsonFilter<"BlockProgression">
    rules?: JsonNullableFilter<"BlockProgression">
    triggers?: JsonNullableFilter<"BlockProgression">
    block?: XOR<BlockRelationFilter, BlockWhereInput>
  }

  export type BlockProgressionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    blockId?: SortOrder
    week?: SortOrder
    parameters?: SortOrder
    rules?: SortOrderInput | SortOrder
    triggers?: SortOrderInput | SortOrder
    block?: BlockOrderByWithRelationInput
  }

  export type BlockProgressionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    blockId_week?: BlockProgressionBlockIdWeekCompoundUniqueInput
    AND?: BlockProgressionWhereInput | BlockProgressionWhereInput[]
    OR?: BlockProgressionWhereInput[]
    NOT?: BlockProgressionWhereInput | BlockProgressionWhereInput[]
    createdAt?: DateTimeFilter<"BlockProgression"> | Date | string
    updatedAt?: DateTimeFilter<"BlockProgression"> | Date | string
    blockId?: StringFilter<"BlockProgression"> | string
    week?: IntFilter<"BlockProgression"> | number
    parameters?: JsonFilter<"BlockProgression">
    rules?: JsonNullableFilter<"BlockProgression">
    triggers?: JsonNullableFilter<"BlockProgression">
    block?: XOR<BlockRelationFilter, BlockWhereInput>
  }, "id" | "blockId_week">

  export type BlockProgressionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    blockId?: SortOrder
    week?: SortOrder
    parameters?: SortOrder
    rules?: SortOrderInput | SortOrder
    triggers?: SortOrderInput | SortOrder
    _count?: BlockProgressionCountOrderByAggregateInput
    _avg?: BlockProgressionAvgOrderByAggregateInput
    _max?: BlockProgressionMaxOrderByAggregateInput
    _min?: BlockProgressionMinOrderByAggregateInput
    _sum?: BlockProgressionSumOrderByAggregateInput
  }

  export type BlockProgressionScalarWhereWithAggregatesInput = {
    AND?: BlockProgressionScalarWhereWithAggregatesInput | BlockProgressionScalarWhereWithAggregatesInput[]
    OR?: BlockProgressionScalarWhereWithAggregatesInput[]
    NOT?: BlockProgressionScalarWhereWithAggregatesInput | BlockProgressionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlockProgression"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BlockProgression"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlockProgression"> | Date | string
    blockId?: StringWithAggregatesFilter<"BlockProgression"> | string
    week?: IntWithAggregatesFilter<"BlockProgression"> | number
    parameters?: JsonWithAggregatesFilter<"BlockProgression">
    rules?: JsonNullableWithAggregatesFilter<"BlockProgression">
    triggers?: JsonNullableWithAggregatesFilter<"BlockProgression">
  }

  export type ProtocolPermissionWhereInput = {
    AND?: ProtocolPermissionWhereInput | ProtocolPermissionWhereInput[]
    OR?: ProtocolPermissionWhereInput[]
    NOT?: ProtocolPermissionWhereInput | ProtocolPermissionWhereInput[]
    id?: StringFilter<"ProtocolPermission"> | string
    createdAt?: DateTimeFilter<"ProtocolPermission"> | Date | string
    updatedAt?: DateTimeFilter<"ProtocolPermission"> | Date | string
    protocolId?: StringFilter<"ProtocolPermission"> | string
    userId?: StringFilter<"ProtocolPermission"> | string
    role?: EnumPermissionRoleFilter<"ProtocolPermission"> | $Enums.PermissionRole
    permissions?: EnumPermissionNullableListFilter<"ProtocolPermission">
    grantedBy?: StringFilter<"ProtocolPermission"> | string
    grantedAt?: DateTimeFilter<"ProtocolPermission"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ProtocolPermission"> | Date | string | null
    isActive?: BoolFilter<"ProtocolPermission"> | boolean
    protocol?: XOR<ProtocolRelationFilter, ProtocolWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProtocolPermissionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    grantedBy?: SortOrder
    grantedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    protocol?: ProtocolOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProtocolPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    protocolId_userId?: ProtocolPermissionProtocolIdUserIdCompoundUniqueInput
    AND?: ProtocolPermissionWhereInput | ProtocolPermissionWhereInput[]
    OR?: ProtocolPermissionWhereInput[]
    NOT?: ProtocolPermissionWhereInput | ProtocolPermissionWhereInput[]
    createdAt?: DateTimeFilter<"ProtocolPermission"> | Date | string
    updatedAt?: DateTimeFilter<"ProtocolPermission"> | Date | string
    protocolId?: StringFilter<"ProtocolPermission"> | string
    userId?: StringFilter<"ProtocolPermission"> | string
    role?: EnumPermissionRoleFilter<"ProtocolPermission"> | $Enums.PermissionRole
    permissions?: EnumPermissionNullableListFilter<"ProtocolPermission">
    grantedBy?: StringFilter<"ProtocolPermission"> | string
    grantedAt?: DateTimeFilter<"ProtocolPermission"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ProtocolPermission"> | Date | string | null
    isActive?: BoolFilter<"ProtocolPermission"> | boolean
    protocol?: XOR<ProtocolRelationFilter, ProtocolWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "protocolId_userId">

  export type ProtocolPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    grantedBy?: SortOrder
    grantedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: ProtocolPermissionCountOrderByAggregateInput
    _max?: ProtocolPermissionMaxOrderByAggregateInput
    _min?: ProtocolPermissionMinOrderByAggregateInput
  }

  export type ProtocolPermissionScalarWhereWithAggregatesInput = {
    AND?: ProtocolPermissionScalarWhereWithAggregatesInput | ProtocolPermissionScalarWhereWithAggregatesInput[]
    OR?: ProtocolPermissionScalarWhereWithAggregatesInput[]
    NOT?: ProtocolPermissionScalarWhereWithAggregatesInput | ProtocolPermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProtocolPermission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProtocolPermission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProtocolPermission"> | Date | string
    protocolId?: StringWithAggregatesFilter<"ProtocolPermission"> | string
    userId?: StringWithAggregatesFilter<"ProtocolPermission"> | string
    role?: EnumPermissionRoleWithAggregatesFilter<"ProtocolPermission"> | $Enums.PermissionRole
    permissions?: EnumPermissionNullableListFilter<"ProtocolPermission">
    grantedBy?: StringWithAggregatesFilter<"ProtocolPermission"> | string
    grantedAt?: DateTimeWithAggregatesFilter<"ProtocolPermission"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ProtocolPermission"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"ProtocolPermission"> | boolean
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    action?: StringFilter<"AuditLog"> | string
    resourceType?: StringFilter<"AuditLog"> | string
    resourceId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    tenantId?: StringFilter<"AuditLog"> | string
    ip?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    sessionId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    result?: StringFilter<"AuditLog"> | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    result?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    action?: StringFilter<"AuditLog"> | string
    resourceType?: StringFilter<"AuditLog"> | string
    resourceId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    tenantId?: StringFilter<"AuditLog"> | string
    ip?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    sessionId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    result?: StringFilter<"AuditLog"> | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    result?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceType?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    tenantId?: StringWithAggregatesFilter<"AuditLog"> | string
    ip?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    result?: StringWithAggregatesFilter<"AuditLog"> | string
  }

  export type ProtocolTemplateWhereInput = {
    AND?: ProtocolTemplateWhereInput | ProtocolTemplateWhereInput[]
    OR?: ProtocolTemplateWhereInput[]
    NOT?: ProtocolTemplateWhereInput | ProtocolTemplateWhereInput[]
    id?: StringFilter<"ProtocolTemplate"> | string
    createdAt?: DateTimeFilter<"ProtocolTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ProtocolTemplate"> | Date | string
    protocolId?: StringFilter<"ProtocolTemplate"> | string
    name?: StringFilter<"ProtocolTemplate"> | string
    description?: StringNullableFilter<"ProtocolTemplate"> | string | null
    parameters?: JsonFilter<"ProtocolTemplate">
    isDefault?: BoolFilter<"ProtocolTemplate"> | boolean
    usageCount?: IntFilter<"ProtocolTemplate"> | number
    protocol?: XOR<ProtocolRelationFilter, ProtocolWhereInput>
  }

  export type ProtocolTemplateOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    parameters?: SortOrder
    isDefault?: SortOrder
    usageCount?: SortOrder
    protocol?: ProtocolOrderByWithRelationInput
  }

  export type ProtocolTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProtocolTemplateWhereInput | ProtocolTemplateWhereInput[]
    OR?: ProtocolTemplateWhereInput[]
    NOT?: ProtocolTemplateWhereInput | ProtocolTemplateWhereInput[]
    createdAt?: DateTimeFilter<"ProtocolTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ProtocolTemplate"> | Date | string
    protocolId?: StringFilter<"ProtocolTemplate"> | string
    name?: StringFilter<"ProtocolTemplate"> | string
    description?: StringNullableFilter<"ProtocolTemplate"> | string | null
    parameters?: JsonFilter<"ProtocolTemplate">
    isDefault?: BoolFilter<"ProtocolTemplate"> | boolean
    usageCount?: IntFilter<"ProtocolTemplate"> | number
    protocol?: XOR<ProtocolRelationFilter, ProtocolWhereInput>
  }, "id">

  export type ProtocolTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    parameters?: SortOrder
    isDefault?: SortOrder
    usageCount?: SortOrder
    _count?: ProtocolTemplateCountOrderByAggregateInput
    _avg?: ProtocolTemplateAvgOrderByAggregateInput
    _max?: ProtocolTemplateMaxOrderByAggregateInput
    _min?: ProtocolTemplateMinOrderByAggregateInput
    _sum?: ProtocolTemplateSumOrderByAggregateInput
  }

  export type ProtocolTemplateScalarWhereWithAggregatesInput = {
    AND?: ProtocolTemplateScalarWhereWithAggregatesInput | ProtocolTemplateScalarWhereWithAggregatesInput[]
    OR?: ProtocolTemplateScalarWhereWithAggregatesInput[]
    NOT?: ProtocolTemplateScalarWhereWithAggregatesInput | ProtocolTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProtocolTemplate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProtocolTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProtocolTemplate"> | Date | string
    protocolId?: StringWithAggregatesFilter<"ProtocolTemplate"> | string
    name?: StringWithAggregatesFilter<"ProtocolTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"ProtocolTemplate"> | string | null
    parameters?: JsonWithAggregatesFilter<"ProtocolTemplate">
    isDefault?: BoolWithAggregatesFilter<"ProtocolTemplate"> | boolean
    usageCount?: IntWithAggregatesFilter<"ProtocolTemplate"> | number
  }

  export type ProtocolExecutionWhereInput = {
    AND?: ProtocolExecutionWhereInput | ProtocolExecutionWhereInput[]
    OR?: ProtocolExecutionWhereInput[]
    NOT?: ProtocolExecutionWhereInput | ProtocolExecutionWhereInput[]
    id?: StringFilter<"ProtocolExecution"> | string
    createdAt?: DateTimeFilter<"ProtocolExecution"> | Date | string
    updatedAt?: DateTimeFilter<"ProtocolExecution"> | Date | string
    tenantId?: StringFilter<"ProtocolExecution"> | string
    protocolId?: StringFilter<"ProtocolExecution"> | string
    userId?: StringFilter<"ProtocolExecution"> | string
    templateId?: StringNullableFilter<"ProtocolExecution"> | string | null
    status?: StringFilter<"ProtocolExecution"> | string
    startDate?: DateTimeFilter<"ProtocolExecution"> | Date | string
    endDate?: DateTimeNullableFilter<"ProtocolExecution"> | Date | string | null
    parameters?: JsonFilter<"ProtocolExecution">
    adaptations?: JsonNullableFilter<"ProtocolExecution">
    dataClassification?: EnumDataClassificationFilter<"ProtocolExecution"> | $Enums.DataClassification
    retentionUntil?: DateTimeNullableFilter<"ProtocolExecution"> | Date | string | null
    currentBlockId?: StringNullableFilter<"ProtocolExecution"> | string | null
    currentWeek?: IntFilter<"ProtocolExecution"> | number
    progress?: FloatFilter<"ProtocolExecution"> | number
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    protocol?: XOR<ProtocolRelationFilter, ProtocolWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    blockExecutions?: BlockExecutionListRelationFilter
    sessions?: SessionExecutionListRelationFilter
  }

  export type ProtocolExecutionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenantId?: SortOrder
    protocolId?: SortOrder
    userId?: SortOrder
    templateId?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    parameters?: SortOrder
    adaptations?: SortOrderInput | SortOrder
    dataClassification?: SortOrder
    retentionUntil?: SortOrderInput | SortOrder
    currentBlockId?: SortOrderInput | SortOrder
    currentWeek?: SortOrder
    progress?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    protocol?: ProtocolOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    blockExecutions?: BlockExecutionOrderByRelationAggregateInput
    sessions?: SessionExecutionOrderByRelationAggregateInput
  }

  export type ProtocolExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProtocolExecutionWhereInput | ProtocolExecutionWhereInput[]
    OR?: ProtocolExecutionWhereInput[]
    NOT?: ProtocolExecutionWhereInput | ProtocolExecutionWhereInput[]
    createdAt?: DateTimeFilter<"ProtocolExecution"> | Date | string
    updatedAt?: DateTimeFilter<"ProtocolExecution"> | Date | string
    tenantId?: StringFilter<"ProtocolExecution"> | string
    protocolId?: StringFilter<"ProtocolExecution"> | string
    userId?: StringFilter<"ProtocolExecution"> | string
    templateId?: StringNullableFilter<"ProtocolExecution"> | string | null
    status?: StringFilter<"ProtocolExecution"> | string
    startDate?: DateTimeFilter<"ProtocolExecution"> | Date | string
    endDate?: DateTimeNullableFilter<"ProtocolExecution"> | Date | string | null
    parameters?: JsonFilter<"ProtocolExecution">
    adaptations?: JsonNullableFilter<"ProtocolExecution">
    dataClassification?: EnumDataClassificationFilter<"ProtocolExecution"> | $Enums.DataClassification
    retentionUntil?: DateTimeNullableFilter<"ProtocolExecution"> | Date | string | null
    currentBlockId?: StringNullableFilter<"ProtocolExecution"> | string | null
    currentWeek?: IntFilter<"ProtocolExecution"> | number
    progress?: FloatFilter<"ProtocolExecution"> | number
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    protocol?: XOR<ProtocolRelationFilter, ProtocolWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    blockExecutions?: BlockExecutionListRelationFilter
    sessions?: SessionExecutionListRelationFilter
  }, "id">

  export type ProtocolExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenantId?: SortOrder
    protocolId?: SortOrder
    userId?: SortOrder
    templateId?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    parameters?: SortOrder
    adaptations?: SortOrderInput | SortOrder
    dataClassification?: SortOrder
    retentionUntil?: SortOrderInput | SortOrder
    currentBlockId?: SortOrderInput | SortOrder
    currentWeek?: SortOrder
    progress?: SortOrder
    _count?: ProtocolExecutionCountOrderByAggregateInput
    _avg?: ProtocolExecutionAvgOrderByAggregateInput
    _max?: ProtocolExecutionMaxOrderByAggregateInput
    _min?: ProtocolExecutionMinOrderByAggregateInput
    _sum?: ProtocolExecutionSumOrderByAggregateInput
  }

  export type ProtocolExecutionScalarWhereWithAggregatesInput = {
    AND?: ProtocolExecutionScalarWhereWithAggregatesInput | ProtocolExecutionScalarWhereWithAggregatesInput[]
    OR?: ProtocolExecutionScalarWhereWithAggregatesInput[]
    NOT?: ProtocolExecutionScalarWhereWithAggregatesInput | ProtocolExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProtocolExecution"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProtocolExecution"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProtocolExecution"> | Date | string
    tenantId?: StringWithAggregatesFilter<"ProtocolExecution"> | string
    protocolId?: StringWithAggregatesFilter<"ProtocolExecution"> | string
    userId?: StringWithAggregatesFilter<"ProtocolExecution"> | string
    templateId?: StringNullableWithAggregatesFilter<"ProtocolExecution"> | string | null
    status?: StringWithAggregatesFilter<"ProtocolExecution"> | string
    startDate?: DateTimeWithAggregatesFilter<"ProtocolExecution"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"ProtocolExecution"> | Date | string | null
    parameters?: JsonWithAggregatesFilter<"ProtocolExecution">
    adaptations?: JsonNullableWithAggregatesFilter<"ProtocolExecution">
    dataClassification?: EnumDataClassificationWithAggregatesFilter<"ProtocolExecution"> | $Enums.DataClassification
    retentionUntil?: DateTimeNullableWithAggregatesFilter<"ProtocolExecution"> | Date | string | null
    currentBlockId?: StringNullableWithAggregatesFilter<"ProtocolExecution"> | string | null
    currentWeek?: IntWithAggregatesFilter<"ProtocolExecution"> | number
    progress?: FloatWithAggregatesFilter<"ProtocolExecution"> | number
  }

  export type BlockExecutionWhereInput = {
    AND?: BlockExecutionWhereInput | BlockExecutionWhereInput[]
    OR?: BlockExecutionWhereInput[]
    NOT?: BlockExecutionWhereInput | BlockExecutionWhereInput[]
    id?: StringFilter<"BlockExecution"> | string
    createdAt?: DateTimeFilter<"BlockExecution"> | Date | string
    updatedAt?: DateTimeFilter<"BlockExecution"> | Date | string
    executionId?: StringFilter<"BlockExecution"> | string
    blockId?: StringFilter<"BlockExecution"> | string
    status?: StringFilter<"BlockExecution"> | string
    startDate?: DateTimeNullableFilter<"BlockExecution"> | Date | string | null
    endDate?: DateTimeNullableFilter<"BlockExecution"> | Date | string | null
    adaptations?: JsonNullableFilter<"BlockExecution">
    notes?: StringNullableFilter<"BlockExecution"> | string | null
    currentWeek?: IntFilter<"BlockExecution"> | number
    progress?: FloatFilter<"BlockExecution"> | number
    execution?: XOR<ProtocolExecutionRelationFilter, ProtocolExecutionWhereInput>
    block?: XOR<BlockRelationFilter, BlockWhereInput>
  }

  export type BlockExecutionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    executionId?: SortOrder
    blockId?: SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    adaptations?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    currentWeek?: SortOrder
    progress?: SortOrder
    execution?: ProtocolExecutionOrderByWithRelationInput
    block?: BlockOrderByWithRelationInput
  }

  export type BlockExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlockExecutionWhereInput | BlockExecutionWhereInput[]
    OR?: BlockExecutionWhereInput[]
    NOT?: BlockExecutionWhereInput | BlockExecutionWhereInput[]
    createdAt?: DateTimeFilter<"BlockExecution"> | Date | string
    updatedAt?: DateTimeFilter<"BlockExecution"> | Date | string
    executionId?: StringFilter<"BlockExecution"> | string
    blockId?: StringFilter<"BlockExecution"> | string
    status?: StringFilter<"BlockExecution"> | string
    startDate?: DateTimeNullableFilter<"BlockExecution"> | Date | string | null
    endDate?: DateTimeNullableFilter<"BlockExecution"> | Date | string | null
    adaptations?: JsonNullableFilter<"BlockExecution">
    notes?: StringNullableFilter<"BlockExecution"> | string | null
    currentWeek?: IntFilter<"BlockExecution"> | number
    progress?: FloatFilter<"BlockExecution"> | number
    execution?: XOR<ProtocolExecutionRelationFilter, ProtocolExecutionWhereInput>
    block?: XOR<BlockRelationFilter, BlockWhereInput>
  }, "id">

  export type BlockExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    executionId?: SortOrder
    blockId?: SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    adaptations?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    currentWeek?: SortOrder
    progress?: SortOrder
    _count?: BlockExecutionCountOrderByAggregateInput
    _avg?: BlockExecutionAvgOrderByAggregateInput
    _max?: BlockExecutionMaxOrderByAggregateInput
    _min?: BlockExecutionMinOrderByAggregateInput
    _sum?: BlockExecutionSumOrderByAggregateInput
  }

  export type BlockExecutionScalarWhereWithAggregatesInput = {
    AND?: BlockExecutionScalarWhereWithAggregatesInput | BlockExecutionScalarWhereWithAggregatesInput[]
    OR?: BlockExecutionScalarWhereWithAggregatesInput[]
    NOT?: BlockExecutionScalarWhereWithAggregatesInput | BlockExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlockExecution"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BlockExecution"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlockExecution"> | Date | string
    executionId?: StringWithAggregatesFilter<"BlockExecution"> | string
    blockId?: StringWithAggregatesFilter<"BlockExecution"> | string
    status?: StringWithAggregatesFilter<"BlockExecution"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"BlockExecution"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"BlockExecution"> | Date | string | null
    adaptations?: JsonNullableWithAggregatesFilter<"BlockExecution">
    notes?: StringNullableWithAggregatesFilter<"BlockExecution"> | string | null
    currentWeek?: IntWithAggregatesFilter<"BlockExecution"> | number
    progress?: FloatWithAggregatesFilter<"BlockExecution"> | number
  }

  export type SessionExecutionWhereInput = {
    AND?: SessionExecutionWhereInput | SessionExecutionWhereInput[]
    OR?: SessionExecutionWhereInput[]
    NOT?: SessionExecutionWhereInput | SessionExecutionWhereInput[]
    id?: StringFilter<"SessionExecution"> | string
    createdAt?: DateTimeFilter<"SessionExecution"> | Date | string
    updatedAt?: DateTimeFilter<"SessionExecution"> | Date | string
    executionId?: StringFilter<"SessionExecution"> | string
    sessionId?: StringFilter<"SessionExecution"> | string
    status?: StringFilter<"SessionExecution"> | string
    scheduledDate?: DateTimeFilter<"SessionExecution"> | Date | string
    actualDate?: DateTimeNullableFilter<"SessionExecution"> | Date | string | null
    exercises?: JsonNullableFilter<"SessionExecution">
    adaptations?: JsonNullableFilter<"SessionExecution">
    notes?: StringNullableFilter<"SessionExecution"> | string | null
    duration?: IntNullableFilter<"SessionExecution"> | number | null
    rpe?: FloatNullableFilter<"SessionExecution"> | number | null
    volume?: FloatNullableFilter<"SessionExecution"> | number | null
    execution?: XOR<ProtocolExecutionRelationFilter, ProtocolExecutionWhereInput>
  }

  export type SessionExecutionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    executionId?: SortOrder
    sessionId?: SortOrder
    status?: SortOrder
    scheduledDate?: SortOrder
    actualDate?: SortOrderInput | SortOrder
    exercises?: SortOrderInput | SortOrder
    adaptations?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    rpe?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    execution?: ProtocolExecutionOrderByWithRelationInput
  }

  export type SessionExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionExecutionWhereInput | SessionExecutionWhereInput[]
    OR?: SessionExecutionWhereInput[]
    NOT?: SessionExecutionWhereInput | SessionExecutionWhereInput[]
    createdAt?: DateTimeFilter<"SessionExecution"> | Date | string
    updatedAt?: DateTimeFilter<"SessionExecution"> | Date | string
    executionId?: StringFilter<"SessionExecution"> | string
    sessionId?: StringFilter<"SessionExecution"> | string
    status?: StringFilter<"SessionExecution"> | string
    scheduledDate?: DateTimeFilter<"SessionExecution"> | Date | string
    actualDate?: DateTimeNullableFilter<"SessionExecution"> | Date | string | null
    exercises?: JsonNullableFilter<"SessionExecution">
    adaptations?: JsonNullableFilter<"SessionExecution">
    notes?: StringNullableFilter<"SessionExecution"> | string | null
    duration?: IntNullableFilter<"SessionExecution"> | number | null
    rpe?: FloatNullableFilter<"SessionExecution"> | number | null
    volume?: FloatNullableFilter<"SessionExecution"> | number | null
    execution?: XOR<ProtocolExecutionRelationFilter, ProtocolExecutionWhereInput>
  }, "id">

  export type SessionExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    executionId?: SortOrder
    sessionId?: SortOrder
    status?: SortOrder
    scheduledDate?: SortOrder
    actualDate?: SortOrderInput | SortOrder
    exercises?: SortOrderInput | SortOrder
    adaptations?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    rpe?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    _count?: SessionExecutionCountOrderByAggregateInput
    _avg?: SessionExecutionAvgOrderByAggregateInput
    _max?: SessionExecutionMaxOrderByAggregateInput
    _min?: SessionExecutionMinOrderByAggregateInput
    _sum?: SessionExecutionSumOrderByAggregateInput
  }

  export type SessionExecutionScalarWhereWithAggregatesInput = {
    AND?: SessionExecutionScalarWhereWithAggregatesInput | SessionExecutionScalarWhereWithAggregatesInput[]
    OR?: SessionExecutionScalarWhereWithAggregatesInput[]
    NOT?: SessionExecutionScalarWhereWithAggregatesInput | SessionExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SessionExecution"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SessionExecution"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SessionExecution"> | Date | string
    executionId?: StringWithAggregatesFilter<"SessionExecution"> | string
    sessionId?: StringWithAggregatesFilter<"SessionExecution"> | string
    status?: StringWithAggregatesFilter<"SessionExecution"> | string
    scheduledDate?: DateTimeWithAggregatesFilter<"SessionExecution"> | Date | string
    actualDate?: DateTimeNullableWithAggregatesFilter<"SessionExecution"> | Date | string | null
    exercises?: JsonNullableWithAggregatesFilter<"SessionExecution">
    adaptations?: JsonNullableWithAggregatesFilter<"SessionExecution">
    notes?: StringNullableWithAggregatesFilter<"SessionExecution"> | string | null
    duration?: IntNullableWithAggregatesFilter<"SessionExecution"> | number | null
    rpe?: FloatNullableWithAggregatesFilter<"SessionExecution"> | number | null
    volume?: FloatNullableWithAggregatesFilter<"SessionExecution"> | number | null
  }

  export type ProtocolAnalyticsWhereInput = {
    AND?: ProtocolAnalyticsWhereInput | ProtocolAnalyticsWhereInput[]
    OR?: ProtocolAnalyticsWhereInput[]
    NOT?: ProtocolAnalyticsWhereInput | ProtocolAnalyticsWhereInput[]
    id?: StringFilter<"ProtocolAnalytics"> | string
    createdAt?: DateTimeFilter<"ProtocolAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"ProtocolAnalytics"> | Date | string
    protocolId?: StringFilter<"ProtocolAnalytics"> | string
    userId?: StringNullableFilter<"ProtocolAnalytics"> | string | null
    metrics?: JsonFilter<"ProtocolAnalytics">
    insights?: JsonNullableFilter<"ProtocolAnalytics">
    recommendations?: JsonNullableFilter<"ProtocolAnalytics">
    periodStart?: DateTimeFilter<"ProtocolAnalytics"> | Date | string
    periodEnd?: DateTimeFilter<"ProtocolAnalytics"> | Date | string
  }

  export type ProtocolAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    userId?: SortOrderInput | SortOrder
    metrics?: SortOrder
    insights?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
  }

  export type ProtocolAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProtocolAnalyticsWhereInput | ProtocolAnalyticsWhereInput[]
    OR?: ProtocolAnalyticsWhereInput[]
    NOT?: ProtocolAnalyticsWhereInput | ProtocolAnalyticsWhereInput[]
    createdAt?: DateTimeFilter<"ProtocolAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"ProtocolAnalytics"> | Date | string
    protocolId?: StringFilter<"ProtocolAnalytics"> | string
    userId?: StringNullableFilter<"ProtocolAnalytics"> | string | null
    metrics?: JsonFilter<"ProtocolAnalytics">
    insights?: JsonNullableFilter<"ProtocolAnalytics">
    recommendations?: JsonNullableFilter<"ProtocolAnalytics">
    periodStart?: DateTimeFilter<"ProtocolAnalytics"> | Date | string
    periodEnd?: DateTimeFilter<"ProtocolAnalytics"> | Date | string
  }, "id">

  export type ProtocolAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    userId?: SortOrderInput | SortOrder
    metrics?: SortOrder
    insights?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    _count?: ProtocolAnalyticsCountOrderByAggregateInput
    _max?: ProtocolAnalyticsMaxOrderByAggregateInput
    _min?: ProtocolAnalyticsMinOrderByAggregateInput
  }

  export type ProtocolAnalyticsScalarWhereWithAggregatesInput = {
    AND?: ProtocolAnalyticsScalarWhereWithAggregatesInput | ProtocolAnalyticsScalarWhereWithAggregatesInput[]
    OR?: ProtocolAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: ProtocolAnalyticsScalarWhereWithAggregatesInput | ProtocolAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProtocolAnalytics"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProtocolAnalytics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProtocolAnalytics"> | Date | string
    protocolId?: StringWithAggregatesFilter<"ProtocolAnalytics"> | string
    userId?: StringNullableWithAggregatesFilter<"ProtocolAnalytics"> | string | null
    metrics?: JsonWithAggregatesFilter<"ProtocolAnalytics">
    insights?: JsonNullableWithAggregatesFilter<"ProtocolAnalytics">
    recommendations?: JsonNullableWithAggregatesFilter<"ProtocolAnalytics">
    periodStart?: DateTimeWithAggregatesFilter<"ProtocolAnalytics"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"ProtocolAnalytics"> | Date | string
  }

  export type ProtocolShareWhereInput = {
    AND?: ProtocolShareWhereInput | ProtocolShareWhereInput[]
    OR?: ProtocolShareWhereInput[]
    NOT?: ProtocolShareWhereInput | ProtocolShareWhereInput[]
    id?: StringFilter<"ProtocolShare"> | string
    createdAt?: DateTimeFilter<"ProtocolShare"> | Date | string
    updatedAt?: DateTimeFilter<"ProtocolShare"> | Date | string
    protocolId?: StringFilter<"ProtocolShare"> | string
    sharedBy?: StringFilter<"ProtocolShare"> | string
    sharedWith?: StringFilter<"ProtocolShare"> | string
    permissions?: EnumPermissionNullableListFilter<"ProtocolShare">
    expiresAt?: DateTimeNullableFilter<"ProtocolShare"> | Date | string | null
    isActive?: BoolFilter<"ProtocolShare"> | boolean
    acceptedAt?: DateTimeNullableFilter<"ProtocolShare"> | Date | string | null
    protocol?: XOR<ProtocolRelationFilter, ProtocolWhereInput>
    sharedByUser?: XOR<UserRelationFilter, UserWhereInput>
    sharedWithUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProtocolShareOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    sharedBy?: SortOrder
    sharedWith?: SortOrder
    permissions?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    protocol?: ProtocolOrderByWithRelationInput
    sharedByUser?: UserOrderByWithRelationInput
    sharedWithUser?: UserOrderByWithRelationInput
  }

  export type ProtocolShareWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    protocolId_sharedWith?: ProtocolShareProtocolIdSharedWithCompoundUniqueInput
    AND?: ProtocolShareWhereInput | ProtocolShareWhereInput[]
    OR?: ProtocolShareWhereInput[]
    NOT?: ProtocolShareWhereInput | ProtocolShareWhereInput[]
    createdAt?: DateTimeFilter<"ProtocolShare"> | Date | string
    updatedAt?: DateTimeFilter<"ProtocolShare"> | Date | string
    protocolId?: StringFilter<"ProtocolShare"> | string
    sharedBy?: StringFilter<"ProtocolShare"> | string
    sharedWith?: StringFilter<"ProtocolShare"> | string
    permissions?: EnumPermissionNullableListFilter<"ProtocolShare">
    expiresAt?: DateTimeNullableFilter<"ProtocolShare"> | Date | string | null
    isActive?: BoolFilter<"ProtocolShare"> | boolean
    acceptedAt?: DateTimeNullableFilter<"ProtocolShare"> | Date | string | null
    protocol?: XOR<ProtocolRelationFilter, ProtocolWhereInput>
    sharedByUser?: XOR<UserRelationFilter, UserWhereInput>
    sharedWithUser?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "protocolId_sharedWith">

  export type ProtocolShareOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    sharedBy?: SortOrder
    sharedWith?: SortOrder
    permissions?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    _count?: ProtocolShareCountOrderByAggregateInput
    _max?: ProtocolShareMaxOrderByAggregateInput
    _min?: ProtocolShareMinOrderByAggregateInput
  }

  export type ProtocolShareScalarWhereWithAggregatesInput = {
    AND?: ProtocolShareScalarWhereWithAggregatesInput | ProtocolShareScalarWhereWithAggregatesInput[]
    OR?: ProtocolShareScalarWhereWithAggregatesInput[]
    NOT?: ProtocolShareScalarWhereWithAggregatesInput | ProtocolShareScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProtocolShare"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProtocolShare"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProtocolShare"> | Date | string
    protocolId?: StringWithAggregatesFilter<"ProtocolShare"> | string
    sharedBy?: StringWithAggregatesFilter<"ProtocolShare"> | string
    sharedWith?: StringWithAggregatesFilter<"ProtocolShare"> | string
    permissions?: EnumPermissionNullableListFilter<"ProtocolShare">
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ProtocolShare"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"ProtocolShare"> | boolean
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"ProtocolShare"> | Date | string | null
  }

  export type TenantCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    domain?: string | null
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    maxUsers?: number
    maxProtocols?: number
    protocols?: ProtocolCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    executions?: ProtocolExecutionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    domain?: string | null
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    maxUsers?: number
    maxProtocols?: number
    protocols?: ProtocolUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    executions?: ProtocolExecutionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProtocols?: IntFieldUpdateOperationsInput | number
    protocols?: ProtocolUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    executions?: ProtocolExecutionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProtocols?: IntFieldUpdateOperationsInput | number
    protocols?: ProtocolUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    executions?: ProtocolExecutionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    domain?: string | null
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    maxUsers?: number
    maxProtocols?: number
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProtocols?: IntFieldUpdateOperationsInput | number
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProtocols?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutUsersInput
    protocols?: ProtocolCreateNestedManyWithoutOwnerInput
    executions?: ProtocolExecutionCreateNestedManyWithoutUserInput
    permissions?: ProtocolPermissionCreateNestedManyWithoutUserInput
    sharedProtocols?: ProtocolShareCreateNestedManyWithoutSharedByUserInput
    receivedProtocols?: ProtocolShareCreateNestedManyWithoutSharedWithUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name?: string | null
    tenantId: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    protocols?: ProtocolUncheckedCreateNestedManyWithoutOwnerInput
    executions?: ProtocolExecutionUncheckedCreateNestedManyWithoutUserInput
    permissions?: ProtocolPermissionUncheckedCreateNestedManyWithoutUserInput
    sharedProtocols?: ProtocolShareUncheckedCreateNestedManyWithoutSharedByUserInput
    receivedProtocols?: ProtocolShareUncheckedCreateNestedManyWithoutSharedWithUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    protocols?: ProtocolUpdateManyWithoutOwnerNestedInput
    executions?: ProtocolExecutionUpdateManyWithoutUserNestedInput
    permissions?: ProtocolPermissionUpdateManyWithoutUserNestedInput
    sharedProtocols?: ProtocolShareUpdateManyWithoutSharedByUserNestedInput
    receivedProtocols?: ProtocolShareUpdateManyWithoutSharedWithUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    protocols?: ProtocolUncheckedUpdateManyWithoutOwnerNestedInput
    executions?: ProtocolExecutionUncheckedUpdateManyWithoutUserNestedInput
    permissions?: ProtocolPermissionUncheckedUpdateManyWithoutUserNestedInput
    sharedProtocols?: ProtocolShareUncheckedUpdateManyWithoutSharedByUserNestedInput
    receivedProtocols?: ProtocolShareUncheckedUpdateManyWithoutSharedWithUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name?: string | null
    tenantId: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProtocolCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    version?: string
    description?: string | null
    category: string
    difficulty: string
    duration?: number | null
    frequency?: number | null
    visibility?: $Enums.Visibility
    isActive?: boolean
    isPublic?: boolean
    overview?: string | null
    principles?: ProtocolCreateprinciplesInput | string[]
    requirements?: ProtocolCreaterequirementsInput | string[]
    tenant: TenantCreateNestedOneWithoutProtocolsInput
    owner: UserCreateNestedOneWithoutProtocolsInput
    blocks?: BlockCreateNestedManyWithoutProtocolInput
    templates?: ProtocolTemplateCreateNestedManyWithoutProtocolInput
    executions?: ProtocolExecutionCreateNestedManyWithoutProtocolInput
    permissions?: ProtocolPermissionCreateNestedManyWithoutProtocolInput
    shares?: ProtocolShareCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId: string
    name: string
    version?: string
    description?: string | null
    category: string
    difficulty: string
    duration?: number | null
    frequency?: number | null
    ownerId: string
    visibility?: $Enums.Visibility
    isActive?: boolean
    isPublic?: boolean
    overview?: string | null
    principles?: ProtocolCreateprinciplesInput | string[]
    requirements?: ProtocolCreaterequirementsInput | string[]
    blocks?: BlockUncheckedCreateNestedManyWithoutProtocolInput
    templates?: ProtocolTemplateUncheckedCreateNestedManyWithoutProtocolInput
    executions?: ProtocolExecutionUncheckedCreateNestedManyWithoutProtocolInput
    permissions?: ProtocolPermissionUncheckedCreateNestedManyWithoutProtocolInput
    shares?: ProtocolShareUncheckedCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    principles?: ProtocolUpdateprinciplesInput | string[]
    requirements?: ProtocolUpdaterequirementsInput | string[]
    tenant?: TenantUpdateOneRequiredWithoutProtocolsNestedInput
    owner?: UserUpdateOneRequiredWithoutProtocolsNestedInput
    blocks?: BlockUpdateManyWithoutProtocolNestedInput
    templates?: ProtocolTemplateUpdateManyWithoutProtocolNestedInput
    executions?: ProtocolExecutionUpdateManyWithoutProtocolNestedInput
    permissions?: ProtocolPermissionUpdateManyWithoutProtocolNestedInput
    shares?: ProtocolShareUpdateManyWithoutProtocolNestedInput
  }

  export type ProtocolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    principles?: ProtocolUpdateprinciplesInput | string[]
    requirements?: ProtocolUpdaterequirementsInput | string[]
    blocks?: BlockUncheckedUpdateManyWithoutProtocolNestedInput
    templates?: ProtocolTemplateUncheckedUpdateManyWithoutProtocolNestedInput
    executions?: ProtocolExecutionUncheckedUpdateManyWithoutProtocolNestedInput
    permissions?: ProtocolPermissionUncheckedUpdateManyWithoutProtocolNestedInput
    shares?: ProtocolShareUncheckedUpdateManyWithoutProtocolNestedInput
  }

  export type ProtocolCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId: string
    name: string
    version?: string
    description?: string | null
    category: string
    difficulty: string
    duration?: number | null
    frequency?: number | null
    ownerId: string
    visibility?: $Enums.Visibility
    isActive?: boolean
    isPublic?: boolean
    overview?: string | null
    principles?: ProtocolCreateprinciplesInput | string[]
    requirements?: ProtocolCreaterequirementsInput | string[]
  }

  export type ProtocolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    principles?: ProtocolUpdateprinciplesInput | string[]
    requirements?: ProtocolUpdaterequirementsInput | string[]
  }

  export type ProtocolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    principles?: ProtocolUpdateprinciplesInput | string[]
    requirements?: ProtocolUpdaterequirementsInput | string[]
  }

  export type BlockCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    order: number
    duration: number
    phase: string
    intensity: string
    volume: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    protocol: ProtocolCreateNestedOneWithoutBlocksInput
    sessions?: BlockSessionCreateNestedManyWithoutBlockInput
    progressions?: BlockProgressionCreateNestedManyWithoutBlockInput
    executions?: BlockExecutionCreateNestedManyWithoutBlockInput
  }

  export type BlockUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    name: string
    description?: string | null
    order: number
    duration: number
    phase: string
    intensity: string
    volume: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    sessions?: BlockSessionUncheckedCreateNestedManyWithoutBlockInput
    progressions?: BlockProgressionUncheckedCreateNestedManyWithoutBlockInput
    executions?: BlockExecutionUncheckedCreateNestedManyWithoutBlockInput
  }

  export type BlockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    intensity?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    protocol?: ProtocolUpdateOneRequiredWithoutBlocksNestedInput
    sessions?: BlockSessionUpdateManyWithoutBlockNestedInput
    progressions?: BlockProgressionUpdateManyWithoutBlockNestedInput
    executions?: BlockExecutionUpdateManyWithoutBlockNestedInput
  }

  export type BlockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    intensity?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    sessions?: BlockSessionUncheckedUpdateManyWithoutBlockNestedInput
    progressions?: BlockProgressionUncheckedUpdateManyWithoutBlockNestedInput
    executions?: BlockExecutionUncheckedUpdateManyWithoutBlockNestedInput
  }

  export type BlockCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    name: string
    description?: string | null
    order: number
    duration: number
    phase: string
    intensity: string
    volume: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BlockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    intensity?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BlockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    intensity?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BlockSessionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    dayOfWeek: number
    order: number
    exercises: JsonNullValueInput | InputJsonValue
    duration?: number | null
    notes?: string | null
    intensity?: number | null
    volume?: number | null
    rpe?: number | null
    block: BlockCreateNestedOneWithoutSessionsInput
  }

  export type BlockSessionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    blockId: string
    name: string
    dayOfWeek: number
    order: number
    exercises: JsonNullValueInput | InputJsonValue
    duration?: number | null
    notes?: string | null
    intensity?: number | null
    volume?: number | null
    rpe?: number | null
  }

  export type BlockSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    exercises?: JsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    intensity?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    block?: BlockUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type BlockSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    exercises?: JsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    intensity?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type BlockSessionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    blockId: string
    name: string
    dayOfWeek: number
    order: number
    exercises: JsonNullValueInput | InputJsonValue
    duration?: number | null
    notes?: string | null
    intensity?: number | null
    volume?: number | null
    rpe?: number | null
  }

  export type BlockSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    exercises?: JsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    intensity?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type BlockSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    exercises?: JsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    intensity?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type BlockProgressionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    week: number
    parameters: JsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    triggers?: NullableJsonNullValueInput | InputJsonValue
    block: BlockCreateNestedOneWithoutProgressionsInput
  }

  export type BlockProgressionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    blockId: string
    week: number
    parameters: JsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    triggers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BlockProgressionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    week?: IntFieldUpdateOperationsInput | number
    parameters?: JsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    triggers?: NullableJsonNullValueInput | InputJsonValue
    block?: BlockUpdateOneRequiredWithoutProgressionsNestedInput
  }

  export type BlockProgressionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockId?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    parameters?: JsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    triggers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BlockProgressionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    blockId: string
    week: number
    parameters: JsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    triggers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BlockProgressionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    week?: IntFieldUpdateOperationsInput | number
    parameters?: JsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    triggers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BlockProgressionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockId?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    parameters?: JsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    triggers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProtocolPermissionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role: $Enums.PermissionRole
    permissions?: ProtocolPermissionCreatepermissionsInput | $Enums.Permission[]
    grantedBy: string
    grantedAt: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
    protocol: ProtocolCreateNestedOneWithoutPermissionsInput
    user: UserCreateNestedOneWithoutPermissionsInput
  }

  export type ProtocolPermissionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    userId: string
    role: $Enums.PermissionRole
    permissions?: ProtocolPermissionCreatepermissionsInput | $Enums.Permission[]
    grantedBy: string
    grantedAt: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type ProtocolPermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumPermissionRoleFieldUpdateOperationsInput | $Enums.PermissionRole
    permissions?: ProtocolPermissionUpdatepermissionsInput | $Enums.Permission[]
    grantedBy?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    protocol?: ProtocolUpdateOneRequiredWithoutPermissionsNestedInput
    user?: UserUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type ProtocolPermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumPermissionRoleFieldUpdateOperationsInput | $Enums.PermissionRole
    permissions?: ProtocolPermissionUpdatepermissionsInput | $Enums.Permission[]
    grantedBy?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProtocolPermissionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    userId: string
    role: $Enums.PermissionRole
    permissions?: ProtocolPermissionCreatepermissionsInput | $Enums.Permission[]
    grantedBy: string
    grantedAt: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type ProtocolPermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumPermissionRoleFieldUpdateOperationsInput | $Enums.PermissionRole
    permissions?: ProtocolPermissionUpdatepermissionsInput | $Enums.Permission[]
    grantedBy?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProtocolPermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumPermissionRoleFieldUpdateOperationsInput | $Enums.PermissionRole
    permissions?: ProtocolPermissionUpdatepermissionsInput | $Enums.Permission[]
    grantedBy?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogCreateInput = {
    id?: string
    createdAt?: Date | string
    action: string
    resourceType: string
    resourceId: string
    userId: string
    tenantId: string
    ip?: string | null
    userAgent?: string | null
    sessionId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    result: string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    action: string
    resourceType: string
    resourceId: string
    userId: string
    tenantId: string
    ip?: string | null
    userAgent?: string | null
    sessionId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    result: string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    result?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    result?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    createdAt?: Date | string
    action: string
    resourceType: string
    resourceId: string
    userId: string
    tenantId: string
    ip?: string | null
    userAgent?: string | null
    sessionId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    result: string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    result?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    result?: StringFieldUpdateOperationsInput | string
  }

  export type ProtocolTemplateCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    parameters: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    usageCount?: number
    protocol: ProtocolCreateNestedOneWithoutTemplatesInput
  }

  export type ProtocolTemplateUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    name: string
    description?: string | null
    parameters: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    usageCount?: number
  }

  export type ProtocolTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    protocol?: ProtocolUpdateOneRequiredWithoutTemplatesNestedInput
  }

  export type ProtocolTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
  }

  export type ProtocolTemplateCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    name: string
    description?: string | null
    parameters: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    usageCount?: number
  }

  export type ProtocolTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
  }

  export type ProtocolTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
  }

  export type ProtocolExecutionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId?: string | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    parameters: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: $Enums.DataClassification
    retentionUntil?: Date | string | null
    currentBlockId?: string | null
    currentWeek?: number
    progress?: number
    tenant: TenantCreateNestedOneWithoutExecutionsInput
    protocol: ProtocolCreateNestedOneWithoutExecutionsInput
    user: UserCreateNestedOneWithoutExecutionsInput
    blockExecutions?: BlockExecutionCreateNestedManyWithoutExecutionInput
    sessions?: SessionExecutionCreateNestedManyWithoutExecutionInput
  }

  export type ProtocolExecutionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId: string
    protocolId: string
    userId: string
    templateId?: string | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    parameters: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: $Enums.DataClassification
    retentionUntil?: Date | string | null
    currentBlockId?: string | null
    currentWeek?: number
    progress?: number
    blockExecutions?: BlockExecutionUncheckedCreateNestedManyWithoutExecutionInput
    sessions?: SessionExecutionUncheckedCreateNestedManyWithoutExecutionInput
  }

  export type ProtocolExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: EnumDataClassificationFieldUpdateOperationsInput | $Enums.DataClassification
    retentionUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    tenant?: TenantUpdateOneRequiredWithoutExecutionsNestedInput
    protocol?: ProtocolUpdateOneRequiredWithoutExecutionsNestedInput
    user?: UserUpdateOneRequiredWithoutExecutionsNestedInput
    blockExecutions?: BlockExecutionUpdateManyWithoutExecutionNestedInput
    sessions?: SessionExecutionUpdateManyWithoutExecutionNestedInput
  }

  export type ProtocolExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    protocolId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: EnumDataClassificationFieldUpdateOperationsInput | $Enums.DataClassification
    retentionUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    blockExecutions?: BlockExecutionUncheckedUpdateManyWithoutExecutionNestedInput
    sessions?: SessionExecutionUncheckedUpdateManyWithoutExecutionNestedInput
  }

  export type ProtocolExecutionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId: string
    protocolId: string
    userId: string
    templateId?: string | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    parameters: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: $Enums.DataClassification
    retentionUntil?: Date | string | null
    currentBlockId?: string | null
    currentWeek?: number
    progress?: number
  }

  export type ProtocolExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: EnumDataClassificationFieldUpdateOperationsInput | $Enums.DataClassification
    retentionUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
  }

  export type ProtocolExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    protocolId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: EnumDataClassificationFieldUpdateOperationsInput | $Enums.DataClassification
    retentionUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
  }

  export type BlockExecutionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    currentWeek?: number
    progress?: number
    execution: ProtocolExecutionCreateNestedOneWithoutBlockExecutionsInput
    block: BlockCreateNestedOneWithoutExecutionsInput
  }

  export type BlockExecutionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executionId: string
    blockId: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    currentWeek?: number
    progress?: number
  }

  export type BlockExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    execution?: ProtocolExecutionUpdateOneRequiredWithoutBlockExecutionsNestedInput
    block?: BlockUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type BlockExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executionId?: StringFieldUpdateOperationsInput | string
    blockId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
  }

  export type BlockExecutionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executionId: string
    blockId: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    currentWeek?: number
    progress?: number
  }

  export type BlockExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
  }

  export type BlockExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executionId?: StringFieldUpdateOperationsInput | string
    blockId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
  }

  export type SessionExecutionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionId: string
    status?: string
    scheduledDate: Date | string
    actualDate?: Date | string | null
    exercises?: NullableJsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    duration?: number | null
    rpe?: number | null
    volume?: number | null
    execution: ProtocolExecutionCreateNestedOneWithoutSessionsInput
  }

  export type SessionExecutionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executionId: string
    sessionId: string
    status?: string
    scheduledDate: Date | string
    actualDate?: Date | string | null
    exercises?: NullableJsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    duration?: number | null
    rpe?: number | null
    volume?: number | null
  }

  export type SessionExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exercises?: NullableJsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    execution?: ProtocolExecutionUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executionId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exercises?: NullableJsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SessionExecutionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executionId: string
    sessionId: string
    status?: string
    scheduledDate: Date | string
    actualDate?: Date | string | null
    exercises?: NullableJsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    duration?: number | null
    rpe?: number | null
    volume?: number | null
  }

  export type SessionExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exercises?: NullableJsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SessionExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executionId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exercises?: NullableJsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ProtocolAnalyticsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    userId?: string | null
    metrics: JsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    periodStart: Date | string
    periodEnd: Date | string
  }

  export type ProtocolAnalyticsUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    userId?: string | null
    metrics: JsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    periodStart: Date | string
    periodEnd: Date | string
  }

  export type ProtocolAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: JsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProtocolAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: JsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProtocolAnalyticsCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    userId?: string | null
    metrics: JsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    periodStart: Date | string
    periodEnd: Date | string
  }

  export type ProtocolAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: JsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProtocolAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: JsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProtocolShareCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: ProtocolShareCreatepermissionsInput | $Enums.Permission[]
    expiresAt?: Date | string | null
    isActive?: boolean
    acceptedAt?: Date | string | null
    protocol: ProtocolCreateNestedOneWithoutSharesInput
    sharedByUser: UserCreateNestedOneWithoutSharedProtocolsInput
    sharedWithUser: UserCreateNestedOneWithoutReceivedProtocolsInput
  }

  export type ProtocolShareUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    sharedBy: string
    sharedWith: string
    permissions?: ProtocolShareCreatepermissionsInput | $Enums.Permission[]
    expiresAt?: Date | string | null
    isActive?: boolean
    acceptedAt?: Date | string | null
  }

  export type ProtocolShareUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: ProtocolShareUpdatepermissionsInput | $Enums.Permission[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    protocol?: ProtocolUpdateOneRequiredWithoutSharesNestedInput
    sharedByUser?: UserUpdateOneRequiredWithoutSharedProtocolsNestedInput
    sharedWithUser?: UserUpdateOneRequiredWithoutReceivedProtocolsNestedInput
  }

  export type ProtocolShareUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    sharedBy?: StringFieldUpdateOperationsInput | string
    sharedWith?: StringFieldUpdateOperationsInput | string
    permissions?: ProtocolShareUpdatepermissionsInput | $Enums.Permission[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProtocolShareCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    sharedBy: string
    sharedWith: string
    permissions?: ProtocolShareCreatepermissionsInput | $Enums.Permission[]
    expiresAt?: Date | string | null
    isActive?: boolean
    acceptedAt?: Date | string | null
  }

  export type ProtocolShareUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: ProtocolShareUpdatepermissionsInput | $Enums.Permission[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProtocolShareUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    sharedBy?: StringFieldUpdateOperationsInput | string
    sharedWith?: StringFieldUpdateOperationsInput | string
    permissions?: ProtocolShareUpdatepermissionsInput | $Enums.Permission[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ProtocolListRelationFilter = {
    every?: ProtocolWhereInput
    some?: ProtocolWhereInput
    none?: ProtocolWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ProtocolExecutionListRelationFilter = {
    every?: ProtocolExecutionWhereInput
    some?: ProtocolExecutionWhereInput
    none?: ProtocolExecutionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProtocolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProtocolExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    isActive?: SortOrder
    settings?: SortOrder
    maxUsers?: SortOrder
    maxProtocols?: SortOrder
  }

  export type TenantAvgOrderByAggregateInput = {
    maxUsers?: SortOrder
    maxProtocols?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    isActive?: SortOrder
    maxUsers?: SortOrder
    maxProtocols?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    isActive?: SortOrder
    maxUsers?: SortOrder
    maxProtocols?: SortOrder
  }

  export type TenantSumOrderByAggregateInput = {
    maxUsers?: SortOrder
    maxProtocols?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TenantRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type ProtocolPermissionListRelationFilter = {
    every?: ProtocolPermissionWhereInput
    some?: ProtocolPermissionWhereInput
    none?: ProtocolPermissionWhereInput
  }

  export type ProtocolShareListRelationFilter = {
    every?: ProtocolShareWhereInput
    some?: ProtocolShareWhereInput
    none?: ProtocolShareWhereInput
  }

  export type ProtocolPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProtocolShareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityFilter<$PrismaModel> | $Enums.Visibility
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BlockListRelationFilter = {
    every?: BlockWhereInput
    some?: BlockWhereInput
    none?: BlockWhereInput
  }

  export type ProtocolTemplateListRelationFilter = {
    every?: ProtocolTemplateWhereInput
    some?: ProtocolTemplateWhereInput
    none?: ProtocolTemplateWhereInput
  }

  export type BlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProtocolTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProtocolCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    version?: SortOrder
    description?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    frequency?: SortOrder
    ownerId?: SortOrder
    visibility?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    overview?: SortOrder
    principles?: SortOrder
    requirements?: SortOrder
  }

  export type ProtocolAvgOrderByAggregateInput = {
    duration?: SortOrder
    frequency?: SortOrder
  }

  export type ProtocolMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    version?: SortOrder
    description?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    frequency?: SortOrder
    ownerId?: SortOrder
    visibility?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    overview?: SortOrder
  }

  export type ProtocolMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    version?: SortOrder
    description?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    frequency?: SortOrder
    ownerId?: SortOrder
    visibility?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    overview?: SortOrder
  }

  export type ProtocolSumOrderByAggregateInput = {
    duration?: SortOrder
    frequency?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.Visibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisibilityFilter<$PrismaModel>
    _max?: NestedEnumVisibilityFilter<$PrismaModel>
  }

  export type ProtocolRelationFilter = {
    is?: ProtocolWhereInput
    isNot?: ProtocolWhereInput
  }

  export type BlockSessionListRelationFilter = {
    every?: BlockSessionWhereInput
    some?: BlockSessionWhereInput
    none?: BlockSessionWhereInput
  }

  export type BlockProgressionListRelationFilter = {
    every?: BlockProgressionWhereInput
    some?: BlockProgressionWhereInput
    none?: BlockProgressionWhereInput
  }

  export type BlockExecutionListRelationFilter = {
    every?: BlockExecutionWhereInput
    some?: BlockExecutionWhereInput
    none?: BlockExecutionWhereInput
  }

  export type BlockSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockProgressionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    duration?: SortOrder
    phase?: SortOrder
    intensity?: SortOrder
    volume?: SortOrder
    parameters?: SortOrder
    rules?: SortOrder
  }

  export type BlockAvgOrderByAggregateInput = {
    order?: SortOrder
    duration?: SortOrder
  }

  export type BlockMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    duration?: SortOrder
    phase?: SortOrder
    intensity?: SortOrder
    volume?: SortOrder
  }

  export type BlockMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    duration?: SortOrder
    phase?: SortOrder
    intensity?: SortOrder
    volume?: SortOrder
  }

  export type BlockSumOrderByAggregateInput = {
    order?: SortOrder
    duration?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BlockRelationFilter = {
    is?: BlockWhereInput
    isNot?: BlockWhereInput
  }

  export type BlockSessionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    blockId?: SortOrder
    name?: SortOrder
    dayOfWeek?: SortOrder
    order?: SortOrder
    exercises?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
    intensity?: SortOrder
    volume?: SortOrder
    rpe?: SortOrder
  }

  export type BlockSessionAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    order?: SortOrder
    duration?: SortOrder
    intensity?: SortOrder
    volume?: SortOrder
    rpe?: SortOrder
  }

  export type BlockSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    blockId?: SortOrder
    name?: SortOrder
    dayOfWeek?: SortOrder
    order?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
    intensity?: SortOrder
    volume?: SortOrder
    rpe?: SortOrder
  }

  export type BlockSessionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    blockId?: SortOrder
    name?: SortOrder
    dayOfWeek?: SortOrder
    order?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
    intensity?: SortOrder
    volume?: SortOrder
    rpe?: SortOrder
  }

  export type BlockSessionSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    order?: SortOrder
    duration?: SortOrder
    intensity?: SortOrder
    volume?: SortOrder
    rpe?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BlockProgressionBlockIdWeekCompoundUniqueInput = {
    blockId: string
    week: number
  }

  export type BlockProgressionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    blockId?: SortOrder
    week?: SortOrder
    parameters?: SortOrder
    rules?: SortOrder
    triggers?: SortOrder
  }

  export type BlockProgressionAvgOrderByAggregateInput = {
    week?: SortOrder
  }

  export type BlockProgressionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    blockId?: SortOrder
    week?: SortOrder
  }

  export type BlockProgressionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    blockId?: SortOrder
    week?: SortOrder
  }

  export type BlockProgressionSumOrderByAggregateInput = {
    week?: SortOrder
  }

  export type EnumPermissionRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionRole | EnumPermissionRoleFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionRole[] | ListEnumPermissionRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.PermissionRole[] | ListEnumPermissionRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionRoleFilter<$PrismaModel> | $Enums.PermissionRole
  }

  export type EnumPermissionNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel> | null
    has?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ProtocolPermissionProtocolIdUserIdCompoundUniqueInput = {
    protocolId: string
    userId: string
  }

  export type ProtocolPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    grantedBy?: SortOrder
    grantedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
  }

  export type ProtocolPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    grantedBy?: SortOrder
    grantedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
  }

  export type ProtocolPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    grantedBy?: SortOrder
    grantedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
  }

  export type EnumPermissionRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionRole | EnumPermissionRoleFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionRole[] | ListEnumPermissionRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.PermissionRole[] | ListEnumPermissionRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionRoleWithAggregatesFilter<$PrismaModel> | $Enums.PermissionRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPermissionRoleFilter<$PrismaModel>
    _max?: NestedEnumPermissionRoleFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    sessionId?: SortOrder
    details?: SortOrder
    result?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    sessionId?: SortOrder
    result?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    sessionId?: SortOrder
    result?: SortOrder
  }

  export type ProtocolTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    parameters?: SortOrder
    isDefault?: SortOrder
    usageCount?: SortOrder
  }

  export type ProtocolTemplateAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type ProtocolTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    usageCount?: SortOrder
  }

  export type ProtocolTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    usageCount?: SortOrder
  }

  export type ProtocolTemplateSumOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type EnumDataClassificationFilter<$PrismaModel = never> = {
    equals?: $Enums.DataClassification | EnumDataClassificationFieldRefInput<$PrismaModel>
    in?: $Enums.DataClassification[] | ListEnumDataClassificationFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataClassification[] | ListEnumDataClassificationFieldRefInput<$PrismaModel>
    not?: NestedEnumDataClassificationFilter<$PrismaModel> | $Enums.DataClassification
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SessionExecutionListRelationFilter = {
    every?: SessionExecutionWhereInput
    some?: SessionExecutionWhereInput
    none?: SessionExecutionWhereInput
  }

  export type SessionExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProtocolExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenantId?: SortOrder
    protocolId?: SortOrder
    userId?: SortOrder
    templateId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    parameters?: SortOrder
    adaptations?: SortOrder
    dataClassification?: SortOrder
    retentionUntil?: SortOrder
    currentBlockId?: SortOrder
    currentWeek?: SortOrder
    progress?: SortOrder
  }

  export type ProtocolExecutionAvgOrderByAggregateInput = {
    currentWeek?: SortOrder
    progress?: SortOrder
  }

  export type ProtocolExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenantId?: SortOrder
    protocolId?: SortOrder
    userId?: SortOrder
    templateId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    dataClassification?: SortOrder
    retentionUntil?: SortOrder
    currentBlockId?: SortOrder
    currentWeek?: SortOrder
    progress?: SortOrder
  }

  export type ProtocolExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenantId?: SortOrder
    protocolId?: SortOrder
    userId?: SortOrder
    templateId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    dataClassification?: SortOrder
    retentionUntil?: SortOrder
    currentBlockId?: SortOrder
    currentWeek?: SortOrder
    progress?: SortOrder
  }

  export type ProtocolExecutionSumOrderByAggregateInput = {
    currentWeek?: SortOrder
    progress?: SortOrder
  }

  export type EnumDataClassificationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataClassification | EnumDataClassificationFieldRefInput<$PrismaModel>
    in?: $Enums.DataClassification[] | ListEnumDataClassificationFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataClassification[] | ListEnumDataClassificationFieldRefInput<$PrismaModel>
    not?: NestedEnumDataClassificationWithAggregatesFilter<$PrismaModel> | $Enums.DataClassification
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataClassificationFilter<$PrismaModel>
    _max?: NestedEnumDataClassificationFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ProtocolExecutionRelationFilter = {
    is?: ProtocolExecutionWhereInput
    isNot?: ProtocolExecutionWhereInput
  }

  export type BlockExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    executionId?: SortOrder
    blockId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    adaptations?: SortOrder
    notes?: SortOrder
    currentWeek?: SortOrder
    progress?: SortOrder
  }

  export type BlockExecutionAvgOrderByAggregateInput = {
    currentWeek?: SortOrder
    progress?: SortOrder
  }

  export type BlockExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    executionId?: SortOrder
    blockId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    notes?: SortOrder
    currentWeek?: SortOrder
    progress?: SortOrder
  }

  export type BlockExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    executionId?: SortOrder
    blockId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    notes?: SortOrder
    currentWeek?: SortOrder
    progress?: SortOrder
  }

  export type BlockExecutionSumOrderByAggregateInput = {
    currentWeek?: SortOrder
    progress?: SortOrder
  }

  export type SessionExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    executionId?: SortOrder
    sessionId?: SortOrder
    status?: SortOrder
    scheduledDate?: SortOrder
    actualDate?: SortOrder
    exercises?: SortOrder
    adaptations?: SortOrder
    notes?: SortOrder
    duration?: SortOrder
    rpe?: SortOrder
    volume?: SortOrder
  }

  export type SessionExecutionAvgOrderByAggregateInput = {
    duration?: SortOrder
    rpe?: SortOrder
    volume?: SortOrder
  }

  export type SessionExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    executionId?: SortOrder
    sessionId?: SortOrder
    status?: SortOrder
    scheduledDate?: SortOrder
    actualDate?: SortOrder
    notes?: SortOrder
    duration?: SortOrder
    rpe?: SortOrder
    volume?: SortOrder
  }

  export type SessionExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    executionId?: SortOrder
    sessionId?: SortOrder
    status?: SortOrder
    scheduledDate?: SortOrder
    actualDate?: SortOrder
    notes?: SortOrder
    duration?: SortOrder
    rpe?: SortOrder
    volume?: SortOrder
  }

  export type SessionExecutionSumOrderByAggregateInput = {
    duration?: SortOrder
    rpe?: SortOrder
    volume?: SortOrder
  }

  export type ProtocolAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    userId?: SortOrder
    metrics?: SortOrder
    insights?: SortOrder
    recommendations?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
  }

  export type ProtocolAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    userId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
  }

  export type ProtocolAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    userId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
  }

  export type ProtocolShareProtocolIdSharedWithCompoundUniqueInput = {
    protocolId: string
    sharedWith: string
  }

  export type ProtocolShareCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    sharedBy?: SortOrder
    sharedWith?: SortOrder
    permissions?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    acceptedAt?: SortOrder
  }

  export type ProtocolShareMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    sharedBy?: SortOrder
    sharedWith?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    acceptedAt?: SortOrder
  }

  export type ProtocolShareMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocolId?: SortOrder
    sharedBy?: SortOrder
    sharedWith?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    acceptedAt?: SortOrder
  }

  export type ProtocolCreateNestedManyWithoutTenantInput = {
    create?: XOR<ProtocolCreateWithoutTenantInput, ProtocolUncheckedCreateWithoutTenantInput> | ProtocolCreateWithoutTenantInput[] | ProtocolUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProtocolCreateOrConnectWithoutTenantInput | ProtocolCreateOrConnectWithoutTenantInput[]
    createMany?: ProtocolCreateManyTenantInputEnvelope
    connect?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ProtocolExecutionCreateNestedManyWithoutTenantInput = {
    create?: XOR<ProtocolExecutionCreateWithoutTenantInput, ProtocolExecutionUncheckedCreateWithoutTenantInput> | ProtocolExecutionCreateWithoutTenantInput[] | ProtocolExecutionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProtocolExecutionCreateOrConnectWithoutTenantInput | ProtocolExecutionCreateOrConnectWithoutTenantInput[]
    createMany?: ProtocolExecutionCreateManyTenantInputEnvelope
    connect?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
  }

  export type ProtocolUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ProtocolCreateWithoutTenantInput, ProtocolUncheckedCreateWithoutTenantInput> | ProtocolCreateWithoutTenantInput[] | ProtocolUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProtocolCreateOrConnectWithoutTenantInput | ProtocolCreateOrConnectWithoutTenantInput[]
    createMany?: ProtocolCreateManyTenantInputEnvelope
    connect?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ProtocolExecutionUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ProtocolExecutionCreateWithoutTenantInput, ProtocolExecutionUncheckedCreateWithoutTenantInput> | ProtocolExecutionCreateWithoutTenantInput[] | ProtocolExecutionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProtocolExecutionCreateOrConnectWithoutTenantInput | ProtocolExecutionCreateOrConnectWithoutTenantInput[]
    createMany?: ProtocolExecutionCreateManyTenantInputEnvelope
    connect?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProtocolUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ProtocolCreateWithoutTenantInput, ProtocolUncheckedCreateWithoutTenantInput> | ProtocolCreateWithoutTenantInput[] | ProtocolUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProtocolCreateOrConnectWithoutTenantInput | ProtocolCreateOrConnectWithoutTenantInput[]
    upsert?: ProtocolUpsertWithWhereUniqueWithoutTenantInput | ProtocolUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ProtocolCreateManyTenantInputEnvelope
    set?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    disconnect?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    delete?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    connect?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    update?: ProtocolUpdateWithWhereUniqueWithoutTenantInput | ProtocolUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ProtocolUpdateManyWithWhereWithoutTenantInput | ProtocolUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ProtocolScalarWhereInput | ProtocolScalarWhereInput[]
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ProtocolExecutionUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ProtocolExecutionCreateWithoutTenantInput, ProtocolExecutionUncheckedCreateWithoutTenantInput> | ProtocolExecutionCreateWithoutTenantInput[] | ProtocolExecutionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProtocolExecutionCreateOrConnectWithoutTenantInput | ProtocolExecutionCreateOrConnectWithoutTenantInput[]
    upsert?: ProtocolExecutionUpsertWithWhereUniqueWithoutTenantInput | ProtocolExecutionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ProtocolExecutionCreateManyTenantInputEnvelope
    set?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    disconnect?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    delete?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    connect?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    update?: ProtocolExecutionUpdateWithWhereUniqueWithoutTenantInput | ProtocolExecutionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ProtocolExecutionUpdateManyWithWhereWithoutTenantInput | ProtocolExecutionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ProtocolExecutionScalarWhereInput | ProtocolExecutionScalarWhereInput[]
  }

  export type ProtocolUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ProtocolCreateWithoutTenantInput, ProtocolUncheckedCreateWithoutTenantInput> | ProtocolCreateWithoutTenantInput[] | ProtocolUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProtocolCreateOrConnectWithoutTenantInput | ProtocolCreateOrConnectWithoutTenantInput[]
    upsert?: ProtocolUpsertWithWhereUniqueWithoutTenantInput | ProtocolUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ProtocolCreateManyTenantInputEnvelope
    set?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    disconnect?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    delete?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    connect?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    update?: ProtocolUpdateWithWhereUniqueWithoutTenantInput | ProtocolUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ProtocolUpdateManyWithWhereWithoutTenantInput | ProtocolUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ProtocolScalarWhereInput | ProtocolScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ProtocolExecutionUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ProtocolExecutionCreateWithoutTenantInput, ProtocolExecutionUncheckedCreateWithoutTenantInput> | ProtocolExecutionCreateWithoutTenantInput[] | ProtocolExecutionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProtocolExecutionCreateOrConnectWithoutTenantInput | ProtocolExecutionCreateOrConnectWithoutTenantInput[]
    upsert?: ProtocolExecutionUpsertWithWhereUniqueWithoutTenantInput | ProtocolExecutionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ProtocolExecutionCreateManyTenantInputEnvelope
    set?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    disconnect?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    delete?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    connect?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    update?: ProtocolExecutionUpdateWithWhereUniqueWithoutTenantInput | ProtocolExecutionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ProtocolExecutionUpdateManyWithWhereWithoutTenantInput | ProtocolExecutionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ProtocolExecutionScalarWhereInput | ProtocolExecutionScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type ProtocolCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ProtocolCreateWithoutOwnerInput, ProtocolUncheckedCreateWithoutOwnerInput> | ProtocolCreateWithoutOwnerInput[] | ProtocolUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProtocolCreateOrConnectWithoutOwnerInput | ProtocolCreateOrConnectWithoutOwnerInput[]
    createMany?: ProtocolCreateManyOwnerInputEnvelope
    connect?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
  }

  export type ProtocolExecutionCreateNestedManyWithoutUserInput = {
    create?: XOR<ProtocolExecutionCreateWithoutUserInput, ProtocolExecutionUncheckedCreateWithoutUserInput> | ProtocolExecutionCreateWithoutUserInput[] | ProtocolExecutionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProtocolExecutionCreateOrConnectWithoutUserInput | ProtocolExecutionCreateOrConnectWithoutUserInput[]
    createMany?: ProtocolExecutionCreateManyUserInputEnvelope
    connect?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
  }

  export type ProtocolPermissionCreateNestedManyWithoutUserInput = {
    create?: XOR<ProtocolPermissionCreateWithoutUserInput, ProtocolPermissionUncheckedCreateWithoutUserInput> | ProtocolPermissionCreateWithoutUserInput[] | ProtocolPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProtocolPermissionCreateOrConnectWithoutUserInput | ProtocolPermissionCreateOrConnectWithoutUserInput[]
    createMany?: ProtocolPermissionCreateManyUserInputEnvelope
    connect?: ProtocolPermissionWhereUniqueInput | ProtocolPermissionWhereUniqueInput[]
  }

  export type ProtocolShareCreateNestedManyWithoutSharedByUserInput = {
    create?: XOR<ProtocolShareCreateWithoutSharedByUserInput, ProtocolShareUncheckedCreateWithoutSharedByUserInput> | ProtocolShareCreateWithoutSharedByUserInput[] | ProtocolShareUncheckedCreateWithoutSharedByUserInput[]
    connectOrCreate?: ProtocolShareCreateOrConnectWithoutSharedByUserInput | ProtocolShareCreateOrConnectWithoutSharedByUserInput[]
    createMany?: ProtocolShareCreateManySharedByUserInputEnvelope
    connect?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
  }

  export type ProtocolShareCreateNestedManyWithoutSharedWithUserInput = {
    create?: XOR<ProtocolShareCreateWithoutSharedWithUserInput, ProtocolShareUncheckedCreateWithoutSharedWithUserInput> | ProtocolShareCreateWithoutSharedWithUserInput[] | ProtocolShareUncheckedCreateWithoutSharedWithUserInput[]
    connectOrCreate?: ProtocolShareCreateOrConnectWithoutSharedWithUserInput | ProtocolShareCreateOrConnectWithoutSharedWithUserInput[]
    createMany?: ProtocolShareCreateManySharedWithUserInputEnvelope
    connect?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
  }

  export type ProtocolUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ProtocolCreateWithoutOwnerInput, ProtocolUncheckedCreateWithoutOwnerInput> | ProtocolCreateWithoutOwnerInput[] | ProtocolUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProtocolCreateOrConnectWithoutOwnerInput | ProtocolCreateOrConnectWithoutOwnerInput[]
    createMany?: ProtocolCreateManyOwnerInputEnvelope
    connect?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
  }

  export type ProtocolExecutionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProtocolExecutionCreateWithoutUserInput, ProtocolExecutionUncheckedCreateWithoutUserInput> | ProtocolExecutionCreateWithoutUserInput[] | ProtocolExecutionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProtocolExecutionCreateOrConnectWithoutUserInput | ProtocolExecutionCreateOrConnectWithoutUserInput[]
    createMany?: ProtocolExecutionCreateManyUserInputEnvelope
    connect?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
  }

  export type ProtocolPermissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProtocolPermissionCreateWithoutUserInput, ProtocolPermissionUncheckedCreateWithoutUserInput> | ProtocolPermissionCreateWithoutUserInput[] | ProtocolPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProtocolPermissionCreateOrConnectWithoutUserInput | ProtocolPermissionCreateOrConnectWithoutUserInput[]
    createMany?: ProtocolPermissionCreateManyUserInputEnvelope
    connect?: ProtocolPermissionWhereUniqueInput | ProtocolPermissionWhereUniqueInput[]
  }

  export type ProtocolShareUncheckedCreateNestedManyWithoutSharedByUserInput = {
    create?: XOR<ProtocolShareCreateWithoutSharedByUserInput, ProtocolShareUncheckedCreateWithoutSharedByUserInput> | ProtocolShareCreateWithoutSharedByUserInput[] | ProtocolShareUncheckedCreateWithoutSharedByUserInput[]
    connectOrCreate?: ProtocolShareCreateOrConnectWithoutSharedByUserInput | ProtocolShareCreateOrConnectWithoutSharedByUserInput[]
    createMany?: ProtocolShareCreateManySharedByUserInputEnvelope
    connect?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
  }

  export type ProtocolShareUncheckedCreateNestedManyWithoutSharedWithUserInput = {
    create?: XOR<ProtocolShareCreateWithoutSharedWithUserInput, ProtocolShareUncheckedCreateWithoutSharedWithUserInput> | ProtocolShareCreateWithoutSharedWithUserInput[] | ProtocolShareUncheckedCreateWithoutSharedWithUserInput[]
    connectOrCreate?: ProtocolShareCreateOrConnectWithoutSharedWithUserInput | ProtocolShareCreateOrConnectWithoutSharedWithUserInput[]
    createMany?: ProtocolShareCreateManySharedWithUserInputEnvelope
    connect?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TenantUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type ProtocolUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ProtocolCreateWithoutOwnerInput, ProtocolUncheckedCreateWithoutOwnerInput> | ProtocolCreateWithoutOwnerInput[] | ProtocolUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProtocolCreateOrConnectWithoutOwnerInput | ProtocolCreateOrConnectWithoutOwnerInput[]
    upsert?: ProtocolUpsertWithWhereUniqueWithoutOwnerInput | ProtocolUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ProtocolCreateManyOwnerInputEnvelope
    set?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    disconnect?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    delete?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    connect?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    update?: ProtocolUpdateWithWhereUniqueWithoutOwnerInput | ProtocolUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ProtocolUpdateManyWithWhereWithoutOwnerInput | ProtocolUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ProtocolScalarWhereInput | ProtocolScalarWhereInput[]
  }

  export type ProtocolExecutionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProtocolExecutionCreateWithoutUserInput, ProtocolExecutionUncheckedCreateWithoutUserInput> | ProtocolExecutionCreateWithoutUserInput[] | ProtocolExecutionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProtocolExecutionCreateOrConnectWithoutUserInput | ProtocolExecutionCreateOrConnectWithoutUserInput[]
    upsert?: ProtocolExecutionUpsertWithWhereUniqueWithoutUserInput | ProtocolExecutionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProtocolExecutionCreateManyUserInputEnvelope
    set?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    disconnect?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    delete?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    connect?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    update?: ProtocolExecutionUpdateWithWhereUniqueWithoutUserInput | ProtocolExecutionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProtocolExecutionUpdateManyWithWhereWithoutUserInput | ProtocolExecutionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProtocolExecutionScalarWhereInput | ProtocolExecutionScalarWhereInput[]
  }

  export type ProtocolPermissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProtocolPermissionCreateWithoutUserInput, ProtocolPermissionUncheckedCreateWithoutUserInput> | ProtocolPermissionCreateWithoutUserInput[] | ProtocolPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProtocolPermissionCreateOrConnectWithoutUserInput | ProtocolPermissionCreateOrConnectWithoutUserInput[]
    upsert?: ProtocolPermissionUpsertWithWhereUniqueWithoutUserInput | ProtocolPermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProtocolPermissionCreateManyUserInputEnvelope
    set?: ProtocolPermissionWhereUniqueInput | ProtocolPermissionWhereUniqueInput[]
    disconnect?: ProtocolPermissionWhereUniqueInput | ProtocolPermissionWhereUniqueInput[]
    delete?: ProtocolPermissionWhereUniqueInput | ProtocolPermissionWhereUniqueInput[]
    connect?: ProtocolPermissionWhereUniqueInput | ProtocolPermissionWhereUniqueInput[]
    update?: ProtocolPermissionUpdateWithWhereUniqueWithoutUserInput | ProtocolPermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProtocolPermissionUpdateManyWithWhereWithoutUserInput | ProtocolPermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProtocolPermissionScalarWhereInput | ProtocolPermissionScalarWhereInput[]
  }

  export type ProtocolShareUpdateManyWithoutSharedByUserNestedInput = {
    create?: XOR<ProtocolShareCreateWithoutSharedByUserInput, ProtocolShareUncheckedCreateWithoutSharedByUserInput> | ProtocolShareCreateWithoutSharedByUserInput[] | ProtocolShareUncheckedCreateWithoutSharedByUserInput[]
    connectOrCreate?: ProtocolShareCreateOrConnectWithoutSharedByUserInput | ProtocolShareCreateOrConnectWithoutSharedByUserInput[]
    upsert?: ProtocolShareUpsertWithWhereUniqueWithoutSharedByUserInput | ProtocolShareUpsertWithWhereUniqueWithoutSharedByUserInput[]
    createMany?: ProtocolShareCreateManySharedByUserInputEnvelope
    set?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    disconnect?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    delete?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    connect?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    update?: ProtocolShareUpdateWithWhereUniqueWithoutSharedByUserInput | ProtocolShareUpdateWithWhereUniqueWithoutSharedByUserInput[]
    updateMany?: ProtocolShareUpdateManyWithWhereWithoutSharedByUserInput | ProtocolShareUpdateManyWithWhereWithoutSharedByUserInput[]
    deleteMany?: ProtocolShareScalarWhereInput | ProtocolShareScalarWhereInput[]
  }

  export type ProtocolShareUpdateManyWithoutSharedWithUserNestedInput = {
    create?: XOR<ProtocolShareCreateWithoutSharedWithUserInput, ProtocolShareUncheckedCreateWithoutSharedWithUserInput> | ProtocolShareCreateWithoutSharedWithUserInput[] | ProtocolShareUncheckedCreateWithoutSharedWithUserInput[]
    connectOrCreate?: ProtocolShareCreateOrConnectWithoutSharedWithUserInput | ProtocolShareCreateOrConnectWithoutSharedWithUserInput[]
    upsert?: ProtocolShareUpsertWithWhereUniqueWithoutSharedWithUserInput | ProtocolShareUpsertWithWhereUniqueWithoutSharedWithUserInput[]
    createMany?: ProtocolShareCreateManySharedWithUserInputEnvelope
    set?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    disconnect?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    delete?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    connect?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    update?: ProtocolShareUpdateWithWhereUniqueWithoutSharedWithUserInput | ProtocolShareUpdateWithWhereUniqueWithoutSharedWithUserInput[]
    updateMany?: ProtocolShareUpdateManyWithWhereWithoutSharedWithUserInput | ProtocolShareUpdateManyWithWhereWithoutSharedWithUserInput[]
    deleteMany?: ProtocolShareScalarWhereInput | ProtocolShareScalarWhereInput[]
  }

  export type ProtocolUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ProtocolCreateWithoutOwnerInput, ProtocolUncheckedCreateWithoutOwnerInput> | ProtocolCreateWithoutOwnerInput[] | ProtocolUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProtocolCreateOrConnectWithoutOwnerInput | ProtocolCreateOrConnectWithoutOwnerInput[]
    upsert?: ProtocolUpsertWithWhereUniqueWithoutOwnerInput | ProtocolUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ProtocolCreateManyOwnerInputEnvelope
    set?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    disconnect?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    delete?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    connect?: ProtocolWhereUniqueInput | ProtocolWhereUniqueInput[]
    update?: ProtocolUpdateWithWhereUniqueWithoutOwnerInput | ProtocolUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ProtocolUpdateManyWithWhereWithoutOwnerInput | ProtocolUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ProtocolScalarWhereInput | ProtocolScalarWhereInput[]
  }

  export type ProtocolExecutionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProtocolExecutionCreateWithoutUserInput, ProtocolExecutionUncheckedCreateWithoutUserInput> | ProtocolExecutionCreateWithoutUserInput[] | ProtocolExecutionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProtocolExecutionCreateOrConnectWithoutUserInput | ProtocolExecutionCreateOrConnectWithoutUserInput[]
    upsert?: ProtocolExecutionUpsertWithWhereUniqueWithoutUserInput | ProtocolExecutionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProtocolExecutionCreateManyUserInputEnvelope
    set?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    disconnect?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    delete?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    connect?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    update?: ProtocolExecutionUpdateWithWhereUniqueWithoutUserInput | ProtocolExecutionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProtocolExecutionUpdateManyWithWhereWithoutUserInput | ProtocolExecutionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProtocolExecutionScalarWhereInput | ProtocolExecutionScalarWhereInput[]
  }

  export type ProtocolPermissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProtocolPermissionCreateWithoutUserInput, ProtocolPermissionUncheckedCreateWithoutUserInput> | ProtocolPermissionCreateWithoutUserInput[] | ProtocolPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProtocolPermissionCreateOrConnectWithoutUserInput | ProtocolPermissionCreateOrConnectWithoutUserInput[]
    upsert?: ProtocolPermissionUpsertWithWhereUniqueWithoutUserInput | ProtocolPermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProtocolPermissionCreateManyUserInputEnvelope
    set?: ProtocolPermissionWhereUniqueInput | ProtocolPermissionWhereUniqueInput[]
    disconnect?: ProtocolPermissionWhereUniqueInput | ProtocolPermissionWhereUniqueInput[]
    delete?: ProtocolPermissionWhereUniqueInput | ProtocolPermissionWhereUniqueInput[]
    connect?: ProtocolPermissionWhereUniqueInput | ProtocolPermissionWhereUniqueInput[]
    update?: ProtocolPermissionUpdateWithWhereUniqueWithoutUserInput | ProtocolPermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProtocolPermissionUpdateManyWithWhereWithoutUserInput | ProtocolPermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProtocolPermissionScalarWhereInput | ProtocolPermissionScalarWhereInput[]
  }

  export type ProtocolShareUncheckedUpdateManyWithoutSharedByUserNestedInput = {
    create?: XOR<ProtocolShareCreateWithoutSharedByUserInput, ProtocolShareUncheckedCreateWithoutSharedByUserInput> | ProtocolShareCreateWithoutSharedByUserInput[] | ProtocolShareUncheckedCreateWithoutSharedByUserInput[]
    connectOrCreate?: ProtocolShareCreateOrConnectWithoutSharedByUserInput | ProtocolShareCreateOrConnectWithoutSharedByUserInput[]
    upsert?: ProtocolShareUpsertWithWhereUniqueWithoutSharedByUserInput | ProtocolShareUpsertWithWhereUniqueWithoutSharedByUserInput[]
    createMany?: ProtocolShareCreateManySharedByUserInputEnvelope
    set?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    disconnect?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    delete?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    connect?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    update?: ProtocolShareUpdateWithWhereUniqueWithoutSharedByUserInput | ProtocolShareUpdateWithWhereUniqueWithoutSharedByUserInput[]
    updateMany?: ProtocolShareUpdateManyWithWhereWithoutSharedByUserInput | ProtocolShareUpdateManyWithWhereWithoutSharedByUserInput[]
    deleteMany?: ProtocolShareScalarWhereInput | ProtocolShareScalarWhereInput[]
  }

  export type ProtocolShareUncheckedUpdateManyWithoutSharedWithUserNestedInput = {
    create?: XOR<ProtocolShareCreateWithoutSharedWithUserInput, ProtocolShareUncheckedCreateWithoutSharedWithUserInput> | ProtocolShareCreateWithoutSharedWithUserInput[] | ProtocolShareUncheckedCreateWithoutSharedWithUserInput[]
    connectOrCreate?: ProtocolShareCreateOrConnectWithoutSharedWithUserInput | ProtocolShareCreateOrConnectWithoutSharedWithUserInput[]
    upsert?: ProtocolShareUpsertWithWhereUniqueWithoutSharedWithUserInput | ProtocolShareUpsertWithWhereUniqueWithoutSharedWithUserInput[]
    createMany?: ProtocolShareCreateManySharedWithUserInputEnvelope
    set?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    disconnect?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    delete?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    connect?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    update?: ProtocolShareUpdateWithWhereUniqueWithoutSharedWithUserInput | ProtocolShareUpdateWithWhereUniqueWithoutSharedWithUserInput[]
    updateMany?: ProtocolShareUpdateManyWithWhereWithoutSharedWithUserInput | ProtocolShareUpdateManyWithWhereWithoutSharedWithUserInput[]
    deleteMany?: ProtocolShareScalarWhereInput | ProtocolShareScalarWhereInput[]
  }

  export type ProtocolCreateprinciplesInput = {
    set: string[]
  }

  export type ProtocolCreaterequirementsInput = {
    set: string[]
  }

  export type TenantCreateNestedOneWithoutProtocolsInput = {
    create?: XOR<TenantCreateWithoutProtocolsInput, TenantUncheckedCreateWithoutProtocolsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutProtocolsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProtocolsInput = {
    create?: XOR<UserCreateWithoutProtocolsInput, UserUncheckedCreateWithoutProtocolsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProtocolsInput
    connect?: UserWhereUniqueInput
  }

  export type BlockCreateNestedManyWithoutProtocolInput = {
    create?: XOR<BlockCreateWithoutProtocolInput, BlockUncheckedCreateWithoutProtocolInput> | BlockCreateWithoutProtocolInput[] | BlockUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutProtocolInput | BlockCreateOrConnectWithoutProtocolInput[]
    createMany?: BlockCreateManyProtocolInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type ProtocolTemplateCreateNestedManyWithoutProtocolInput = {
    create?: XOR<ProtocolTemplateCreateWithoutProtocolInput, ProtocolTemplateUncheckedCreateWithoutProtocolInput> | ProtocolTemplateCreateWithoutProtocolInput[] | ProtocolTemplateUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: ProtocolTemplateCreateOrConnectWithoutProtocolInput | ProtocolTemplateCreateOrConnectWithoutProtocolInput[]
    createMany?: ProtocolTemplateCreateManyProtocolInputEnvelope
    connect?: ProtocolTemplateWhereUniqueInput | ProtocolTemplateWhereUniqueInput[]
  }

  export type ProtocolExecutionCreateNestedManyWithoutProtocolInput = {
    create?: XOR<ProtocolExecutionCreateWithoutProtocolInput, ProtocolExecutionUncheckedCreateWithoutProtocolInput> | ProtocolExecutionCreateWithoutProtocolInput[] | ProtocolExecutionUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: ProtocolExecutionCreateOrConnectWithoutProtocolInput | ProtocolExecutionCreateOrConnectWithoutProtocolInput[]
    createMany?: ProtocolExecutionCreateManyProtocolInputEnvelope
    connect?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
  }

  export type ProtocolPermissionCreateNestedManyWithoutProtocolInput = {
    create?: XOR<ProtocolPermissionCreateWithoutProtocolInput, ProtocolPermissionUncheckedCreateWithoutProtocolInput> | ProtocolPermissionCreateWithoutProtocolInput[] | ProtocolPermissionUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: ProtocolPermissionCreateOrConnectWithoutProtocolInput | ProtocolPermissionCreateOrConnectWithoutProtocolInput[]
    createMany?: ProtocolPermissionCreateManyProtocolInputEnvelope
    connect?: ProtocolPermissionWhereUniqueInput | ProtocolPermissionWhereUniqueInput[]
  }

  export type ProtocolShareCreateNestedManyWithoutProtocolInput = {
    create?: XOR<ProtocolShareCreateWithoutProtocolInput, ProtocolShareUncheckedCreateWithoutProtocolInput> | ProtocolShareCreateWithoutProtocolInput[] | ProtocolShareUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: ProtocolShareCreateOrConnectWithoutProtocolInput | ProtocolShareCreateOrConnectWithoutProtocolInput[]
    createMany?: ProtocolShareCreateManyProtocolInputEnvelope
    connect?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
  }

  export type BlockUncheckedCreateNestedManyWithoutProtocolInput = {
    create?: XOR<BlockCreateWithoutProtocolInput, BlockUncheckedCreateWithoutProtocolInput> | BlockCreateWithoutProtocolInput[] | BlockUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutProtocolInput | BlockCreateOrConnectWithoutProtocolInput[]
    createMany?: BlockCreateManyProtocolInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type ProtocolTemplateUncheckedCreateNestedManyWithoutProtocolInput = {
    create?: XOR<ProtocolTemplateCreateWithoutProtocolInput, ProtocolTemplateUncheckedCreateWithoutProtocolInput> | ProtocolTemplateCreateWithoutProtocolInput[] | ProtocolTemplateUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: ProtocolTemplateCreateOrConnectWithoutProtocolInput | ProtocolTemplateCreateOrConnectWithoutProtocolInput[]
    createMany?: ProtocolTemplateCreateManyProtocolInputEnvelope
    connect?: ProtocolTemplateWhereUniqueInput | ProtocolTemplateWhereUniqueInput[]
  }

  export type ProtocolExecutionUncheckedCreateNestedManyWithoutProtocolInput = {
    create?: XOR<ProtocolExecutionCreateWithoutProtocolInput, ProtocolExecutionUncheckedCreateWithoutProtocolInput> | ProtocolExecutionCreateWithoutProtocolInput[] | ProtocolExecutionUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: ProtocolExecutionCreateOrConnectWithoutProtocolInput | ProtocolExecutionCreateOrConnectWithoutProtocolInput[]
    createMany?: ProtocolExecutionCreateManyProtocolInputEnvelope
    connect?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
  }

  export type ProtocolPermissionUncheckedCreateNestedManyWithoutProtocolInput = {
    create?: XOR<ProtocolPermissionCreateWithoutProtocolInput, ProtocolPermissionUncheckedCreateWithoutProtocolInput> | ProtocolPermissionCreateWithoutProtocolInput[] | ProtocolPermissionUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: ProtocolPermissionCreateOrConnectWithoutProtocolInput | ProtocolPermissionCreateOrConnectWithoutProtocolInput[]
    createMany?: ProtocolPermissionCreateManyProtocolInputEnvelope
    connect?: ProtocolPermissionWhereUniqueInput | ProtocolPermissionWhereUniqueInput[]
  }

  export type ProtocolShareUncheckedCreateNestedManyWithoutProtocolInput = {
    create?: XOR<ProtocolShareCreateWithoutProtocolInput, ProtocolShareUncheckedCreateWithoutProtocolInput> | ProtocolShareCreateWithoutProtocolInput[] | ProtocolShareUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: ProtocolShareCreateOrConnectWithoutProtocolInput | ProtocolShareCreateOrConnectWithoutProtocolInput[]
    createMany?: ProtocolShareCreateManyProtocolInputEnvelope
    connect?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.Visibility
  }

  export type ProtocolUpdateprinciplesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProtocolUpdaterequirementsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TenantUpdateOneRequiredWithoutProtocolsNestedInput = {
    create?: XOR<TenantCreateWithoutProtocolsInput, TenantUncheckedCreateWithoutProtocolsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutProtocolsInput
    upsert?: TenantUpsertWithoutProtocolsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutProtocolsInput, TenantUpdateWithoutProtocolsInput>, TenantUncheckedUpdateWithoutProtocolsInput>
  }

  export type UserUpdateOneRequiredWithoutProtocolsNestedInput = {
    create?: XOR<UserCreateWithoutProtocolsInput, UserUncheckedCreateWithoutProtocolsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProtocolsInput
    upsert?: UserUpsertWithoutProtocolsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProtocolsInput, UserUpdateWithoutProtocolsInput>, UserUncheckedUpdateWithoutProtocolsInput>
  }

  export type BlockUpdateManyWithoutProtocolNestedInput = {
    create?: XOR<BlockCreateWithoutProtocolInput, BlockUncheckedCreateWithoutProtocolInput> | BlockCreateWithoutProtocolInput[] | BlockUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutProtocolInput | BlockCreateOrConnectWithoutProtocolInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutProtocolInput | BlockUpsertWithWhereUniqueWithoutProtocolInput[]
    createMany?: BlockCreateManyProtocolInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutProtocolInput | BlockUpdateWithWhereUniqueWithoutProtocolInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutProtocolInput | BlockUpdateManyWithWhereWithoutProtocolInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type ProtocolTemplateUpdateManyWithoutProtocolNestedInput = {
    create?: XOR<ProtocolTemplateCreateWithoutProtocolInput, ProtocolTemplateUncheckedCreateWithoutProtocolInput> | ProtocolTemplateCreateWithoutProtocolInput[] | ProtocolTemplateUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: ProtocolTemplateCreateOrConnectWithoutProtocolInput | ProtocolTemplateCreateOrConnectWithoutProtocolInput[]
    upsert?: ProtocolTemplateUpsertWithWhereUniqueWithoutProtocolInput | ProtocolTemplateUpsertWithWhereUniqueWithoutProtocolInput[]
    createMany?: ProtocolTemplateCreateManyProtocolInputEnvelope
    set?: ProtocolTemplateWhereUniqueInput | ProtocolTemplateWhereUniqueInput[]
    disconnect?: ProtocolTemplateWhereUniqueInput | ProtocolTemplateWhereUniqueInput[]
    delete?: ProtocolTemplateWhereUniqueInput | ProtocolTemplateWhereUniqueInput[]
    connect?: ProtocolTemplateWhereUniqueInput | ProtocolTemplateWhereUniqueInput[]
    update?: ProtocolTemplateUpdateWithWhereUniqueWithoutProtocolInput | ProtocolTemplateUpdateWithWhereUniqueWithoutProtocolInput[]
    updateMany?: ProtocolTemplateUpdateManyWithWhereWithoutProtocolInput | ProtocolTemplateUpdateManyWithWhereWithoutProtocolInput[]
    deleteMany?: ProtocolTemplateScalarWhereInput | ProtocolTemplateScalarWhereInput[]
  }

  export type ProtocolExecutionUpdateManyWithoutProtocolNestedInput = {
    create?: XOR<ProtocolExecutionCreateWithoutProtocolInput, ProtocolExecutionUncheckedCreateWithoutProtocolInput> | ProtocolExecutionCreateWithoutProtocolInput[] | ProtocolExecutionUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: ProtocolExecutionCreateOrConnectWithoutProtocolInput | ProtocolExecutionCreateOrConnectWithoutProtocolInput[]
    upsert?: ProtocolExecutionUpsertWithWhereUniqueWithoutProtocolInput | ProtocolExecutionUpsertWithWhereUniqueWithoutProtocolInput[]
    createMany?: ProtocolExecutionCreateManyProtocolInputEnvelope
    set?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    disconnect?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    delete?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    connect?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    update?: ProtocolExecutionUpdateWithWhereUniqueWithoutProtocolInput | ProtocolExecutionUpdateWithWhereUniqueWithoutProtocolInput[]
    updateMany?: ProtocolExecutionUpdateManyWithWhereWithoutProtocolInput | ProtocolExecutionUpdateManyWithWhereWithoutProtocolInput[]
    deleteMany?: ProtocolExecutionScalarWhereInput | ProtocolExecutionScalarWhereInput[]
  }

  export type ProtocolPermissionUpdateManyWithoutProtocolNestedInput = {
    create?: XOR<ProtocolPermissionCreateWithoutProtocolInput, ProtocolPermissionUncheckedCreateWithoutProtocolInput> | ProtocolPermissionCreateWithoutProtocolInput[] | ProtocolPermissionUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: ProtocolPermissionCreateOrConnectWithoutProtocolInput | ProtocolPermissionCreateOrConnectWithoutProtocolInput[]
    upsert?: ProtocolPermissionUpsertWithWhereUniqueWithoutProtocolInput | ProtocolPermissionUpsertWithWhereUniqueWithoutProtocolInput[]
    createMany?: ProtocolPermissionCreateManyProtocolInputEnvelope
    set?: ProtocolPermissionWhereUniqueInput | ProtocolPermissionWhereUniqueInput[]
    disconnect?: ProtocolPermissionWhereUniqueInput | ProtocolPermissionWhereUniqueInput[]
    delete?: ProtocolPermissionWhereUniqueInput | ProtocolPermissionWhereUniqueInput[]
    connect?: ProtocolPermissionWhereUniqueInput | ProtocolPermissionWhereUniqueInput[]
    update?: ProtocolPermissionUpdateWithWhereUniqueWithoutProtocolInput | ProtocolPermissionUpdateWithWhereUniqueWithoutProtocolInput[]
    updateMany?: ProtocolPermissionUpdateManyWithWhereWithoutProtocolInput | ProtocolPermissionUpdateManyWithWhereWithoutProtocolInput[]
    deleteMany?: ProtocolPermissionScalarWhereInput | ProtocolPermissionScalarWhereInput[]
  }

  export type ProtocolShareUpdateManyWithoutProtocolNestedInput = {
    create?: XOR<ProtocolShareCreateWithoutProtocolInput, ProtocolShareUncheckedCreateWithoutProtocolInput> | ProtocolShareCreateWithoutProtocolInput[] | ProtocolShareUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: ProtocolShareCreateOrConnectWithoutProtocolInput | ProtocolShareCreateOrConnectWithoutProtocolInput[]
    upsert?: ProtocolShareUpsertWithWhereUniqueWithoutProtocolInput | ProtocolShareUpsertWithWhereUniqueWithoutProtocolInput[]
    createMany?: ProtocolShareCreateManyProtocolInputEnvelope
    set?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    disconnect?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    delete?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    connect?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    update?: ProtocolShareUpdateWithWhereUniqueWithoutProtocolInput | ProtocolShareUpdateWithWhereUniqueWithoutProtocolInput[]
    updateMany?: ProtocolShareUpdateManyWithWhereWithoutProtocolInput | ProtocolShareUpdateManyWithWhereWithoutProtocolInput[]
    deleteMany?: ProtocolShareScalarWhereInput | ProtocolShareScalarWhereInput[]
  }

  export type BlockUncheckedUpdateManyWithoutProtocolNestedInput = {
    create?: XOR<BlockCreateWithoutProtocolInput, BlockUncheckedCreateWithoutProtocolInput> | BlockCreateWithoutProtocolInput[] | BlockUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutProtocolInput | BlockCreateOrConnectWithoutProtocolInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutProtocolInput | BlockUpsertWithWhereUniqueWithoutProtocolInput[]
    createMany?: BlockCreateManyProtocolInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutProtocolInput | BlockUpdateWithWhereUniqueWithoutProtocolInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutProtocolInput | BlockUpdateManyWithWhereWithoutProtocolInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type ProtocolTemplateUncheckedUpdateManyWithoutProtocolNestedInput = {
    create?: XOR<ProtocolTemplateCreateWithoutProtocolInput, ProtocolTemplateUncheckedCreateWithoutProtocolInput> | ProtocolTemplateCreateWithoutProtocolInput[] | ProtocolTemplateUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: ProtocolTemplateCreateOrConnectWithoutProtocolInput | ProtocolTemplateCreateOrConnectWithoutProtocolInput[]
    upsert?: ProtocolTemplateUpsertWithWhereUniqueWithoutProtocolInput | ProtocolTemplateUpsertWithWhereUniqueWithoutProtocolInput[]
    createMany?: ProtocolTemplateCreateManyProtocolInputEnvelope
    set?: ProtocolTemplateWhereUniqueInput | ProtocolTemplateWhereUniqueInput[]
    disconnect?: ProtocolTemplateWhereUniqueInput | ProtocolTemplateWhereUniqueInput[]
    delete?: ProtocolTemplateWhereUniqueInput | ProtocolTemplateWhereUniqueInput[]
    connect?: ProtocolTemplateWhereUniqueInput | ProtocolTemplateWhereUniqueInput[]
    update?: ProtocolTemplateUpdateWithWhereUniqueWithoutProtocolInput | ProtocolTemplateUpdateWithWhereUniqueWithoutProtocolInput[]
    updateMany?: ProtocolTemplateUpdateManyWithWhereWithoutProtocolInput | ProtocolTemplateUpdateManyWithWhereWithoutProtocolInput[]
    deleteMany?: ProtocolTemplateScalarWhereInput | ProtocolTemplateScalarWhereInput[]
  }

  export type ProtocolExecutionUncheckedUpdateManyWithoutProtocolNestedInput = {
    create?: XOR<ProtocolExecutionCreateWithoutProtocolInput, ProtocolExecutionUncheckedCreateWithoutProtocolInput> | ProtocolExecutionCreateWithoutProtocolInput[] | ProtocolExecutionUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: ProtocolExecutionCreateOrConnectWithoutProtocolInput | ProtocolExecutionCreateOrConnectWithoutProtocolInput[]
    upsert?: ProtocolExecutionUpsertWithWhereUniqueWithoutProtocolInput | ProtocolExecutionUpsertWithWhereUniqueWithoutProtocolInput[]
    createMany?: ProtocolExecutionCreateManyProtocolInputEnvelope
    set?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    disconnect?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    delete?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    connect?: ProtocolExecutionWhereUniqueInput | ProtocolExecutionWhereUniqueInput[]
    update?: ProtocolExecutionUpdateWithWhereUniqueWithoutProtocolInput | ProtocolExecutionUpdateWithWhereUniqueWithoutProtocolInput[]
    updateMany?: ProtocolExecutionUpdateManyWithWhereWithoutProtocolInput | ProtocolExecutionUpdateManyWithWhereWithoutProtocolInput[]
    deleteMany?: ProtocolExecutionScalarWhereInput | ProtocolExecutionScalarWhereInput[]
  }

  export type ProtocolPermissionUncheckedUpdateManyWithoutProtocolNestedInput = {
    create?: XOR<ProtocolPermissionCreateWithoutProtocolInput, ProtocolPermissionUncheckedCreateWithoutProtocolInput> | ProtocolPermissionCreateWithoutProtocolInput[] | ProtocolPermissionUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: ProtocolPermissionCreateOrConnectWithoutProtocolInput | ProtocolPermissionCreateOrConnectWithoutProtocolInput[]
    upsert?: ProtocolPermissionUpsertWithWhereUniqueWithoutProtocolInput | ProtocolPermissionUpsertWithWhereUniqueWithoutProtocolInput[]
    createMany?: ProtocolPermissionCreateManyProtocolInputEnvelope
    set?: ProtocolPermissionWhereUniqueInput | ProtocolPermissionWhereUniqueInput[]
    disconnect?: ProtocolPermissionWhereUniqueInput | ProtocolPermissionWhereUniqueInput[]
    delete?: ProtocolPermissionWhereUniqueInput | ProtocolPermissionWhereUniqueInput[]
    connect?: ProtocolPermissionWhereUniqueInput | ProtocolPermissionWhereUniqueInput[]
    update?: ProtocolPermissionUpdateWithWhereUniqueWithoutProtocolInput | ProtocolPermissionUpdateWithWhereUniqueWithoutProtocolInput[]
    updateMany?: ProtocolPermissionUpdateManyWithWhereWithoutProtocolInput | ProtocolPermissionUpdateManyWithWhereWithoutProtocolInput[]
    deleteMany?: ProtocolPermissionScalarWhereInput | ProtocolPermissionScalarWhereInput[]
  }

  export type ProtocolShareUncheckedUpdateManyWithoutProtocolNestedInput = {
    create?: XOR<ProtocolShareCreateWithoutProtocolInput, ProtocolShareUncheckedCreateWithoutProtocolInput> | ProtocolShareCreateWithoutProtocolInput[] | ProtocolShareUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: ProtocolShareCreateOrConnectWithoutProtocolInput | ProtocolShareCreateOrConnectWithoutProtocolInput[]
    upsert?: ProtocolShareUpsertWithWhereUniqueWithoutProtocolInput | ProtocolShareUpsertWithWhereUniqueWithoutProtocolInput[]
    createMany?: ProtocolShareCreateManyProtocolInputEnvelope
    set?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    disconnect?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    delete?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    connect?: ProtocolShareWhereUniqueInput | ProtocolShareWhereUniqueInput[]
    update?: ProtocolShareUpdateWithWhereUniqueWithoutProtocolInput | ProtocolShareUpdateWithWhereUniqueWithoutProtocolInput[]
    updateMany?: ProtocolShareUpdateManyWithWhereWithoutProtocolInput | ProtocolShareUpdateManyWithWhereWithoutProtocolInput[]
    deleteMany?: ProtocolShareScalarWhereInput | ProtocolShareScalarWhereInput[]
  }

  export type ProtocolCreateNestedOneWithoutBlocksInput = {
    create?: XOR<ProtocolCreateWithoutBlocksInput, ProtocolUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: ProtocolCreateOrConnectWithoutBlocksInput
    connect?: ProtocolWhereUniqueInput
  }

  export type BlockSessionCreateNestedManyWithoutBlockInput = {
    create?: XOR<BlockSessionCreateWithoutBlockInput, BlockSessionUncheckedCreateWithoutBlockInput> | BlockSessionCreateWithoutBlockInput[] | BlockSessionUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: BlockSessionCreateOrConnectWithoutBlockInput | BlockSessionCreateOrConnectWithoutBlockInput[]
    createMany?: BlockSessionCreateManyBlockInputEnvelope
    connect?: BlockSessionWhereUniqueInput | BlockSessionWhereUniqueInput[]
  }

  export type BlockProgressionCreateNestedManyWithoutBlockInput = {
    create?: XOR<BlockProgressionCreateWithoutBlockInput, BlockProgressionUncheckedCreateWithoutBlockInput> | BlockProgressionCreateWithoutBlockInput[] | BlockProgressionUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: BlockProgressionCreateOrConnectWithoutBlockInput | BlockProgressionCreateOrConnectWithoutBlockInput[]
    createMany?: BlockProgressionCreateManyBlockInputEnvelope
    connect?: BlockProgressionWhereUniqueInput | BlockProgressionWhereUniqueInput[]
  }

  export type BlockExecutionCreateNestedManyWithoutBlockInput = {
    create?: XOR<BlockExecutionCreateWithoutBlockInput, BlockExecutionUncheckedCreateWithoutBlockInput> | BlockExecutionCreateWithoutBlockInput[] | BlockExecutionUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: BlockExecutionCreateOrConnectWithoutBlockInput | BlockExecutionCreateOrConnectWithoutBlockInput[]
    createMany?: BlockExecutionCreateManyBlockInputEnvelope
    connect?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
  }

  export type BlockSessionUncheckedCreateNestedManyWithoutBlockInput = {
    create?: XOR<BlockSessionCreateWithoutBlockInput, BlockSessionUncheckedCreateWithoutBlockInput> | BlockSessionCreateWithoutBlockInput[] | BlockSessionUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: BlockSessionCreateOrConnectWithoutBlockInput | BlockSessionCreateOrConnectWithoutBlockInput[]
    createMany?: BlockSessionCreateManyBlockInputEnvelope
    connect?: BlockSessionWhereUniqueInput | BlockSessionWhereUniqueInput[]
  }

  export type BlockProgressionUncheckedCreateNestedManyWithoutBlockInput = {
    create?: XOR<BlockProgressionCreateWithoutBlockInput, BlockProgressionUncheckedCreateWithoutBlockInput> | BlockProgressionCreateWithoutBlockInput[] | BlockProgressionUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: BlockProgressionCreateOrConnectWithoutBlockInput | BlockProgressionCreateOrConnectWithoutBlockInput[]
    createMany?: BlockProgressionCreateManyBlockInputEnvelope
    connect?: BlockProgressionWhereUniqueInput | BlockProgressionWhereUniqueInput[]
  }

  export type BlockExecutionUncheckedCreateNestedManyWithoutBlockInput = {
    create?: XOR<BlockExecutionCreateWithoutBlockInput, BlockExecutionUncheckedCreateWithoutBlockInput> | BlockExecutionCreateWithoutBlockInput[] | BlockExecutionUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: BlockExecutionCreateOrConnectWithoutBlockInput | BlockExecutionCreateOrConnectWithoutBlockInput[]
    createMany?: BlockExecutionCreateManyBlockInputEnvelope
    connect?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
  }

  export type ProtocolUpdateOneRequiredWithoutBlocksNestedInput = {
    create?: XOR<ProtocolCreateWithoutBlocksInput, ProtocolUncheckedCreateWithoutBlocksInput>
    connectOrCreate?: ProtocolCreateOrConnectWithoutBlocksInput
    upsert?: ProtocolUpsertWithoutBlocksInput
    connect?: ProtocolWhereUniqueInput
    update?: XOR<XOR<ProtocolUpdateToOneWithWhereWithoutBlocksInput, ProtocolUpdateWithoutBlocksInput>, ProtocolUncheckedUpdateWithoutBlocksInput>
  }

  export type BlockSessionUpdateManyWithoutBlockNestedInput = {
    create?: XOR<BlockSessionCreateWithoutBlockInput, BlockSessionUncheckedCreateWithoutBlockInput> | BlockSessionCreateWithoutBlockInput[] | BlockSessionUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: BlockSessionCreateOrConnectWithoutBlockInput | BlockSessionCreateOrConnectWithoutBlockInput[]
    upsert?: BlockSessionUpsertWithWhereUniqueWithoutBlockInput | BlockSessionUpsertWithWhereUniqueWithoutBlockInput[]
    createMany?: BlockSessionCreateManyBlockInputEnvelope
    set?: BlockSessionWhereUniqueInput | BlockSessionWhereUniqueInput[]
    disconnect?: BlockSessionWhereUniqueInput | BlockSessionWhereUniqueInput[]
    delete?: BlockSessionWhereUniqueInput | BlockSessionWhereUniqueInput[]
    connect?: BlockSessionWhereUniqueInput | BlockSessionWhereUniqueInput[]
    update?: BlockSessionUpdateWithWhereUniqueWithoutBlockInput | BlockSessionUpdateWithWhereUniqueWithoutBlockInput[]
    updateMany?: BlockSessionUpdateManyWithWhereWithoutBlockInput | BlockSessionUpdateManyWithWhereWithoutBlockInput[]
    deleteMany?: BlockSessionScalarWhereInput | BlockSessionScalarWhereInput[]
  }

  export type BlockProgressionUpdateManyWithoutBlockNestedInput = {
    create?: XOR<BlockProgressionCreateWithoutBlockInput, BlockProgressionUncheckedCreateWithoutBlockInput> | BlockProgressionCreateWithoutBlockInput[] | BlockProgressionUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: BlockProgressionCreateOrConnectWithoutBlockInput | BlockProgressionCreateOrConnectWithoutBlockInput[]
    upsert?: BlockProgressionUpsertWithWhereUniqueWithoutBlockInput | BlockProgressionUpsertWithWhereUniqueWithoutBlockInput[]
    createMany?: BlockProgressionCreateManyBlockInputEnvelope
    set?: BlockProgressionWhereUniqueInput | BlockProgressionWhereUniqueInput[]
    disconnect?: BlockProgressionWhereUniqueInput | BlockProgressionWhereUniqueInput[]
    delete?: BlockProgressionWhereUniqueInput | BlockProgressionWhereUniqueInput[]
    connect?: BlockProgressionWhereUniqueInput | BlockProgressionWhereUniqueInput[]
    update?: BlockProgressionUpdateWithWhereUniqueWithoutBlockInput | BlockProgressionUpdateWithWhereUniqueWithoutBlockInput[]
    updateMany?: BlockProgressionUpdateManyWithWhereWithoutBlockInput | BlockProgressionUpdateManyWithWhereWithoutBlockInput[]
    deleteMany?: BlockProgressionScalarWhereInput | BlockProgressionScalarWhereInput[]
  }

  export type BlockExecutionUpdateManyWithoutBlockNestedInput = {
    create?: XOR<BlockExecutionCreateWithoutBlockInput, BlockExecutionUncheckedCreateWithoutBlockInput> | BlockExecutionCreateWithoutBlockInput[] | BlockExecutionUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: BlockExecutionCreateOrConnectWithoutBlockInput | BlockExecutionCreateOrConnectWithoutBlockInput[]
    upsert?: BlockExecutionUpsertWithWhereUniqueWithoutBlockInput | BlockExecutionUpsertWithWhereUniqueWithoutBlockInput[]
    createMany?: BlockExecutionCreateManyBlockInputEnvelope
    set?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    disconnect?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    delete?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    connect?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    update?: BlockExecutionUpdateWithWhereUniqueWithoutBlockInput | BlockExecutionUpdateWithWhereUniqueWithoutBlockInput[]
    updateMany?: BlockExecutionUpdateManyWithWhereWithoutBlockInput | BlockExecutionUpdateManyWithWhereWithoutBlockInput[]
    deleteMany?: BlockExecutionScalarWhereInput | BlockExecutionScalarWhereInput[]
  }

  export type BlockSessionUncheckedUpdateManyWithoutBlockNestedInput = {
    create?: XOR<BlockSessionCreateWithoutBlockInput, BlockSessionUncheckedCreateWithoutBlockInput> | BlockSessionCreateWithoutBlockInput[] | BlockSessionUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: BlockSessionCreateOrConnectWithoutBlockInput | BlockSessionCreateOrConnectWithoutBlockInput[]
    upsert?: BlockSessionUpsertWithWhereUniqueWithoutBlockInput | BlockSessionUpsertWithWhereUniqueWithoutBlockInput[]
    createMany?: BlockSessionCreateManyBlockInputEnvelope
    set?: BlockSessionWhereUniqueInput | BlockSessionWhereUniqueInput[]
    disconnect?: BlockSessionWhereUniqueInput | BlockSessionWhereUniqueInput[]
    delete?: BlockSessionWhereUniqueInput | BlockSessionWhereUniqueInput[]
    connect?: BlockSessionWhereUniqueInput | BlockSessionWhereUniqueInput[]
    update?: BlockSessionUpdateWithWhereUniqueWithoutBlockInput | BlockSessionUpdateWithWhereUniqueWithoutBlockInput[]
    updateMany?: BlockSessionUpdateManyWithWhereWithoutBlockInput | BlockSessionUpdateManyWithWhereWithoutBlockInput[]
    deleteMany?: BlockSessionScalarWhereInput | BlockSessionScalarWhereInput[]
  }

  export type BlockProgressionUncheckedUpdateManyWithoutBlockNestedInput = {
    create?: XOR<BlockProgressionCreateWithoutBlockInput, BlockProgressionUncheckedCreateWithoutBlockInput> | BlockProgressionCreateWithoutBlockInput[] | BlockProgressionUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: BlockProgressionCreateOrConnectWithoutBlockInput | BlockProgressionCreateOrConnectWithoutBlockInput[]
    upsert?: BlockProgressionUpsertWithWhereUniqueWithoutBlockInput | BlockProgressionUpsertWithWhereUniqueWithoutBlockInput[]
    createMany?: BlockProgressionCreateManyBlockInputEnvelope
    set?: BlockProgressionWhereUniqueInput | BlockProgressionWhereUniqueInput[]
    disconnect?: BlockProgressionWhereUniqueInput | BlockProgressionWhereUniqueInput[]
    delete?: BlockProgressionWhereUniqueInput | BlockProgressionWhereUniqueInput[]
    connect?: BlockProgressionWhereUniqueInput | BlockProgressionWhereUniqueInput[]
    update?: BlockProgressionUpdateWithWhereUniqueWithoutBlockInput | BlockProgressionUpdateWithWhereUniqueWithoutBlockInput[]
    updateMany?: BlockProgressionUpdateManyWithWhereWithoutBlockInput | BlockProgressionUpdateManyWithWhereWithoutBlockInput[]
    deleteMany?: BlockProgressionScalarWhereInput | BlockProgressionScalarWhereInput[]
  }

  export type BlockExecutionUncheckedUpdateManyWithoutBlockNestedInput = {
    create?: XOR<BlockExecutionCreateWithoutBlockInput, BlockExecutionUncheckedCreateWithoutBlockInput> | BlockExecutionCreateWithoutBlockInput[] | BlockExecutionUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: BlockExecutionCreateOrConnectWithoutBlockInput | BlockExecutionCreateOrConnectWithoutBlockInput[]
    upsert?: BlockExecutionUpsertWithWhereUniqueWithoutBlockInput | BlockExecutionUpsertWithWhereUniqueWithoutBlockInput[]
    createMany?: BlockExecutionCreateManyBlockInputEnvelope
    set?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    disconnect?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    delete?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    connect?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    update?: BlockExecutionUpdateWithWhereUniqueWithoutBlockInput | BlockExecutionUpdateWithWhereUniqueWithoutBlockInput[]
    updateMany?: BlockExecutionUpdateManyWithWhereWithoutBlockInput | BlockExecutionUpdateManyWithWhereWithoutBlockInput[]
    deleteMany?: BlockExecutionScalarWhereInput | BlockExecutionScalarWhereInput[]
  }

  export type BlockCreateNestedOneWithoutSessionsInput = {
    create?: XOR<BlockCreateWithoutSessionsInput, BlockUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: BlockCreateOrConnectWithoutSessionsInput
    connect?: BlockWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BlockUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<BlockCreateWithoutSessionsInput, BlockUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: BlockCreateOrConnectWithoutSessionsInput
    upsert?: BlockUpsertWithoutSessionsInput
    connect?: BlockWhereUniqueInput
    update?: XOR<XOR<BlockUpdateToOneWithWhereWithoutSessionsInput, BlockUpdateWithoutSessionsInput>, BlockUncheckedUpdateWithoutSessionsInput>
  }

  export type BlockCreateNestedOneWithoutProgressionsInput = {
    create?: XOR<BlockCreateWithoutProgressionsInput, BlockUncheckedCreateWithoutProgressionsInput>
    connectOrCreate?: BlockCreateOrConnectWithoutProgressionsInput
    connect?: BlockWhereUniqueInput
  }

  export type BlockUpdateOneRequiredWithoutProgressionsNestedInput = {
    create?: XOR<BlockCreateWithoutProgressionsInput, BlockUncheckedCreateWithoutProgressionsInput>
    connectOrCreate?: BlockCreateOrConnectWithoutProgressionsInput
    upsert?: BlockUpsertWithoutProgressionsInput
    connect?: BlockWhereUniqueInput
    update?: XOR<XOR<BlockUpdateToOneWithWhereWithoutProgressionsInput, BlockUpdateWithoutProgressionsInput>, BlockUncheckedUpdateWithoutProgressionsInput>
  }

  export type ProtocolPermissionCreatepermissionsInput = {
    set: $Enums.Permission[]
  }

  export type ProtocolCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<ProtocolCreateWithoutPermissionsInput, ProtocolUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: ProtocolCreateOrConnectWithoutPermissionsInput
    connect?: ProtocolWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermissionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPermissionRoleFieldUpdateOperationsInput = {
    set?: $Enums.PermissionRole
  }

  export type ProtocolPermissionUpdatepermissionsInput = {
    set?: $Enums.Permission[]
    push?: $Enums.Permission | $Enums.Permission[]
  }

  export type ProtocolUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<ProtocolCreateWithoutPermissionsInput, ProtocolUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: ProtocolCreateOrConnectWithoutPermissionsInput
    upsert?: ProtocolUpsertWithoutPermissionsInput
    connect?: ProtocolWhereUniqueInput
    update?: XOR<XOR<ProtocolUpdateToOneWithWhereWithoutPermissionsInput, ProtocolUpdateWithoutPermissionsInput>, ProtocolUncheckedUpdateWithoutPermissionsInput>
  }

  export type UserUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermissionsInput
    upsert?: UserUpsertWithoutPermissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPermissionsInput, UserUpdateWithoutPermissionsInput>, UserUncheckedUpdateWithoutPermissionsInput>
  }

  export type ProtocolCreateNestedOneWithoutTemplatesInput = {
    create?: XOR<ProtocolCreateWithoutTemplatesInput, ProtocolUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: ProtocolCreateOrConnectWithoutTemplatesInput
    connect?: ProtocolWhereUniqueInput
  }

  export type ProtocolUpdateOneRequiredWithoutTemplatesNestedInput = {
    create?: XOR<ProtocolCreateWithoutTemplatesInput, ProtocolUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: ProtocolCreateOrConnectWithoutTemplatesInput
    upsert?: ProtocolUpsertWithoutTemplatesInput
    connect?: ProtocolWhereUniqueInput
    update?: XOR<XOR<ProtocolUpdateToOneWithWhereWithoutTemplatesInput, ProtocolUpdateWithoutTemplatesInput>, ProtocolUncheckedUpdateWithoutTemplatesInput>
  }

  export type TenantCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<TenantCreateWithoutExecutionsInput, TenantUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutExecutionsInput
    connect?: TenantWhereUniqueInput
  }

  export type ProtocolCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<ProtocolCreateWithoutExecutionsInput, ProtocolUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: ProtocolCreateOrConnectWithoutExecutionsInput
    connect?: ProtocolWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<UserCreateWithoutExecutionsInput, UserUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExecutionsInput
    connect?: UserWhereUniqueInput
  }

  export type BlockExecutionCreateNestedManyWithoutExecutionInput = {
    create?: XOR<BlockExecutionCreateWithoutExecutionInput, BlockExecutionUncheckedCreateWithoutExecutionInput> | BlockExecutionCreateWithoutExecutionInput[] | BlockExecutionUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: BlockExecutionCreateOrConnectWithoutExecutionInput | BlockExecutionCreateOrConnectWithoutExecutionInput[]
    createMany?: BlockExecutionCreateManyExecutionInputEnvelope
    connect?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
  }

  export type SessionExecutionCreateNestedManyWithoutExecutionInput = {
    create?: XOR<SessionExecutionCreateWithoutExecutionInput, SessionExecutionUncheckedCreateWithoutExecutionInput> | SessionExecutionCreateWithoutExecutionInput[] | SessionExecutionUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: SessionExecutionCreateOrConnectWithoutExecutionInput | SessionExecutionCreateOrConnectWithoutExecutionInput[]
    createMany?: SessionExecutionCreateManyExecutionInputEnvelope
    connect?: SessionExecutionWhereUniqueInput | SessionExecutionWhereUniqueInput[]
  }

  export type BlockExecutionUncheckedCreateNestedManyWithoutExecutionInput = {
    create?: XOR<BlockExecutionCreateWithoutExecutionInput, BlockExecutionUncheckedCreateWithoutExecutionInput> | BlockExecutionCreateWithoutExecutionInput[] | BlockExecutionUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: BlockExecutionCreateOrConnectWithoutExecutionInput | BlockExecutionCreateOrConnectWithoutExecutionInput[]
    createMany?: BlockExecutionCreateManyExecutionInputEnvelope
    connect?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
  }

  export type SessionExecutionUncheckedCreateNestedManyWithoutExecutionInput = {
    create?: XOR<SessionExecutionCreateWithoutExecutionInput, SessionExecutionUncheckedCreateWithoutExecutionInput> | SessionExecutionCreateWithoutExecutionInput[] | SessionExecutionUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: SessionExecutionCreateOrConnectWithoutExecutionInput | SessionExecutionCreateOrConnectWithoutExecutionInput[]
    createMany?: SessionExecutionCreateManyExecutionInputEnvelope
    connect?: SessionExecutionWhereUniqueInput | SessionExecutionWhereUniqueInput[]
  }

  export type EnumDataClassificationFieldUpdateOperationsInput = {
    set?: $Enums.DataClassification
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<TenantCreateWithoutExecutionsInput, TenantUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutExecutionsInput
    upsert?: TenantUpsertWithoutExecutionsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutExecutionsInput, TenantUpdateWithoutExecutionsInput>, TenantUncheckedUpdateWithoutExecutionsInput>
  }

  export type ProtocolUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<ProtocolCreateWithoutExecutionsInput, ProtocolUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: ProtocolCreateOrConnectWithoutExecutionsInput
    upsert?: ProtocolUpsertWithoutExecutionsInput
    connect?: ProtocolWhereUniqueInput
    update?: XOR<XOR<ProtocolUpdateToOneWithWhereWithoutExecutionsInput, ProtocolUpdateWithoutExecutionsInput>, ProtocolUncheckedUpdateWithoutExecutionsInput>
  }

  export type UserUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<UserCreateWithoutExecutionsInput, UserUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExecutionsInput
    upsert?: UserUpsertWithoutExecutionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExecutionsInput, UserUpdateWithoutExecutionsInput>, UserUncheckedUpdateWithoutExecutionsInput>
  }

  export type BlockExecutionUpdateManyWithoutExecutionNestedInput = {
    create?: XOR<BlockExecutionCreateWithoutExecutionInput, BlockExecutionUncheckedCreateWithoutExecutionInput> | BlockExecutionCreateWithoutExecutionInput[] | BlockExecutionUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: BlockExecutionCreateOrConnectWithoutExecutionInput | BlockExecutionCreateOrConnectWithoutExecutionInput[]
    upsert?: BlockExecutionUpsertWithWhereUniqueWithoutExecutionInput | BlockExecutionUpsertWithWhereUniqueWithoutExecutionInput[]
    createMany?: BlockExecutionCreateManyExecutionInputEnvelope
    set?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    disconnect?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    delete?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    connect?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    update?: BlockExecutionUpdateWithWhereUniqueWithoutExecutionInput | BlockExecutionUpdateWithWhereUniqueWithoutExecutionInput[]
    updateMany?: BlockExecutionUpdateManyWithWhereWithoutExecutionInput | BlockExecutionUpdateManyWithWhereWithoutExecutionInput[]
    deleteMany?: BlockExecutionScalarWhereInput | BlockExecutionScalarWhereInput[]
  }

  export type SessionExecutionUpdateManyWithoutExecutionNestedInput = {
    create?: XOR<SessionExecutionCreateWithoutExecutionInput, SessionExecutionUncheckedCreateWithoutExecutionInput> | SessionExecutionCreateWithoutExecutionInput[] | SessionExecutionUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: SessionExecutionCreateOrConnectWithoutExecutionInput | SessionExecutionCreateOrConnectWithoutExecutionInput[]
    upsert?: SessionExecutionUpsertWithWhereUniqueWithoutExecutionInput | SessionExecutionUpsertWithWhereUniqueWithoutExecutionInput[]
    createMany?: SessionExecutionCreateManyExecutionInputEnvelope
    set?: SessionExecutionWhereUniqueInput | SessionExecutionWhereUniqueInput[]
    disconnect?: SessionExecutionWhereUniqueInput | SessionExecutionWhereUniqueInput[]
    delete?: SessionExecutionWhereUniqueInput | SessionExecutionWhereUniqueInput[]
    connect?: SessionExecutionWhereUniqueInput | SessionExecutionWhereUniqueInput[]
    update?: SessionExecutionUpdateWithWhereUniqueWithoutExecutionInput | SessionExecutionUpdateWithWhereUniqueWithoutExecutionInput[]
    updateMany?: SessionExecutionUpdateManyWithWhereWithoutExecutionInput | SessionExecutionUpdateManyWithWhereWithoutExecutionInput[]
    deleteMany?: SessionExecutionScalarWhereInput | SessionExecutionScalarWhereInput[]
  }

  export type BlockExecutionUncheckedUpdateManyWithoutExecutionNestedInput = {
    create?: XOR<BlockExecutionCreateWithoutExecutionInput, BlockExecutionUncheckedCreateWithoutExecutionInput> | BlockExecutionCreateWithoutExecutionInput[] | BlockExecutionUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: BlockExecutionCreateOrConnectWithoutExecutionInput | BlockExecutionCreateOrConnectWithoutExecutionInput[]
    upsert?: BlockExecutionUpsertWithWhereUniqueWithoutExecutionInput | BlockExecutionUpsertWithWhereUniqueWithoutExecutionInput[]
    createMany?: BlockExecutionCreateManyExecutionInputEnvelope
    set?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    disconnect?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    delete?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    connect?: BlockExecutionWhereUniqueInput | BlockExecutionWhereUniqueInput[]
    update?: BlockExecutionUpdateWithWhereUniqueWithoutExecutionInput | BlockExecutionUpdateWithWhereUniqueWithoutExecutionInput[]
    updateMany?: BlockExecutionUpdateManyWithWhereWithoutExecutionInput | BlockExecutionUpdateManyWithWhereWithoutExecutionInput[]
    deleteMany?: BlockExecutionScalarWhereInput | BlockExecutionScalarWhereInput[]
  }

  export type SessionExecutionUncheckedUpdateManyWithoutExecutionNestedInput = {
    create?: XOR<SessionExecutionCreateWithoutExecutionInput, SessionExecutionUncheckedCreateWithoutExecutionInput> | SessionExecutionCreateWithoutExecutionInput[] | SessionExecutionUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: SessionExecutionCreateOrConnectWithoutExecutionInput | SessionExecutionCreateOrConnectWithoutExecutionInput[]
    upsert?: SessionExecutionUpsertWithWhereUniqueWithoutExecutionInput | SessionExecutionUpsertWithWhereUniqueWithoutExecutionInput[]
    createMany?: SessionExecutionCreateManyExecutionInputEnvelope
    set?: SessionExecutionWhereUniqueInput | SessionExecutionWhereUniqueInput[]
    disconnect?: SessionExecutionWhereUniqueInput | SessionExecutionWhereUniqueInput[]
    delete?: SessionExecutionWhereUniqueInput | SessionExecutionWhereUniqueInput[]
    connect?: SessionExecutionWhereUniqueInput | SessionExecutionWhereUniqueInput[]
    update?: SessionExecutionUpdateWithWhereUniqueWithoutExecutionInput | SessionExecutionUpdateWithWhereUniqueWithoutExecutionInput[]
    updateMany?: SessionExecutionUpdateManyWithWhereWithoutExecutionInput | SessionExecutionUpdateManyWithWhereWithoutExecutionInput[]
    deleteMany?: SessionExecutionScalarWhereInput | SessionExecutionScalarWhereInput[]
  }

  export type ProtocolExecutionCreateNestedOneWithoutBlockExecutionsInput = {
    create?: XOR<ProtocolExecutionCreateWithoutBlockExecutionsInput, ProtocolExecutionUncheckedCreateWithoutBlockExecutionsInput>
    connectOrCreate?: ProtocolExecutionCreateOrConnectWithoutBlockExecutionsInput
    connect?: ProtocolExecutionWhereUniqueInput
  }

  export type BlockCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<BlockCreateWithoutExecutionsInput, BlockUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: BlockCreateOrConnectWithoutExecutionsInput
    connect?: BlockWhereUniqueInput
  }

  export type ProtocolExecutionUpdateOneRequiredWithoutBlockExecutionsNestedInput = {
    create?: XOR<ProtocolExecutionCreateWithoutBlockExecutionsInput, ProtocolExecutionUncheckedCreateWithoutBlockExecutionsInput>
    connectOrCreate?: ProtocolExecutionCreateOrConnectWithoutBlockExecutionsInput
    upsert?: ProtocolExecutionUpsertWithoutBlockExecutionsInput
    connect?: ProtocolExecutionWhereUniqueInput
    update?: XOR<XOR<ProtocolExecutionUpdateToOneWithWhereWithoutBlockExecutionsInput, ProtocolExecutionUpdateWithoutBlockExecutionsInput>, ProtocolExecutionUncheckedUpdateWithoutBlockExecutionsInput>
  }

  export type BlockUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<BlockCreateWithoutExecutionsInput, BlockUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: BlockCreateOrConnectWithoutExecutionsInput
    upsert?: BlockUpsertWithoutExecutionsInput
    connect?: BlockWhereUniqueInput
    update?: XOR<XOR<BlockUpdateToOneWithWhereWithoutExecutionsInput, BlockUpdateWithoutExecutionsInput>, BlockUncheckedUpdateWithoutExecutionsInput>
  }

  export type ProtocolExecutionCreateNestedOneWithoutSessionsInput = {
    create?: XOR<ProtocolExecutionCreateWithoutSessionsInput, ProtocolExecutionUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: ProtocolExecutionCreateOrConnectWithoutSessionsInput
    connect?: ProtocolExecutionWhereUniqueInput
  }

  export type ProtocolExecutionUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<ProtocolExecutionCreateWithoutSessionsInput, ProtocolExecutionUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: ProtocolExecutionCreateOrConnectWithoutSessionsInput
    upsert?: ProtocolExecutionUpsertWithoutSessionsInput
    connect?: ProtocolExecutionWhereUniqueInput
    update?: XOR<XOR<ProtocolExecutionUpdateToOneWithWhereWithoutSessionsInput, ProtocolExecutionUpdateWithoutSessionsInput>, ProtocolExecutionUncheckedUpdateWithoutSessionsInput>
  }

  export type ProtocolShareCreatepermissionsInput = {
    set: $Enums.Permission[]
  }

  export type ProtocolCreateNestedOneWithoutSharesInput = {
    create?: XOR<ProtocolCreateWithoutSharesInput, ProtocolUncheckedCreateWithoutSharesInput>
    connectOrCreate?: ProtocolCreateOrConnectWithoutSharesInput
    connect?: ProtocolWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSharedProtocolsInput = {
    create?: XOR<UserCreateWithoutSharedProtocolsInput, UserUncheckedCreateWithoutSharedProtocolsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedProtocolsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedProtocolsInput = {
    create?: XOR<UserCreateWithoutReceivedProtocolsInput, UserUncheckedCreateWithoutReceivedProtocolsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedProtocolsInput
    connect?: UserWhereUniqueInput
  }

  export type ProtocolShareUpdatepermissionsInput = {
    set?: $Enums.Permission[]
    push?: $Enums.Permission | $Enums.Permission[]
  }

  export type ProtocolUpdateOneRequiredWithoutSharesNestedInput = {
    create?: XOR<ProtocolCreateWithoutSharesInput, ProtocolUncheckedCreateWithoutSharesInput>
    connectOrCreate?: ProtocolCreateOrConnectWithoutSharesInput
    upsert?: ProtocolUpsertWithoutSharesInput
    connect?: ProtocolWhereUniqueInput
    update?: XOR<XOR<ProtocolUpdateToOneWithWhereWithoutSharesInput, ProtocolUpdateWithoutSharesInput>, ProtocolUncheckedUpdateWithoutSharesInput>
  }

  export type UserUpdateOneRequiredWithoutSharedProtocolsNestedInput = {
    create?: XOR<UserCreateWithoutSharedProtocolsInput, UserUncheckedCreateWithoutSharedProtocolsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedProtocolsInput
    upsert?: UserUpsertWithoutSharedProtocolsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSharedProtocolsInput, UserUpdateWithoutSharedProtocolsInput>, UserUncheckedUpdateWithoutSharedProtocolsInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedProtocolsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedProtocolsInput, UserUncheckedCreateWithoutReceivedProtocolsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedProtocolsInput
    upsert?: UserUpsertWithoutReceivedProtocolsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedProtocolsInput, UserUpdateWithoutReceivedProtocolsInput>, UserUncheckedUpdateWithoutReceivedProtocolsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityFilter<$PrismaModel> | $Enums.Visibility
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.Visibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisibilityFilter<$PrismaModel>
    _max?: NestedEnumVisibilityFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumPermissionRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionRole | EnumPermissionRoleFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionRole[] | ListEnumPermissionRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.PermissionRole[] | ListEnumPermissionRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionRoleFilter<$PrismaModel> | $Enums.PermissionRole
  }

  export type NestedEnumPermissionRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionRole | EnumPermissionRoleFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionRole[] | ListEnumPermissionRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.PermissionRole[] | ListEnumPermissionRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionRoleWithAggregatesFilter<$PrismaModel> | $Enums.PermissionRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPermissionRoleFilter<$PrismaModel>
    _max?: NestedEnumPermissionRoleFilter<$PrismaModel>
  }

  export type NestedEnumDataClassificationFilter<$PrismaModel = never> = {
    equals?: $Enums.DataClassification | EnumDataClassificationFieldRefInput<$PrismaModel>
    in?: $Enums.DataClassification[] | ListEnumDataClassificationFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataClassification[] | ListEnumDataClassificationFieldRefInput<$PrismaModel>
    not?: NestedEnumDataClassificationFilter<$PrismaModel> | $Enums.DataClassification
  }

  export type NestedEnumDataClassificationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataClassification | EnumDataClassificationFieldRefInput<$PrismaModel>
    in?: $Enums.DataClassification[] | ListEnumDataClassificationFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataClassification[] | ListEnumDataClassificationFieldRefInput<$PrismaModel>
    not?: NestedEnumDataClassificationWithAggregatesFilter<$PrismaModel> | $Enums.DataClassification
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataClassificationFilter<$PrismaModel>
    _max?: NestedEnumDataClassificationFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ProtocolCreateWithoutTenantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    version?: string
    description?: string | null
    category: string
    difficulty: string
    duration?: number | null
    frequency?: number | null
    visibility?: $Enums.Visibility
    isActive?: boolean
    isPublic?: boolean
    overview?: string | null
    principles?: ProtocolCreateprinciplesInput | string[]
    requirements?: ProtocolCreaterequirementsInput | string[]
    owner: UserCreateNestedOneWithoutProtocolsInput
    blocks?: BlockCreateNestedManyWithoutProtocolInput
    templates?: ProtocolTemplateCreateNestedManyWithoutProtocolInput
    executions?: ProtocolExecutionCreateNestedManyWithoutProtocolInput
    permissions?: ProtocolPermissionCreateNestedManyWithoutProtocolInput
    shares?: ProtocolShareCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolUncheckedCreateWithoutTenantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    version?: string
    description?: string | null
    category: string
    difficulty: string
    duration?: number | null
    frequency?: number | null
    ownerId: string
    visibility?: $Enums.Visibility
    isActive?: boolean
    isPublic?: boolean
    overview?: string | null
    principles?: ProtocolCreateprinciplesInput | string[]
    requirements?: ProtocolCreaterequirementsInput | string[]
    blocks?: BlockUncheckedCreateNestedManyWithoutProtocolInput
    templates?: ProtocolTemplateUncheckedCreateNestedManyWithoutProtocolInput
    executions?: ProtocolExecutionUncheckedCreateNestedManyWithoutProtocolInput
    permissions?: ProtocolPermissionUncheckedCreateNestedManyWithoutProtocolInput
    shares?: ProtocolShareUncheckedCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolCreateOrConnectWithoutTenantInput = {
    where: ProtocolWhereUniqueInput
    create: XOR<ProtocolCreateWithoutTenantInput, ProtocolUncheckedCreateWithoutTenantInput>
  }

  export type ProtocolCreateManyTenantInputEnvelope = {
    data: ProtocolCreateManyTenantInput | ProtocolCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    protocols?: ProtocolCreateNestedManyWithoutOwnerInput
    executions?: ProtocolExecutionCreateNestedManyWithoutUserInput
    permissions?: ProtocolPermissionCreateNestedManyWithoutUserInput
    sharedProtocols?: ProtocolShareCreateNestedManyWithoutSharedByUserInput
    receivedProtocols?: ProtocolShareCreateNestedManyWithoutSharedWithUserInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    protocols?: ProtocolUncheckedCreateNestedManyWithoutOwnerInput
    executions?: ProtocolExecutionUncheckedCreateNestedManyWithoutUserInput
    permissions?: ProtocolPermissionUncheckedCreateNestedManyWithoutUserInput
    sharedProtocols?: ProtocolShareUncheckedCreateNestedManyWithoutSharedByUserInput
    receivedProtocols?: ProtocolShareUncheckedCreateNestedManyWithoutSharedWithUserInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ProtocolExecutionCreateWithoutTenantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId?: string | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    parameters: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: $Enums.DataClassification
    retentionUntil?: Date | string | null
    currentBlockId?: string | null
    currentWeek?: number
    progress?: number
    protocol: ProtocolCreateNestedOneWithoutExecutionsInput
    user: UserCreateNestedOneWithoutExecutionsInput
    blockExecutions?: BlockExecutionCreateNestedManyWithoutExecutionInput
    sessions?: SessionExecutionCreateNestedManyWithoutExecutionInput
  }

  export type ProtocolExecutionUncheckedCreateWithoutTenantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    userId: string
    templateId?: string | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    parameters: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: $Enums.DataClassification
    retentionUntil?: Date | string | null
    currentBlockId?: string | null
    currentWeek?: number
    progress?: number
    blockExecutions?: BlockExecutionUncheckedCreateNestedManyWithoutExecutionInput
    sessions?: SessionExecutionUncheckedCreateNestedManyWithoutExecutionInput
  }

  export type ProtocolExecutionCreateOrConnectWithoutTenantInput = {
    where: ProtocolExecutionWhereUniqueInput
    create: XOR<ProtocolExecutionCreateWithoutTenantInput, ProtocolExecutionUncheckedCreateWithoutTenantInput>
  }

  export type ProtocolExecutionCreateManyTenantInputEnvelope = {
    data: ProtocolExecutionCreateManyTenantInput | ProtocolExecutionCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ProtocolUpsertWithWhereUniqueWithoutTenantInput = {
    where: ProtocolWhereUniqueInput
    update: XOR<ProtocolUpdateWithoutTenantInput, ProtocolUncheckedUpdateWithoutTenantInput>
    create: XOR<ProtocolCreateWithoutTenantInput, ProtocolUncheckedCreateWithoutTenantInput>
  }

  export type ProtocolUpdateWithWhereUniqueWithoutTenantInput = {
    where: ProtocolWhereUniqueInput
    data: XOR<ProtocolUpdateWithoutTenantInput, ProtocolUncheckedUpdateWithoutTenantInput>
  }

  export type ProtocolUpdateManyWithWhereWithoutTenantInput = {
    where: ProtocolScalarWhereInput
    data: XOR<ProtocolUpdateManyMutationInput, ProtocolUncheckedUpdateManyWithoutTenantInput>
  }

  export type ProtocolScalarWhereInput = {
    AND?: ProtocolScalarWhereInput | ProtocolScalarWhereInput[]
    OR?: ProtocolScalarWhereInput[]
    NOT?: ProtocolScalarWhereInput | ProtocolScalarWhereInput[]
    id?: StringFilter<"Protocol"> | string
    createdAt?: DateTimeFilter<"Protocol"> | Date | string
    updatedAt?: DateTimeFilter<"Protocol"> | Date | string
    tenantId?: StringFilter<"Protocol"> | string
    name?: StringFilter<"Protocol"> | string
    version?: StringFilter<"Protocol"> | string
    description?: StringNullableFilter<"Protocol"> | string | null
    category?: StringFilter<"Protocol"> | string
    difficulty?: StringFilter<"Protocol"> | string
    duration?: IntNullableFilter<"Protocol"> | number | null
    frequency?: IntNullableFilter<"Protocol"> | number | null
    ownerId?: StringFilter<"Protocol"> | string
    visibility?: EnumVisibilityFilter<"Protocol"> | $Enums.Visibility
    isActive?: BoolFilter<"Protocol"> | boolean
    isPublic?: BoolFilter<"Protocol"> | boolean
    overview?: StringNullableFilter<"Protocol"> | string | null
    principles?: StringNullableListFilter<"Protocol">
    requirements?: StringNullableListFilter<"Protocol">
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    tenantId?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type ProtocolExecutionUpsertWithWhereUniqueWithoutTenantInput = {
    where: ProtocolExecutionWhereUniqueInput
    update: XOR<ProtocolExecutionUpdateWithoutTenantInput, ProtocolExecutionUncheckedUpdateWithoutTenantInput>
    create: XOR<ProtocolExecutionCreateWithoutTenantInput, ProtocolExecutionUncheckedCreateWithoutTenantInput>
  }

  export type ProtocolExecutionUpdateWithWhereUniqueWithoutTenantInput = {
    where: ProtocolExecutionWhereUniqueInput
    data: XOR<ProtocolExecutionUpdateWithoutTenantInput, ProtocolExecutionUncheckedUpdateWithoutTenantInput>
  }

  export type ProtocolExecutionUpdateManyWithWhereWithoutTenantInput = {
    where: ProtocolExecutionScalarWhereInput
    data: XOR<ProtocolExecutionUpdateManyMutationInput, ProtocolExecutionUncheckedUpdateManyWithoutTenantInput>
  }

  export type ProtocolExecutionScalarWhereInput = {
    AND?: ProtocolExecutionScalarWhereInput | ProtocolExecutionScalarWhereInput[]
    OR?: ProtocolExecutionScalarWhereInput[]
    NOT?: ProtocolExecutionScalarWhereInput | ProtocolExecutionScalarWhereInput[]
    id?: StringFilter<"ProtocolExecution"> | string
    createdAt?: DateTimeFilter<"ProtocolExecution"> | Date | string
    updatedAt?: DateTimeFilter<"ProtocolExecution"> | Date | string
    tenantId?: StringFilter<"ProtocolExecution"> | string
    protocolId?: StringFilter<"ProtocolExecution"> | string
    userId?: StringFilter<"ProtocolExecution"> | string
    templateId?: StringNullableFilter<"ProtocolExecution"> | string | null
    status?: StringFilter<"ProtocolExecution"> | string
    startDate?: DateTimeFilter<"ProtocolExecution"> | Date | string
    endDate?: DateTimeNullableFilter<"ProtocolExecution"> | Date | string | null
    parameters?: JsonFilter<"ProtocolExecution">
    adaptations?: JsonNullableFilter<"ProtocolExecution">
    dataClassification?: EnumDataClassificationFilter<"ProtocolExecution"> | $Enums.DataClassification
    retentionUntil?: DateTimeNullableFilter<"ProtocolExecution"> | Date | string | null
    currentBlockId?: StringNullableFilter<"ProtocolExecution"> | string | null
    currentWeek?: IntFilter<"ProtocolExecution"> | number
    progress?: FloatFilter<"ProtocolExecution"> | number
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    domain?: string | null
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    maxUsers?: number
    maxProtocols?: number
    protocols?: ProtocolCreateNestedManyWithoutTenantInput
    executions?: ProtocolExecutionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    domain?: string | null
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    maxUsers?: number
    maxProtocols?: number
    protocols?: ProtocolUncheckedCreateNestedManyWithoutTenantInput
    executions?: ProtocolExecutionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type ProtocolCreateWithoutOwnerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    version?: string
    description?: string | null
    category: string
    difficulty: string
    duration?: number | null
    frequency?: number | null
    visibility?: $Enums.Visibility
    isActive?: boolean
    isPublic?: boolean
    overview?: string | null
    principles?: ProtocolCreateprinciplesInput | string[]
    requirements?: ProtocolCreaterequirementsInput | string[]
    tenant: TenantCreateNestedOneWithoutProtocolsInput
    blocks?: BlockCreateNestedManyWithoutProtocolInput
    templates?: ProtocolTemplateCreateNestedManyWithoutProtocolInput
    executions?: ProtocolExecutionCreateNestedManyWithoutProtocolInput
    permissions?: ProtocolPermissionCreateNestedManyWithoutProtocolInput
    shares?: ProtocolShareCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolUncheckedCreateWithoutOwnerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId: string
    name: string
    version?: string
    description?: string | null
    category: string
    difficulty: string
    duration?: number | null
    frequency?: number | null
    visibility?: $Enums.Visibility
    isActive?: boolean
    isPublic?: boolean
    overview?: string | null
    principles?: ProtocolCreateprinciplesInput | string[]
    requirements?: ProtocolCreaterequirementsInput | string[]
    blocks?: BlockUncheckedCreateNestedManyWithoutProtocolInput
    templates?: ProtocolTemplateUncheckedCreateNestedManyWithoutProtocolInput
    executions?: ProtocolExecutionUncheckedCreateNestedManyWithoutProtocolInput
    permissions?: ProtocolPermissionUncheckedCreateNestedManyWithoutProtocolInput
    shares?: ProtocolShareUncheckedCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolCreateOrConnectWithoutOwnerInput = {
    where: ProtocolWhereUniqueInput
    create: XOR<ProtocolCreateWithoutOwnerInput, ProtocolUncheckedCreateWithoutOwnerInput>
  }

  export type ProtocolCreateManyOwnerInputEnvelope = {
    data: ProtocolCreateManyOwnerInput | ProtocolCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ProtocolExecutionCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId?: string | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    parameters: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: $Enums.DataClassification
    retentionUntil?: Date | string | null
    currentBlockId?: string | null
    currentWeek?: number
    progress?: number
    tenant: TenantCreateNestedOneWithoutExecutionsInput
    protocol: ProtocolCreateNestedOneWithoutExecutionsInput
    blockExecutions?: BlockExecutionCreateNestedManyWithoutExecutionInput
    sessions?: SessionExecutionCreateNestedManyWithoutExecutionInput
  }

  export type ProtocolExecutionUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId: string
    protocolId: string
    templateId?: string | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    parameters: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: $Enums.DataClassification
    retentionUntil?: Date | string | null
    currentBlockId?: string | null
    currentWeek?: number
    progress?: number
    blockExecutions?: BlockExecutionUncheckedCreateNestedManyWithoutExecutionInput
    sessions?: SessionExecutionUncheckedCreateNestedManyWithoutExecutionInput
  }

  export type ProtocolExecutionCreateOrConnectWithoutUserInput = {
    where: ProtocolExecutionWhereUniqueInput
    create: XOR<ProtocolExecutionCreateWithoutUserInput, ProtocolExecutionUncheckedCreateWithoutUserInput>
  }

  export type ProtocolExecutionCreateManyUserInputEnvelope = {
    data: ProtocolExecutionCreateManyUserInput | ProtocolExecutionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProtocolPermissionCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role: $Enums.PermissionRole
    permissions?: ProtocolPermissionCreatepermissionsInput | $Enums.Permission[]
    grantedBy: string
    grantedAt: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
    protocol: ProtocolCreateNestedOneWithoutPermissionsInput
  }

  export type ProtocolPermissionUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    role: $Enums.PermissionRole
    permissions?: ProtocolPermissionCreatepermissionsInput | $Enums.Permission[]
    grantedBy: string
    grantedAt: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type ProtocolPermissionCreateOrConnectWithoutUserInput = {
    where: ProtocolPermissionWhereUniqueInput
    create: XOR<ProtocolPermissionCreateWithoutUserInput, ProtocolPermissionUncheckedCreateWithoutUserInput>
  }

  export type ProtocolPermissionCreateManyUserInputEnvelope = {
    data: ProtocolPermissionCreateManyUserInput | ProtocolPermissionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProtocolShareCreateWithoutSharedByUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: ProtocolShareCreatepermissionsInput | $Enums.Permission[]
    expiresAt?: Date | string | null
    isActive?: boolean
    acceptedAt?: Date | string | null
    protocol: ProtocolCreateNestedOneWithoutSharesInput
    sharedWithUser: UserCreateNestedOneWithoutReceivedProtocolsInput
  }

  export type ProtocolShareUncheckedCreateWithoutSharedByUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    sharedWith: string
    permissions?: ProtocolShareCreatepermissionsInput | $Enums.Permission[]
    expiresAt?: Date | string | null
    isActive?: boolean
    acceptedAt?: Date | string | null
  }

  export type ProtocolShareCreateOrConnectWithoutSharedByUserInput = {
    where: ProtocolShareWhereUniqueInput
    create: XOR<ProtocolShareCreateWithoutSharedByUserInput, ProtocolShareUncheckedCreateWithoutSharedByUserInput>
  }

  export type ProtocolShareCreateManySharedByUserInputEnvelope = {
    data: ProtocolShareCreateManySharedByUserInput | ProtocolShareCreateManySharedByUserInput[]
    skipDuplicates?: boolean
  }

  export type ProtocolShareCreateWithoutSharedWithUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: ProtocolShareCreatepermissionsInput | $Enums.Permission[]
    expiresAt?: Date | string | null
    isActive?: boolean
    acceptedAt?: Date | string | null
    protocol: ProtocolCreateNestedOneWithoutSharesInput
    sharedByUser: UserCreateNestedOneWithoutSharedProtocolsInput
  }

  export type ProtocolShareUncheckedCreateWithoutSharedWithUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    sharedBy: string
    permissions?: ProtocolShareCreatepermissionsInput | $Enums.Permission[]
    expiresAt?: Date | string | null
    isActive?: boolean
    acceptedAt?: Date | string | null
  }

  export type ProtocolShareCreateOrConnectWithoutSharedWithUserInput = {
    where: ProtocolShareWhereUniqueInput
    create: XOR<ProtocolShareCreateWithoutSharedWithUserInput, ProtocolShareUncheckedCreateWithoutSharedWithUserInput>
  }

  export type ProtocolShareCreateManySharedWithUserInputEnvelope = {
    data: ProtocolShareCreateManySharedWithUserInput | ProtocolShareCreateManySharedWithUserInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProtocols?: IntFieldUpdateOperationsInput | number
    protocols?: ProtocolUpdateManyWithoutTenantNestedInput
    executions?: ProtocolExecutionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProtocols?: IntFieldUpdateOperationsInput | number
    protocols?: ProtocolUncheckedUpdateManyWithoutTenantNestedInput
    executions?: ProtocolExecutionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ProtocolUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ProtocolWhereUniqueInput
    update: XOR<ProtocolUpdateWithoutOwnerInput, ProtocolUncheckedUpdateWithoutOwnerInput>
    create: XOR<ProtocolCreateWithoutOwnerInput, ProtocolUncheckedCreateWithoutOwnerInput>
  }

  export type ProtocolUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ProtocolWhereUniqueInput
    data: XOR<ProtocolUpdateWithoutOwnerInput, ProtocolUncheckedUpdateWithoutOwnerInput>
  }

  export type ProtocolUpdateManyWithWhereWithoutOwnerInput = {
    where: ProtocolScalarWhereInput
    data: XOR<ProtocolUpdateManyMutationInput, ProtocolUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ProtocolExecutionUpsertWithWhereUniqueWithoutUserInput = {
    where: ProtocolExecutionWhereUniqueInput
    update: XOR<ProtocolExecutionUpdateWithoutUserInput, ProtocolExecutionUncheckedUpdateWithoutUserInput>
    create: XOR<ProtocolExecutionCreateWithoutUserInput, ProtocolExecutionUncheckedCreateWithoutUserInput>
  }

  export type ProtocolExecutionUpdateWithWhereUniqueWithoutUserInput = {
    where: ProtocolExecutionWhereUniqueInput
    data: XOR<ProtocolExecutionUpdateWithoutUserInput, ProtocolExecutionUncheckedUpdateWithoutUserInput>
  }

  export type ProtocolExecutionUpdateManyWithWhereWithoutUserInput = {
    where: ProtocolExecutionScalarWhereInput
    data: XOR<ProtocolExecutionUpdateManyMutationInput, ProtocolExecutionUncheckedUpdateManyWithoutUserInput>
  }

  export type ProtocolPermissionUpsertWithWhereUniqueWithoutUserInput = {
    where: ProtocolPermissionWhereUniqueInput
    update: XOR<ProtocolPermissionUpdateWithoutUserInput, ProtocolPermissionUncheckedUpdateWithoutUserInput>
    create: XOR<ProtocolPermissionCreateWithoutUserInput, ProtocolPermissionUncheckedCreateWithoutUserInput>
  }

  export type ProtocolPermissionUpdateWithWhereUniqueWithoutUserInput = {
    where: ProtocolPermissionWhereUniqueInput
    data: XOR<ProtocolPermissionUpdateWithoutUserInput, ProtocolPermissionUncheckedUpdateWithoutUserInput>
  }

  export type ProtocolPermissionUpdateManyWithWhereWithoutUserInput = {
    where: ProtocolPermissionScalarWhereInput
    data: XOR<ProtocolPermissionUpdateManyMutationInput, ProtocolPermissionUncheckedUpdateManyWithoutUserInput>
  }

  export type ProtocolPermissionScalarWhereInput = {
    AND?: ProtocolPermissionScalarWhereInput | ProtocolPermissionScalarWhereInput[]
    OR?: ProtocolPermissionScalarWhereInput[]
    NOT?: ProtocolPermissionScalarWhereInput | ProtocolPermissionScalarWhereInput[]
    id?: StringFilter<"ProtocolPermission"> | string
    createdAt?: DateTimeFilter<"ProtocolPermission"> | Date | string
    updatedAt?: DateTimeFilter<"ProtocolPermission"> | Date | string
    protocolId?: StringFilter<"ProtocolPermission"> | string
    userId?: StringFilter<"ProtocolPermission"> | string
    role?: EnumPermissionRoleFilter<"ProtocolPermission"> | $Enums.PermissionRole
    permissions?: EnumPermissionNullableListFilter<"ProtocolPermission">
    grantedBy?: StringFilter<"ProtocolPermission"> | string
    grantedAt?: DateTimeFilter<"ProtocolPermission"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ProtocolPermission"> | Date | string | null
    isActive?: BoolFilter<"ProtocolPermission"> | boolean
  }

  export type ProtocolShareUpsertWithWhereUniqueWithoutSharedByUserInput = {
    where: ProtocolShareWhereUniqueInput
    update: XOR<ProtocolShareUpdateWithoutSharedByUserInput, ProtocolShareUncheckedUpdateWithoutSharedByUserInput>
    create: XOR<ProtocolShareCreateWithoutSharedByUserInput, ProtocolShareUncheckedCreateWithoutSharedByUserInput>
  }

  export type ProtocolShareUpdateWithWhereUniqueWithoutSharedByUserInput = {
    where: ProtocolShareWhereUniqueInput
    data: XOR<ProtocolShareUpdateWithoutSharedByUserInput, ProtocolShareUncheckedUpdateWithoutSharedByUserInput>
  }

  export type ProtocolShareUpdateManyWithWhereWithoutSharedByUserInput = {
    where: ProtocolShareScalarWhereInput
    data: XOR<ProtocolShareUpdateManyMutationInput, ProtocolShareUncheckedUpdateManyWithoutSharedByUserInput>
  }

  export type ProtocolShareScalarWhereInput = {
    AND?: ProtocolShareScalarWhereInput | ProtocolShareScalarWhereInput[]
    OR?: ProtocolShareScalarWhereInput[]
    NOT?: ProtocolShareScalarWhereInput | ProtocolShareScalarWhereInput[]
    id?: StringFilter<"ProtocolShare"> | string
    createdAt?: DateTimeFilter<"ProtocolShare"> | Date | string
    updatedAt?: DateTimeFilter<"ProtocolShare"> | Date | string
    protocolId?: StringFilter<"ProtocolShare"> | string
    sharedBy?: StringFilter<"ProtocolShare"> | string
    sharedWith?: StringFilter<"ProtocolShare"> | string
    permissions?: EnumPermissionNullableListFilter<"ProtocolShare">
    expiresAt?: DateTimeNullableFilter<"ProtocolShare"> | Date | string | null
    isActive?: BoolFilter<"ProtocolShare"> | boolean
    acceptedAt?: DateTimeNullableFilter<"ProtocolShare"> | Date | string | null
  }

  export type ProtocolShareUpsertWithWhereUniqueWithoutSharedWithUserInput = {
    where: ProtocolShareWhereUniqueInput
    update: XOR<ProtocolShareUpdateWithoutSharedWithUserInput, ProtocolShareUncheckedUpdateWithoutSharedWithUserInput>
    create: XOR<ProtocolShareCreateWithoutSharedWithUserInput, ProtocolShareUncheckedCreateWithoutSharedWithUserInput>
  }

  export type ProtocolShareUpdateWithWhereUniqueWithoutSharedWithUserInput = {
    where: ProtocolShareWhereUniqueInput
    data: XOR<ProtocolShareUpdateWithoutSharedWithUserInput, ProtocolShareUncheckedUpdateWithoutSharedWithUserInput>
  }

  export type ProtocolShareUpdateManyWithWhereWithoutSharedWithUserInput = {
    where: ProtocolShareScalarWhereInput
    data: XOR<ProtocolShareUpdateManyMutationInput, ProtocolShareUncheckedUpdateManyWithoutSharedWithUserInput>
  }

  export type TenantCreateWithoutProtocolsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    domain?: string | null
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    maxUsers?: number
    maxProtocols?: number
    users?: UserCreateNestedManyWithoutTenantInput
    executions?: ProtocolExecutionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutProtocolsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    domain?: string | null
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    maxUsers?: number
    maxProtocols?: number
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    executions?: ProtocolExecutionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutProtocolsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutProtocolsInput, TenantUncheckedCreateWithoutProtocolsInput>
  }

  export type UserCreateWithoutProtocolsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutUsersInput
    executions?: ProtocolExecutionCreateNestedManyWithoutUserInput
    permissions?: ProtocolPermissionCreateNestedManyWithoutUserInput
    sharedProtocols?: ProtocolShareCreateNestedManyWithoutSharedByUserInput
    receivedProtocols?: ProtocolShareCreateNestedManyWithoutSharedWithUserInput
  }

  export type UserUncheckedCreateWithoutProtocolsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name?: string | null
    tenantId: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    executions?: ProtocolExecutionUncheckedCreateNestedManyWithoutUserInput
    permissions?: ProtocolPermissionUncheckedCreateNestedManyWithoutUserInput
    sharedProtocols?: ProtocolShareUncheckedCreateNestedManyWithoutSharedByUserInput
    receivedProtocols?: ProtocolShareUncheckedCreateNestedManyWithoutSharedWithUserInput
  }

  export type UserCreateOrConnectWithoutProtocolsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProtocolsInput, UserUncheckedCreateWithoutProtocolsInput>
  }

  export type BlockCreateWithoutProtocolInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    order: number
    duration: number
    phase: string
    intensity: string
    volume: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    sessions?: BlockSessionCreateNestedManyWithoutBlockInput
    progressions?: BlockProgressionCreateNestedManyWithoutBlockInput
    executions?: BlockExecutionCreateNestedManyWithoutBlockInput
  }

  export type BlockUncheckedCreateWithoutProtocolInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    order: number
    duration: number
    phase: string
    intensity: string
    volume: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    sessions?: BlockSessionUncheckedCreateNestedManyWithoutBlockInput
    progressions?: BlockProgressionUncheckedCreateNestedManyWithoutBlockInput
    executions?: BlockExecutionUncheckedCreateNestedManyWithoutBlockInput
  }

  export type BlockCreateOrConnectWithoutProtocolInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutProtocolInput, BlockUncheckedCreateWithoutProtocolInput>
  }

  export type BlockCreateManyProtocolInputEnvelope = {
    data: BlockCreateManyProtocolInput | BlockCreateManyProtocolInput[]
    skipDuplicates?: boolean
  }

  export type ProtocolTemplateCreateWithoutProtocolInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    parameters: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    usageCount?: number
  }

  export type ProtocolTemplateUncheckedCreateWithoutProtocolInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    parameters: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    usageCount?: number
  }

  export type ProtocolTemplateCreateOrConnectWithoutProtocolInput = {
    where: ProtocolTemplateWhereUniqueInput
    create: XOR<ProtocolTemplateCreateWithoutProtocolInput, ProtocolTemplateUncheckedCreateWithoutProtocolInput>
  }

  export type ProtocolTemplateCreateManyProtocolInputEnvelope = {
    data: ProtocolTemplateCreateManyProtocolInput | ProtocolTemplateCreateManyProtocolInput[]
    skipDuplicates?: boolean
  }

  export type ProtocolExecutionCreateWithoutProtocolInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId?: string | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    parameters: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: $Enums.DataClassification
    retentionUntil?: Date | string | null
    currentBlockId?: string | null
    currentWeek?: number
    progress?: number
    tenant: TenantCreateNestedOneWithoutExecutionsInput
    user: UserCreateNestedOneWithoutExecutionsInput
    blockExecutions?: BlockExecutionCreateNestedManyWithoutExecutionInput
    sessions?: SessionExecutionCreateNestedManyWithoutExecutionInput
  }

  export type ProtocolExecutionUncheckedCreateWithoutProtocolInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId: string
    userId: string
    templateId?: string | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    parameters: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: $Enums.DataClassification
    retentionUntil?: Date | string | null
    currentBlockId?: string | null
    currentWeek?: number
    progress?: number
    blockExecutions?: BlockExecutionUncheckedCreateNestedManyWithoutExecutionInput
    sessions?: SessionExecutionUncheckedCreateNestedManyWithoutExecutionInput
  }

  export type ProtocolExecutionCreateOrConnectWithoutProtocolInput = {
    where: ProtocolExecutionWhereUniqueInput
    create: XOR<ProtocolExecutionCreateWithoutProtocolInput, ProtocolExecutionUncheckedCreateWithoutProtocolInput>
  }

  export type ProtocolExecutionCreateManyProtocolInputEnvelope = {
    data: ProtocolExecutionCreateManyProtocolInput | ProtocolExecutionCreateManyProtocolInput[]
    skipDuplicates?: boolean
  }

  export type ProtocolPermissionCreateWithoutProtocolInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role: $Enums.PermissionRole
    permissions?: ProtocolPermissionCreatepermissionsInput | $Enums.Permission[]
    grantedBy: string
    grantedAt: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
    user: UserCreateNestedOneWithoutPermissionsInput
  }

  export type ProtocolPermissionUncheckedCreateWithoutProtocolInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    role: $Enums.PermissionRole
    permissions?: ProtocolPermissionCreatepermissionsInput | $Enums.Permission[]
    grantedBy: string
    grantedAt: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type ProtocolPermissionCreateOrConnectWithoutProtocolInput = {
    where: ProtocolPermissionWhereUniqueInput
    create: XOR<ProtocolPermissionCreateWithoutProtocolInput, ProtocolPermissionUncheckedCreateWithoutProtocolInput>
  }

  export type ProtocolPermissionCreateManyProtocolInputEnvelope = {
    data: ProtocolPermissionCreateManyProtocolInput | ProtocolPermissionCreateManyProtocolInput[]
    skipDuplicates?: boolean
  }

  export type ProtocolShareCreateWithoutProtocolInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: ProtocolShareCreatepermissionsInput | $Enums.Permission[]
    expiresAt?: Date | string | null
    isActive?: boolean
    acceptedAt?: Date | string | null
    sharedByUser: UserCreateNestedOneWithoutSharedProtocolsInput
    sharedWithUser: UserCreateNestedOneWithoutReceivedProtocolsInput
  }

  export type ProtocolShareUncheckedCreateWithoutProtocolInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sharedBy: string
    sharedWith: string
    permissions?: ProtocolShareCreatepermissionsInput | $Enums.Permission[]
    expiresAt?: Date | string | null
    isActive?: boolean
    acceptedAt?: Date | string | null
  }

  export type ProtocolShareCreateOrConnectWithoutProtocolInput = {
    where: ProtocolShareWhereUniqueInput
    create: XOR<ProtocolShareCreateWithoutProtocolInput, ProtocolShareUncheckedCreateWithoutProtocolInput>
  }

  export type ProtocolShareCreateManyProtocolInputEnvelope = {
    data: ProtocolShareCreateManyProtocolInput | ProtocolShareCreateManyProtocolInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutProtocolsInput = {
    update: XOR<TenantUpdateWithoutProtocolsInput, TenantUncheckedUpdateWithoutProtocolsInput>
    create: XOR<TenantCreateWithoutProtocolsInput, TenantUncheckedCreateWithoutProtocolsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutProtocolsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutProtocolsInput, TenantUncheckedUpdateWithoutProtocolsInput>
  }

  export type TenantUpdateWithoutProtocolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProtocols?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutTenantNestedInput
    executions?: ProtocolExecutionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutProtocolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProtocols?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    executions?: ProtocolExecutionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutProtocolsInput = {
    update: XOR<UserUpdateWithoutProtocolsInput, UserUncheckedUpdateWithoutProtocolsInput>
    create: XOR<UserCreateWithoutProtocolsInput, UserUncheckedCreateWithoutProtocolsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProtocolsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProtocolsInput, UserUncheckedUpdateWithoutProtocolsInput>
  }

  export type UserUpdateWithoutProtocolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    executions?: ProtocolExecutionUpdateManyWithoutUserNestedInput
    permissions?: ProtocolPermissionUpdateManyWithoutUserNestedInput
    sharedProtocols?: ProtocolShareUpdateManyWithoutSharedByUserNestedInput
    receivedProtocols?: ProtocolShareUpdateManyWithoutSharedWithUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProtocolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executions?: ProtocolExecutionUncheckedUpdateManyWithoutUserNestedInput
    permissions?: ProtocolPermissionUncheckedUpdateManyWithoutUserNestedInput
    sharedProtocols?: ProtocolShareUncheckedUpdateManyWithoutSharedByUserNestedInput
    receivedProtocols?: ProtocolShareUncheckedUpdateManyWithoutSharedWithUserNestedInput
  }

  export type BlockUpsertWithWhereUniqueWithoutProtocolInput = {
    where: BlockWhereUniqueInput
    update: XOR<BlockUpdateWithoutProtocolInput, BlockUncheckedUpdateWithoutProtocolInput>
    create: XOR<BlockCreateWithoutProtocolInput, BlockUncheckedCreateWithoutProtocolInput>
  }

  export type BlockUpdateWithWhereUniqueWithoutProtocolInput = {
    where: BlockWhereUniqueInput
    data: XOR<BlockUpdateWithoutProtocolInput, BlockUncheckedUpdateWithoutProtocolInput>
  }

  export type BlockUpdateManyWithWhereWithoutProtocolInput = {
    where: BlockScalarWhereInput
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutProtocolInput>
  }

  export type BlockScalarWhereInput = {
    AND?: BlockScalarWhereInput | BlockScalarWhereInput[]
    OR?: BlockScalarWhereInput[]
    NOT?: BlockScalarWhereInput | BlockScalarWhereInput[]
    id?: StringFilter<"Block"> | string
    createdAt?: DateTimeFilter<"Block"> | Date | string
    updatedAt?: DateTimeFilter<"Block"> | Date | string
    protocolId?: StringFilter<"Block"> | string
    name?: StringFilter<"Block"> | string
    description?: StringNullableFilter<"Block"> | string | null
    order?: IntFilter<"Block"> | number
    duration?: IntFilter<"Block"> | number
    phase?: StringFilter<"Block"> | string
    intensity?: StringFilter<"Block"> | string
    volume?: StringFilter<"Block"> | string
    parameters?: JsonNullableFilter<"Block">
    rules?: JsonNullableFilter<"Block">
  }

  export type ProtocolTemplateUpsertWithWhereUniqueWithoutProtocolInput = {
    where: ProtocolTemplateWhereUniqueInput
    update: XOR<ProtocolTemplateUpdateWithoutProtocolInput, ProtocolTemplateUncheckedUpdateWithoutProtocolInput>
    create: XOR<ProtocolTemplateCreateWithoutProtocolInput, ProtocolTemplateUncheckedCreateWithoutProtocolInput>
  }

  export type ProtocolTemplateUpdateWithWhereUniqueWithoutProtocolInput = {
    where: ProtocolTemplateWhereUniqueInput
    data: XOR<ProtocolTemplateUpdateWithoutProtocolInput, ProtocolTemplateUncheckedUpdateWithoutProtocolInput>
  }

  export type ProtocolTemplateUpdateManyWithWhereWithoutProtocolInput = {
    where: ProtocolTemplateScalarWhereInput
    data: XOR<ProtocolTemplateUpdateManyMutationInput, ProtocolTemplateUncheckedUpdateManyWithoutProtocolInput>
  }

  export type ProtocolTemplateScalarWhereInput = {
    AND?: ProtocolTemplateScalarWhereInput | ProtocolTemplateScalarWhereInput[]
    OR?: ProtocolTemplateScalarWhereInput[]
    NOT?: ProtocolTemplateScalarWhereInput | ProtocolTemplateScalarWhereInput[]
    id?: StringFilter<"ProtocolTemplate"> | string
    createdAt?: DateTimeFilter<"ProtocolTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ProtocolTemplate"> | Date | string
    protocolId?: StringFilter<"ProtocolTemplate"> | string
    name?: StringFilter<"ProtocolTemplate"> | string
    description?: StringNullableFilter<"ProtocolTemplate"> | string | null
    parameters?: JsonFilter<"ProtocolTemplate">
    isDefault?: BoolFilter<"ProtocolTemplate"> | boolean
    usageCount?: IntFilter<"ProtocolTemplate"> | number
  }

  export type ProtocolExecutionUpsertWithWhereUniqueWithoutProtocolInput = {
    where: ProtocolExecutionWhereUniqueInput
    update: XOR<ProtocolExecutionUpdateWithoutProtocolInput, ProtocolExecutionUncheckedUpdateWithoutProtocolInput>
    create: XOR<ProtocolExecutionCreateWithoutProtocolInput, ProtocolExecutionUncheckedCreateWithoutProtocolInput>
  }

  export type ProtocolExecutionUpdateWithWhereUniqueWithoutProtocolInput = {
    where: ProtocolExecutionWhereUniqueInput
    data: XOR<ProtocolExecutionUpdateWithoutProtocolInput, ProtocolExecutionUncheckedUpdateWithoutProtocolInput>
  }

  export type ProtocolExecutionUpdateManyWithWhereWithoutProtocolInput = {
    where: ProtocolExecutionScalarWhereInput
    data: XOR<ProtocolExecutionUpdateManyMutationInput, ProtocolExecutionUncheckedUpdateManyWithoutProtocolInput>
  }

  export type ProtocolPermissionUpsertWithWhereUniqueWithoutProtocolInput = {
    where: ProtocolPermissionWhereUniqueInput
    update: XOR<ProtocolPermissionUpdateWithoutProtocolInput, ProtocolPermissionUncheckedUpdateWithoutProtocolInput>
    create: XOR<ProtocolPermissionCreateWithoutProtocolInput, ProtocolPermissionUncheckedCreateWithoutProtocolInput>
  }

  export type ProtocolPermissionUpdateWithWhereUniqueWithoutProtocolInput = {
    where: ProtocolPermissionWhereUniqueInput
    data: XOR<ProtocolPermissionUpdateWithoutProtocolInput, ProtocolPermissionUncheckedUpdateWithoutProtocolInput>
  }

  export type ProtocolPermissionUpdateManyWithWhereWithoutProtocolInput = {
    where: ProtocolPermissionScalarWhereInput
    data: XOR<ProtocolPermissionUpdateManyMutationInput, ProtocolPermissionUncheckedUpdateManyWithoutProtocolInput>
  }

  export type ProtocolShareUpsertWithWhereUniqueWithoutProtocolInput = {
    where: ProtocolShareWhereUniqueInput
    update: XOR<ProtocolShareUpdateWithoutProtocolInput, ProtocolShareUncheckedUpdateWithoutProtocolInput>
    create: XOR<ProtocolShareCreateWithoutProtocolInput, ProtocolShareUncheckedCreateWithoutProtocolInput>
  }

  export type ProtocolShareUpdateWithWhereUniqueWithoutProtocolInput = {
    where: ProtocolShareWhereUniqueInput
    data: XOR<ProtocolShareUpdateWithoutProtocolInput, ProtocolShareUncheckedUpdateWithoutProtocolInput>
  }

  export type ProtocolShareUpdateManyWithWhereWithoutProtocolInput = {
    where: ProtocolShareScalarWhereInput
    data: XOR<ProtocolShareUpdateManyMutationInput, ProtocolShareUncheckedUpdateManyWithoutProtocolInput>
  }

  export type ProtocolCreateWithoutBlocksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    version?: string
    description?: string | null
    category: string
    difficulty: string
    duration?: number | null
    frequency?: number | null
    visibility?: $Enums.Visibility
    isActive?: boolean
    isPublic?: boolean
    overview?: string | null
    principles?: ProtocolCreateprinciplesInput | string[]
    requirements?: ProtocolCreaterequirementsInput | string[]
    tenant: TenantCreateNestedOneWithoutProtocolsInput
    owner: UserCreateNestedOneWithoutProtocolsInput
    templates?: ProtocolTemplateCreateNestedManyWithoutProtocolInput
    executions?: ProtocolExecutionCreateNestedManyWithoutProtocolInput
    permissions?: ProtocolPermissionCreateNestedManyWithoutProtocolInput
    shares?: ProtocolShareCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolUncheckedCreateWithoutBlocksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId: string
    name: string
    version?: string
    description?: string | null
    category: string
    difficulty: string
    duration?: number | null
    frequency?: number | null
    ownerId: string
    visibility?: $Enums.Visibility
    isActive?: boolean
    isPublic?: boolean
    overview?: string | null
    principles?: ProtocolCreateprinciplesInput | string[]
    requirements?: ProtocolCreaterequirementsInput | string[]
    templates?: ProtocolTemplateUncheckedCreateNestedManyWithoutProtocolInput
    executions?: ProtocolExecutionUncheckedCreateNestedManyWithoutProtocolInput
    permissions?: ProtocolPermissionUncheckedCreateNestedManyWithoutProtocolInput
    shares?: ProtocolShareUncheckedCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolCreateOrConnectWithoutBlocksInput = {
    where: ProtocolWhereUniqueInput
    create: XOR<ProtocolCreateWithoutBlocksInput, ProtocolUncheckedCreateWithoutBlocksInput>
  }

  export type BlockSessionCreateWithoutBlockInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    dayOfWeek: number
    order: number
    exercises: JsonNullValueInput | InputJsonValue
    duration?: number | null
    notes?: string | null
    intensity?: number | null
    volume?: number | null
    rpe?: number | null
  }

  export type BlockSessionUncheckedCreateWithoutBlockInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    dayOfWeek: number
    order: number
    exercises: JsonNullValueInput | InputJsonValue
    duration?: number | null
    notes?: string | null
    intensity?: number | null
    volume?: number | null
    rpe?: number | null
  }

  export type BlockSessionCreateOrConnectWithoutBlockInput = {
    where: BlockSessionWhereUniqueInput
    create: XOR<BlockSessionCreateWithoutBlockInput, BlockSessionUncheckedCreateWithoutBlockInput>
  }

  export type BlockSessionCreateManyBlockInputEnvelope = {
    data: BlockSessionCreateManyBlockInput | BlockSessionCreateManyBlockInput[]
    skipDuplicates?: boolean
  }

  export type BlockProgressionCreateWithoutBlockInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    week: number
    parameters: JsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    triggers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BlockProgressionUncheckedCreateWithoutBlockInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    week: number
    parameters: JsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    triggers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BlockProgressionCreateOrConnectWithoutBlockInput = {
    where: BlockProgressionWhereUniqueInput
    create: XOR<BlockProgressionCreateWithoutBlockInput, BlockProgressionUncheckedCreateWithoutBlockInput>
  }

  export type BlockProgressionCreateManyBlockInputEnvelope = {
    data: BlockProgressionCreateManyBlockInput | BlockProgressionCreateManyBlockInput[]
    skipDuplicates?: boolean
  }

  export type BlockExecutionCreateWithoutBlockInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    currentWeek?: number
    progress?: number
    execution: ProtocolExecutionCreateNestedOneWithoutBlockExecutionsInput
  }

  export type BlockExecutionUncheckedCreateWithoutBlockInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executionId: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    currentWeek?: number
    progress?: number
  }

  export type BlockExecutionCreateOrConnectWithoutBlockInput = {
    where: BlockExecutionWhereUniqueInput
    create: XOR<BlockExecutionCreateWithoutBlockInput, BlockExecutionUncheckedCreateWithoutBlockInput>
  }

  export type BlockExecutionCreateManyBlockInputEnvelope = {
    data: BlockExecutionCreateManyBlockInput | BlockExecutionCreateManyBlockInput[]
    skipDuplicates?: boolean
  }

  export type ProtocolUpsertWithoutBlocksInput = {
    update: XOR<ProtocolUpdateWithoutBlocksInput, ProtocolUncheckedUpdateWithoutBlocksInput>
    create: XOR<ProtocolCreateWithoutBlocksInput, ProtocolUncheckedCreateWithoutBlocksInput>
    where?: ProtocolWhereInput
  }

  export type ProtocolUpdateToOneWithWhereWithoutBlocksInput = {
    where?: ProtocolWhereInput
    data: XOR<ProtocolUpdateWithoutBlocksInput, ProtocolUncheckedUpdateWithoutBlocksInput>
  }

  export type ProtocolUpdateWithoutBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    principles?: ProtocolUpdateprinciplesInput | string[]
    requirements?: ProtocolUpdaterequirementsInput | string[]
    tenant?: TenantUpdateOneRequiredWithoutProtocolsNestedInput
    owner?: UserUpdateOneRequiredWithoutProtocolsNestedInput
    templates?: ProtocolTemplateUpdateManyWithoutProtocolNestedInput
    executions?: ProtocolExecutionUpdateManyWithoutProtocolNestedInput
    permissions?: ProtocolPermissionUpdateManyWithoutProtocolNestedInput
    shares?: ProtocolShareUpdateManyWithoutProtocolNestedInput
  }

  export type ProtocolUncheckedUpdateWithoutBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    principles?: ProtocolUpdateprinciplesInput | string[]
    requirements?: ProtocolUpdaterequirementsInput | string[]
    templates?: ProtocolTemplateUncheckedUpdateManyWithoutProtocolNestedInput
    executions?: ProtocolExecutionUncheckedUpdateManyWithoutProtocolNestedInput
    permissions?: ProtocolPermissionUncheckedUpdateManyWithoutProtocolNestedInput
    shares?: ProtocolShareUncheckedUpdateManyWithoutProtocolNestedInput
  }

  export type BlockSessionUpsertWithWhereUniqueWithoutBlockInput = {
    where: BlockSessionWhereUniqueInput
    update: XOR<BlockSessionUpdateWithoutBlockInput, BlockSessionUncheckedUpdateWithoutBlockInput>
    create: XOR<BlockSessionCreateWithoutBlockInput, BlockSessionUncheckedCreateWithoutBlockInput>
  }

  export type BlockSessionUpdateWithWhereUniqueWithoutBlockInput = {
    where: BlockSessionWhereUniqueInput
    data: XOR<BlockSessionUpdateWithoutBlockInput, BlockSessionUncheckedUpdateWithoutBlockInput>
  }

  export type BlockSessionUpdateManyWithWhereWithoutBlockInput = {
    where: BlockSessionScalarWhereInput
    data: XOR<BlockSessionUpdateManyMutationInput, BlockSessionUncheckedUpdateManyWithoutBlockInput>
  }

  export type BlockSessionScalarWhereInput = {
    AND?: BlockSessionScalarWhereInput | BlockSessionScalarWhereInput[]
    OR?: BlockSessionScalarWhereInput[]
    NOT?: BlockSessionScalarWhereInput | BlockSessionScalarWhereInput[]
    id?: StringFilter<"BlockSession"> | string
    createdAt?: DateTimeFilter<"BlockSession"> | Date | string
    updatedAt?: DateTimeFilter<"BlockSession"> | Date | string
    blockId?: StringFilter<"BlockSession"> | string
    name?: StringFilter<"BlockSession"> | string
    dayOfWeek?: IntFilter<"BlockSession"> | number
    order?: IntFilter<"BlockSession"> | number
    exercises?: JsonFilter<"BlockSession">
    duration?: IntNullableFilter<"BlockSession"> | number | null
    notes?: StringNullableFilter<"BlockSession"> | string | null
    intensity?: FloatNullableFilter<"BlockSession"> | number | null
    volume?: FloatNullableFilter<"BlockSession"> | number | null
    rpe?: FloatNullableFilter<"BlockSession"> | number | null
  }

  export type BlockProgressionUpsertWithWhereUniqueWithoutBlockInput = {
    where: BlockProgressionWhereUniqueInput
    update: XOR<BlockProgressionUpdateWithoutBlockInput, BlockProgressionUncheckedUpdateWithoutBlockInput>
    create: XOR<BlockProgressionCreateWithoutBlockInput, BlockProgressionUncheckedCreateWithoutBlockInput>
  }

  export type BlockProgressionUpdateWithWhereUniqueWithoutBlockInput = {
    where: BlockProgressionWhereUniqueInput
    data: XOR<BlockProgressionUpdateWithoutBlockInput, BlockProgressionUncheckedUpdateWithoutBlockInput>
  }

  export type BlockProgressionUpdateManyWithWhereWithoutBlockInput = {
    where: BlockProgressionScalarWhereInput
    data: XOR<BlockProgressionUpdateManyMutationInput, BlockProgressionUncheckedUpdateManyWithoutBlockInput>
  }

  export type BlockProgressionScalarWhereInput = {
    AND?: BlockProgressionScalarWhereInput | BlockProgressionScalarWhereInput[]
    OR?: BlockProgressionScalarWhereInput[]
    NOT?: BlockProgressionScalarWhereInput | BlockProgressionScalarWhereInput[]
    id?: StringFilter<"BlockProgression"> | string
    createdAt?: DateTimeFilter<"BlockProgression"> | Date | string
    updatedAt?: DateTimeFilter<"BlockProgression"> | Date | string
    blockId?: StringFilter<"BlockProgression"> | string
    week?: IntFilter<"BlockProgression"> | number
    parameters?: JsonFilter<"BlockProgression">
    rules?: JsonNullableFilter<"BlockProgression">
    triggers?: JsonNullableFilter<"BlockProgression">
  }

  export type BlockExecutionUpsertWithWhereUniqueWithoutBlockInput = {
    where: BlockExecutionWhereUniqueInput
    update: XOR<BlockExecutionUpdateWithoutBlockInput, BlockExecutionUncheckedUpdateWithoutBlockInput>
    create: XOR<BlockExecutionCreateWithoutBlockInput, BlockExecutionUncheckedCreateWithoutBlockInput>
  }

  export type BlockExecutionUpdateWithWhereUniqueWithoutBlockInput = {
    where: BlockExecutionWhereUniqueInput
    data: XOR<BlockExecutionUpdateWithoutBlockInput, BlockExecutionUncheckedUpdateWithoutBlockInput>
  }

  export type BlockExecutionUpdateManyWithWhereWithoutBlockInput = {
    where: BlockExecutionScalarWhereInput
    data: XOR<BlockExecutionUpdateManyMutationInput, BlockExecutionUncheckedUpdateManyWithoutBlockInput>
  }

  export type BlockExecutionScalarWhereInput = {
    AND?: BlockExecutionScalarWhereInput | BlockExecutionScalarWhereInput[]
    OR?: BlockExecutionScalarWhereInput[]
    NOT?: BlockExecutionScalarWhereInput | BlockExecutionScalarWhereInput[]
    id?: StringFilter<"BlockExecution"> | string
    createdAt?: DateTimeFilter<"BlockExecution"> | Date | string
    updatedAt?: DateTimeFilter<"BlockExecution"> | Date | string
    executionId?: StringFilter<"BlockExecution"> | string
    blockId?: StringFilter<"BlockExecution"> | string
    status?: StringFilter<"BlockExecution"> | string
    startDate?: DateTimeNullableFilter<"BlockExecution"> | Date | string | null
    endDate?: DateTimeNullableFilter<"BlockExecution"> | Date | string | null
    adaptations?: JsonNullableFilter<"BlockExecution">
    notes?: StringNullableFilter<"BlockExecution"> | string | null
    currentWeek?: IntFilter<"BlockExecution"> | number
    progress?: FloatFilter<"BlockExecution"> | number
  }

  export type BlockCreateWithoutSessionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    order: number
    duration: number
    phase: string
    intensity: string
    volume: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    protocol: ProtocolCreateNestedOneWithoutBlocksInput
    progressions?: BlockProgressionCreateNestedManyWithoutBlockInput
    executions?: BlockExecutionCreateNestedManyWithoutBlockInput
  }

  export type BlockUncheckedCreateWithoutSessionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    name: string
    description?: string | null
    order: number
    duration: number
    phase: string
    intensity: string
    volume: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    progressions?: BlockProgressionUncheckedCreateNestedManyWithoutBlockInput
    executions?: BlockExecutionUncheckedCreateNestedManyWithoutBlockInput
  }

  export type BlockCreateOrConnectWithoutSessionsInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutSessionsInput, BlockUncheckedCreateWithoutSessionsInput>
  }

  export type BlockUpsertWithoutSessionsInput = {
    update: XOR<BlockUpdateWithoutSessionsInput, BlockUncheckedUpdateWithoutSessionsInput>
    create: XOR<BlockCreateWithoutSessionsInput, BlockUncheckedCreateWithoutSessionsInput>
    where?: BlockWhereInput
  }

  export type BlockUpdateToOneWithWhereWithoutSessionsInput = {
    where?: BlockWhereInput
    data: XOR<BlockUpdateWithoutSessionsInput, BlockUncheckedUpdateWithoutSessionsInput>
  }

  export type BlockUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    intensity?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    protocol?: ProtocolUpdateOneRequiredWithoutBlocksNestedInput
    progressions?: BlockProgressionUpdateManyWithoutBlockNestedInput
    executions?: BlockExecutionUpdateManyWithoutBlockNestedInput
  }

  export type BlockUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    intensity?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    progressions?: BlockProgressionUncheckedUpdateManyWithoutBlockNestedInput
    executions?: BlockExecutionUncheckedUpdateManyWithoutBlockNestedInput
  }

  export type BlockCreateWithoutProgressionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    order: number
    duration: number
    phase: string
    intensity: string
    volume: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    protocol: ProtocolCreateNestedOneWithoutBlocksInput
    sessions?: BlockSessionCreateNestedManyWithoutBlockInput
    executions?: BlockExecutionCreateNestedManyWithoutBlockInput
  }

  export type BlockUncheckedCreateWithoutProgressionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    name: string
    description?: string | null
    order: number
    duration: number
    phase: string
    intensity: string
    volume: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    sessions?: BlockSessionUncheckedCreateNestedManyWithoutBlockInput
    executions?: BlockExecutionUncheckedCreateNestedManyWithoutBlockInput
  }

  export type BlockCreateOrConnectWithoutProgressionsInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutProgressionsInput, BlockUncheckedCreateWithoutProgressionsInput>
  }

  export type BlockUpsertWithoutProgressionsInput = {
    update: XOR<BlockUpdateWithoutProgressionsInput, BlockUncheckedUpdateWithoutProgressionsInput>
    create: XOR<BlockCreateWithoutProgressionsInput, BlockUncheckedCreateWithoutProgressionsInput>
    where?: BlockWhereInput
  }

  export type BlockUpdateToOneWithWhereWithoutProgressionsInput = {
    where?: BlockWhereInput
    data: XOR<BlockUpdateWithoutProgressionsInput, BlockUncheckedUpdateWithoutProgressionsInput>
  }

  export type BlockUpdateWithoutProgressionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    intensity?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    protocol?: ProtocolUpdateOneRequiredWithoutBlocksNestedInput
    sessions?: BlockSessionUpdateManyWithoutBlockNestedInput
    executions?: BlockExecutionUpdateManyWithoutBlockNestedInput
  }

  export type BlockUncheckedUpdateWithoutProgressionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    intensity?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    sessions?: BlockSessionUncheckedUpdateManyWithoutBlockNestedInput
    executions?: BlockExecutionUncheckedUpdateManyWithoutBlockNestedInput
  }

  export type ProtocolCreateWithoutPermissionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    version?: string
    description?: string | null
    category: string
    difficulty: string
    duration?: number | null
    frequency?: number | null
    visibility?: $Enums.Visibility
    isActive?: boolean
    isPublic?: boolean
    overview?: string | null
    principles?: ProtocolCreateprinciplesInput | string[]
    requirements?: ProtocolCreaterequirementsInput | string[]
    tenant: TenantCreateNestedOneWithoutProtocolsInput
    owner: UserCreateNestedOneWithoutProtocolsInput
    blocks?: BlockCreateNestedManyWithoutProtocolInput
    templates?: ProtocolTemplateCreateNestedManyWithoutProtocolInput
    executions?: ProtocolExecutionCreateNestedManyWithoutProtocolInput
    shares?: ProtocolShareCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolUncheckedCreateWithoutPermissionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId: string
    name: string
    version?: string
    description?: string | null
    category: string
    difficulty: string
    duration?: number | null
    frequency?: number | null
    ownerId: string
    visibility?: $Enums.Visibility
    isActive?: boolean
    isPublic?: boolean
    overview?: string | null
    principles?: ProtocolCreateprinciplesInput | string[]
    requirements?: ProtocolCreaterequirementsInput | string[]
    blocks?: BlockUncheckedCreateNestedManyWithoutProtocolInput
    templates?: ProtocolTemplateUncheckedCreateNestedManyWithoutProtocolInput
    executions?: ProtocolExecutionUncheckedCreateNestedManyWithoutProtocolInput
    shares?: ProtocolShareUncheckedCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolCreateOrConnectWithoutPermissionsInput = {
    where: ProtocolWhereUniqueInput
    create: XOR<ProtocolCreateWithoutPermissionsInput, ProtocolUncheckedCreateWithoutPermissionsInput>
  }

  export type UserCreateWithoutPermissionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutUsersInput
    protocols?: ProtocolCreateNestedManyWithoutOwnerInput
    executions?: ProtocolExecutionCreateNestedManyWithoutUserInput
    sharedProtocols?: ProtocolShareCreateNestedManyWithoutSharedByUserInput
    receivedProtocols?: ProtocolShareCreateNestedManyWithoutSharedWithUserInput
  }

  export type UserUncheckedCreateWithoutPermissionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name?: string | null
    tenantId: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    protocols?: ProtocolUncheckedCreateNestedManyWithoutOwnerInput
    executions?: ProtocolExecutionUncheckedCreateNestedManyWithoutUserInput
    sharedProtocols?: ProtocolShareUncheckedCreateNestedManyWithoutSharedByUserInput
    receivedProtocols?: ProtocolShareUncheckedCreateNestedManyWithoutSharedWithUserInput
  }

  export type UserCreateOrConnectWithoutPermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
  }

  export type ProtocolUpsertWithoutPermissionsInput = {
    update: XOR<ProtocolUpdateWithoutPermissionsInput, ProtocolUncheckedUpdateWithoutPermissionsInput>
    create: XOR<ProtocolCreateWithoutPermissionsInput, ProtocolUncheckedCreateWithoutPermissionsInput>
    where?: ProtocolWhereInput
  }

  export type ProtocolUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: ProtocolWhereInput
    data: XOR<ProtocolUpdateWithoutPermissionsInput, ProtocolUncheckedUpdateWithoutPermissionsInput>
  }

  export type ProtocolUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    principles?: ProtocolUpdateprinciplesInput | string[]
    requirements?: ProtocolUpdaterequirementsInput | string[]
    tenant?: TenantUpdateOneRequiredWithoutProtocolsNestedInput
    owner?: UserUpdateOneRequiredWithoutProtocolsNestedInput
    blocks?: BlockUpdateManyWithoutProtocolNestedInput
    templates?: ProtocolTemplateUpdateManyWithoutProtocolNestedInput
    executions?: ProtocolExecutionUpdateManyWithoutProtocolNestedInput
    shares?: ProtocolShareUpdateManyWithoutProtocolNestedInput
  }

  export type ProtocolUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    principles?: ProtocolUpdateprinciplesInput | string[]
    requirements?: ProtocolUpdaterequirementsInput | string[]
    blocks?: BlockUncheckedUpdateManyWithoutProtocolNestedInput
    templates?: ProtocolTemplateUncheckedUpdateManyWithoutProtocolNestedInput
    executions?: ProtocolExecutionUncheckedUpdateManyWithoutProtocolNestedInput
    shares?: ProtocolShareUncheckedUpdateManyWithoutProtocolNestedInput
  }

  export type UserUpsertWithoutPermissionsInput = {
    update: XOR<UserUpdateWithoutPermissionsInput, UserUncheckedUpdateWithoutPermissionsInput>
    create: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPermissionsInput, UserUncheckedUpdateWithoutPermissionsInput>
  }

  export type UserUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    protocols?: ProtocolUpdateManyWithoutOwnerNestedInput
    executions?: ProtocolExecutionUpdateManyWithoutUserNestedInput
    sharedProtocols?: ProtocolShareUpdateManyWithoutSharedByUserNestedInput
    receivedProtocols?: ProtocolShareUpdateManyWithoutSharedWithUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    protocols?: ProtocolUncheckedUpdateManyWithoutOwnerNestedInput
    executions?: ProtocolExecutionUncheckedUpdateManyWithoutUserNestedInput
    sharedProtocols?: ProtocolShareUncheckedUpdateManyWithoutSharedByUserNestedInput
    receivedProtocols?: ProtocolShareUncheckedUpdateManyWithoutSharedWithUserNestedInput
  }

  export type ProtocolCreateWithoutTemplatesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    version?: string
    description?: string | null
    category: string
    difficulty: string
    duration?: number | null
    frequency?: number | null
    visibility?: $Enums.Visibility
    isActive?: boolean
    isPublic?: boolean
    overview?: string | null
    principles?: ProtocolCreateprinciplesInput | string[]
    requirements?: ProtocolCreaterequirementsInput | string[]
    tenant: TenantCreateNestedOneWithoutProtocolsInput
    owner: UserCreateNestedOneWithoutProtocolsInput
    blocks?: BlockCreateNestedManyWithoutProtocolInput
    executions?: ProtocolExecutionCreateNestedManyWithoutProtocolInput
    permissions?: ProtocolPermissionCreateNestedManyWithoutProtocolInput
    shares?: ProtocolShareCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolUncheckedCreateWithoutTemplatesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId: string
    name: string
    version?: string
    description?: string | null
    category: string
    difficulty: string
    duration?: number | null
    frequency?: number | null
    ownerId: string
    visibility?: $Enums.Visibility
    isActive?: boolean
    isPublic?: boolean
    overview?: string | null
    principles?: ProtocolCreateprinciplesInput | string[]
    requirements?: ProtocolCreaterequirementsInput | string[]
    blocks?: BlockUncheckedCreateNestedManyWithoutProtocolInput
    executions?: ProtocolExecutionUncheckedCreateNestedManyWithoutProtocolInput
    permissions?: ProtocolPermissionUncheckedCreateNestedManyWithoutProtocolInput
    shares?: ProtocolShareUncheckedCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolCreateOrConnectWithoutTemplatesInput = {
    where: ProtocolWhereUniqueInput
    create: XOR<ProtocolCreateWithoutTemplatesInput, ProtocolUncheckedCreateWithoutTemplatesInput>
  }

  export type ProtocolUpsertWithoutTemplatesInput = {
    update: XOR<ProtocolUpdateWithoutTemplatesInput, ProtocolUncheckedUpdateWithoutTemplatesInput>
    create: XOR<ProtocolCreateWithoutTemplatesInput, ProtocolUncheckedCreateWithoutTemplatesInput>
    where?: ProtocolWhereInput
  }

  export type ProtocolUpdateToOneWithWhereWithoutTemplatesInput = {
    where?: ProtocolWhereInput
    data: XOR<ProtocolUpdateWithoutTemplatesInput, ProtocolUncheckedUpdateWithoutTemplatesInput>
  }

  export type ProtocolUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    principles?: ProtocolUpdateprinciplesInput | string[]
    requirements?: ProtocolUpdaterequirementsInput | string[]
    tenant?: TenantUpdateOneRequiredWithoutProtocolsNestedInput
    owner?: UserUpdateOneRequiredWithoutProtocolsNestedInput
    blocks?: BlockUpdateManyWithoutProtocolNestedInput
    executions?: ProtocolExecutionUpdateManyWithoutProtocolNestedInput
    permissions?: ProtocolPermissionUpdateManyWithoutProtocolNestedInput
    shares?: ProtocolShareUpdateManyWithoutProtocolNestedInput
  }

  export type ProtocolUncheckedUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    principles?: ProtocolUpdateprinciplesInput | string[]
    requirements?: ProtocolUpdaterequirementsInput | string[]
    blocks?: BlockUncheckedUpdateManyWithoutProtocolNestedInput
    executions?: ProtocolExecutionUncheckedUpdateManyWithoutProtocolNestedInput
    permissions?: ProtocolPermissionUncheckedUpdateManyWithoutProtocolNestedInput
    shares?: ProtocolShareUncheckedUpdateManyWithoutProtocolNestedInput
  }

  export type TenantCreateWithoutExecutionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    domain?: string | null
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    maxUsers?: number
    maxProtocols?: number
    protocols?: ProtocolCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutExecutionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    domain?: string | null
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    maxUsers?: number
    maxProtocols?: number
    protocols?: ProtocolUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutExecutionsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutExecutionsInput, TenantUncheckedCreateWithoutExecutionsInput>
  }

  export type ProtocolCreateWithoutExecutionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    version?: string
    description?: string | null
    category: string
    difficulty: string
    duration?: number | null
    frequency?: number | null
    visibility?: $Enums.Visibility
    isActive?: boolean
    isPublic?: boolean
    overview?: string | null
    principles?: ProtocolCreateprinciplesInput | string[]
    requirements?: ProtocolCreaterequirementsInput | string[]
    tenant: TenantCreateNestedOneWithoutProtocolsInput
    owner: UserCreateNestedOneWithoutProtocolsInput
    blocks?: BlockCreateNestedManyWithoutProtocolInput
    templates?: ProtocolTemplateCreateNestedManyWithoutProtocolInput
    permissions?: ProtocolPermissionCreateNestedManyWithoutProtocolInput
    shares?: ProtocolShareCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolUncheckedCreateWithoutExecutionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId: string
    name: string
    version?: string
    description?: string | null
    category: string
    difficulty: string
    duration?: number | null
    frequency?: number | null
    ownerId: string
    visibility?: $Enums.Visibility
    isActive?: boolean
    isPublic?: boolean
    overview?: string | null
    principles?: ProtocolCreateprinciplesInput | string[]
    requirements?: ProtocolCreaterequirementsInput | string[]
    blocks?: BlockUncheckedCreateNestedManyWithoutProtocolInput
    templates?: ProtocolTemplateUncheckedCreateNestedManyWithoutProtocolInput
    permissions?: ProtocolPermissionUncheckedCreateNestedManyWithoutProtocolInput
    shares?: ProtocolShareUncheckedCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolCreateOrConnectWithoutExecutionsInput = {
    where: ProtocolWhereUniqueInput
    create: XOR<ProtocolCreateWithoutExecutionsInput, ProtocolUncheckedCreateWithoutExecutionsInput>
  }

  export type UserCreateWithoutExecutionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutUsersInput
    protocols?: ProtocolCreateNestedManyWithoutOwnerInput
    permissions?: ProtocolPermissionCreateNestedManyWithoutUserInput
    sharedProtocols?: ProtocolShareCreateNestedManyWithoutSharedByUserInput
    receivedProtocols?: ProtocolShareCreateNestedManyWithoutSharedWithUserInput
  }

  export type UserUncheckedCreateWithoutExecutionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name?: string | null
    tenantId: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    protocols?: ProtocolUncheckedCreateNestedManyWithoutOwnerInput
    permissions?: ProtocolPermissionUncheckedCreateNestedManyWithoutUserInput
    sharedProtocols?: ProtocolShareUncheckedCreateNestedManyWithoutSharedByUserInput
    receivedProtocols?: ProtocolShareUncheckedCreateNestedManyWithoutSharedWithUserInput
  }

  export type UserCreateOrConnectWithoutExecutionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExecutionsInput, UserUncheckedCreateWithoutExecutionsInput>
  }

  export type BlockExecutionCreateWithoutExecutionInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    currentWeek?: number
    progress?: number
    block: BlockCreateNestedOneWithoutExecutionsInput
  }

  export type BlockExecutionUncheckedCreateWithoutExecutionInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    blockId: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    currentWeek?: number
    progress?: number
  }

  export type BlockExecutionCreateOrConnectWithoutExecutionInput = {
    where: BlockExecutionWhereUniqueInput
    create: XOR<BlockExecutionCreateWithoutExecutionInput, BlockExecutionUncheckedCreateWithoutExecutionInput>
  }

  export type BlockExecutionCreateManyExecutionInputEnvelope = {
    data: BlockExecutionCreateManyExecutionInput | BlockExecutionCreateManyExecutionInput[]
    skipDuplicates?: boolean
  }

  export type SessionExecutionCreateWithoutExecutionInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionId: string
    status?: string
    scheduledDate: Date | string
    actualDate?: Date | string | null
    exercises?: NullableJsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    duration?: number | null
    rpe?: number | null
    volume?: number | null
  }

  export type SessionExecutionUncheckedCreateWithoutExecutionInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionId: string
    status?: string
    scheduledDate: Date | string
    actualDate?: Date | string | null
    exercises?: NullableJsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    duration?: number | null
    rpe?: number | null
    volume?: number | null
  }

  export type SessionExecutionCreateOrConnectWithoutExecutionInput = {
    where: SessionExecutionWhereUniqueInput
    create: XOR<SessionExecutionCreateWithoutExecutionInput, SessionExecutionUncheckedCreateWithoutExecutionInput>
  }

  export type SessionExecutionCreateManyExecutionInputEnvelope = {
    data: SessionExecutionCreateManyExecutionInput | SessionExecutionCreateManyExecutionInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutExecutionsInput = {
    update: XOR<TenantUpdateWithoutExecutionsInput, TenantUncheckedUpdateWithoutExecutionsInput>
    create: XOR<TenantCreateWithoutExecutionsInput, TenantUncheckedCreateWithoutExecutionsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutExecutionsInput, TenantUncheckedUpdateWithoutExecutionsInput>
  }

  export type TenantUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProtocols?: IntFieldUpdateOperationsInput | number
    protocols?: ProtocolUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProtocols?: IntFieldUpdateOperationsInput | number
    protocols?: ProtocolUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ProtocolUpsertWithoutExecutionsInput = {
    update: XOR<ProtocolUpdateWithoutExecutionsInput, ProtocolUncheckedUpdateWithoutExecutionsInput>
    create: XOR<ProtocolCreateWithoutExecutionsInput, ProtocolUncheckedCreateWithoutExecutionsInput>
    where?: ProtocolWhereInput
  }

  export type ProtocolUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: ProtocolWhereInput
    data: XOR<ProtocolUpdateWithoutExecutionsInput, ProtocolUncheckedUpdateWithoutExecutionsInput>
  }

  export type ProtocolUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    principles?: ProtocolUpdateprinciplesInput | string[]
    requirements?: ProtocolUpdaterequirementsInput | string[]
    tenant?: TenantUpdateOneRequiredWithoutProtocolsNestedInput
    owner?: UserUpdateOneRequiredWithoutProtocolsNestedInput
    blocks?: BlockUpdateManyWithoutProtocolNestedInput
    templates?: ProtocolTemplateUpdateManyWithoutProtocolNestedInput
    permissions?: ProtocolPermissionUpdateManyWithoutProtocolNestedInput
    shares?: ProtocolShareUpdateManyWithoutProtocolNestedInput
  }

  export type ProtocolUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    principles?: ProtocolUpdateprinciplesInput | string[]
    requirements?: ProtocolUpdaterequirementsInput | string[]
    blocks?: BlockUncheckedUpdateManyWithoutProtocolNestedInput
    templates?: ProtocolTemplateUncheckedUpdateManyWithoutProtocolNestedInput
    permissions?: ProtocolPermissionUncheckedUpdateManyWithoutProtocolNestedInput
    shares?: ProtocolShareUncheckedUpdateManyWithoutProtocolNestedInput
  }

  export type UserUpsertWithoutExecutionsInput = {
    update: XOR<UserUpdateWithoutExecutionsInput, UserUncheckedUpdateWithoutExecutionsInput>
    create: XOR<UserCreateWithoutExecutionsInput, UserUncheckedCreateWithoutExecutionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExecutionsInput, UserUncheckedUpdateWithoutExecutionsInput>
  }

  export type UserUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    protocols?: ProtocolUpdateManyWithoutOwnerNestedInput
    permissions?: ProtocolPermissionUpdateManyWithoutUserNestedInput
    sharedProtocols?: ProtocolShareUpdateManyWithoutSharedByUserNestedInput
    receivedProtocols?: ProtocolShareUpdateManyWithoutSharedWithUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    protocols?: ProtocolUncheckedUpdateManyWithoutOwnerNestedInput
    permissions?: ProtocolPermissionUncheckedUpdateManyWithoutUserNestedInput
    sharedProtocols?: ProtocolShareUncheckedUpdateManyWithoutSharedByUserNestedInput
    receivedProtocols?: ProtocolShareUncheckedUpdateManyWithoutSharedWithUserNestedInput
  }

  export type BlockExecutionUpsertWithWhereUniqueWithoutExecutionInput = {
    where: BlockExecutionWhereUniqueInput
    update: XOR<BlockExecutionUpdateWithoutExecutionInput, BlockExecutionUncheckedUpdateWithoutExecutionInput>
    create: XOR<BlockExecutionCreateWithoutExecutionInput, BlockExecutionUncheckedCreateWithoutExecutionInput>
  }

  export type BlockExecutionUpdateWithWhereUniqueWithoutExecutionInput = {
    where: BlockExecutionWhereUniqueInput
    data: XOR<BlockExecutionUpdateWithoutExecutionInput, BlockExecutionUncheckedUpdateWithoutExecutionInput>
  }

  export type BlockExecutionUpdateManyWithWhereWithoutExecutionInput = {
    where: BlockExecutionScalarWhereInput
    data: XOR<BlockExecutionUpdateManyMutationInput, BlockExecutionUncheckedUpdateManyWithoutExecutionInput>
  }

  export type SessionExecutionUpsertWithWhereUniqueWithoutExecutionInput = {
    where: SessionExecutionWhereUniqueInput
    update: XOR<SessionExecutionUpdateWithoutExecutionInput, SessionExecutionUncheckedUpdateWithoutExecutionInput>
    create: XOR<SessionExecutionCreateWithoutExecutionInput, SessionExecutionUncheckedCreateWithoutExecutionInput>
  }

  export type SessionExecutionUpdateWithWhereUniqueWithoutExecutionInput = {
    where: SessionExecutionWhereUniqueInput
    data: XOR<SessionExecutionUpdateWithoutExecutionInput, SessionExecutionUncheckedUpdateWithoutExecutionInput>
  }

  export type SessionExecutionUpdateManyWithWhereWithoutExecutionInput = {
    where: SessionExecutionScalarWhereInput
    data: XOR<SessionExecutionUpdateManyMutationInput, SessionExecutionUncheckedUpdateManyWithoutExecutionInput>
  }

  export type SessionExecutionScalarWhereInput = {
    AND?: SessionExecutionScalarWhereInput | SessionExecutionScalarWhereInput[]
    OR?: SessionExecutionScalarWhereInput[]
    NOT?: SessionExecutionScalarWhereInput | SessionExecutionScalarWhereInput[]
    id?: StringFilter<"SessionExecution"> | string
    createdAt?: DateTimeFilter<"SessionExecution"> | Date | string
    updatedAt?: DateTimeFilter<"SessionExecution"> | Date | string
    executionId?: StringFilter<"SessionExecution"> | string
    sessionId?: StringFilter<"SessionExecution"> | string
    status?: StringFilter<"SessionExecution"> | string
    scheduledDate?: DateTimeFilter<"SessionExecution"> | Date | string
    actualDate?: DateTimeNullableFilter<"SessionExecution"> | Date | string | null
    exercises?: JsonNullableFilter<"SessionExecution">
    adaptations?: JsonNullableFilter<"SessionExecution">
    notes?: StringNullableFilter<"SessionExecution"> | string | null
    duration?: IntNullableFilter<"SessionExecution"> | number | null
    rpe?: FloatNullableFilter<"SessionExecution"> | number | null
    volume?: FloatNullableFilter<"SessionExecution"> | number | null
  }

  export type ProtocolExecutionCreateWithoutBlockExecutionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId?: string | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    parameters: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: $Enums.DataClassification
    retentionUntil?: Date | string | null
    currentBlockId?: string | null
    currentWeek?: number
    progress?: number
    tenant: TenantCreateNestedOneWithoutExecutionsInput
    protocol: ProtocolCreateNestedOneWithoutExecutionsInput
    user: UserCreateNestedOneWithoutExecutionsInput
    sessions?: SessionExecutionCreateNestedManyWithoutExecutionInput
  }

  export type ProtocolExecutionUncheckedCreateWithoutBlockExecutionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId: string
    protocolId: string
    userId: string
    templateId?: string | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    parameters: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: $Enums.DataClassification
    retentionUntil?: Date | string | null
    currentBlockId?: string | null
    currentWeek?: number
    progress?: number
    sessions?: SessionExecutionUncheckedCreateNestedManyWithoutExecutionInput
  }

  export type ProtocolExecutionCreateOrConnectWithoutBlockExecutionsInput = {
    where: ProtocolExecutionWhereUniqueInput
    create: XOR<ProtocolExecutionCreateWithoutBlockExecutionsInput, ProtocolExecutionUncheckedCreateWithoutBlockExecutionsInput>
  }

  export type BlockCreateWithoutExecutionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    order: number
    duration: number
    phase: string
    intensity: string
    volume: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    protocol: ProtocolCreateNestedOneWithoutBlocksInput
    sessions?: BlockSessionCreateNestedManyWithoutBlockInput
    progressions?: BlockProgressionCreateNestedManyWithoutBlockInput
  }

  export type BlockUncheckedCreateWithoutExecutionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    name: string
    description?: string | null
    order: number
    duration: number
    phase: string
    intensity: string
    volume: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    sessions?: BlockSessionUncheckedCreateNestedManyWithoutBlockInput
    progressions?: BlockProgressionUncheckedCreateNestedManyWithoutBlockInput
  }

  export type BlockCreateOrConnectWithoutExecutionsInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutExecutionsInput, BlockUncheckedCreateWithoutExecutionsInput>
  }

  export type ProtocolExecutionUpsertWithoutBlockExecutionsInput = {
    update: XOR<ProtocolExecutionUpdateWithoutBlockExecutionsInput, ProtocolExecutionUncheckedUpdateWithoutBlockExecutionsInput>
    create: XOR<ProtocolExecutionCreateWithoutBlockExecutionsInput, ProtocolExecutionUncheckedCreateWithoutBlockExecutionsInput>
    where?: ProtocolExecutionWhereInput
  }

  export type ProtocolExecutionUpdateToOneWithWhereWithoutBlockExecutionsInput = {
    where?: ProtocolExecutionWhereInput
    data: XOR<ProtocolExecutionUpdateWithoutBlockExecutionsInput, ProtocolExecutionUncheckedUpdateWithoutBlockExecutionsInput>
  }

  export type ProtocolExecutionUpdateWithoutBlockExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: EnumDataClassificationFieldUpdateOperationsInput | $Enums.DataClassification
    retentionUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    tenant?: TenantUpdateOneRequiredWithoutExecutionsNestedInput
    protocol?: ProtocolUpdateOneRequiredWithoutExecutionsNestedInput
    user?: UserUpdateOneRequiredWithoutExecutionsNestedInput
    sessions?: SessionExecutionUpdateManyWithoutExecutionNestedInput
  }

  export type ProtocolExecutionUncheckedUpdateWithoutBlockExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    protocolId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: EnumDataClassificationFieldUpdateOperationsInput | $Enums.DataClassification
    retentionUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    sessions?: SessionExecutionUncheckedUpdateManyWithoutExecutionNestedInput
  }

  export type BlockUpsertWithoutExecutionsInput = {
    update: XOR<BlockUpdateWithoutExecutionsInput, BlockUncheckedUpdateWithoutExecutionsInput>
    create: XOR<BlockCreateWithoutExecutionsInput, BlockUncheckedCreateWithoutExecutionsInput>
    where?: BlockWhereInput
  }

  export type BlockUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: BlockWhereInput
    data: XOR<BlockUpdateWithoutExecutionsInput, BlockUncheckedUpdateWithoutExecutionsInput>
  }

  export type BlockUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    intensity?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    protocol?: ProtocolUpdateOneRequiredWithoutBlocksNestedInput
    sessions?: BlockSessionUpdateManyWithoutBlockNestedInput
    progressions?: BlockProgressionUpdateManyWithoutBlockNestedInput
  }

  export type BlockUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    intensity?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    sessions?: BlockSessionUncheckedUpdateManyWithoutBlockNestedInput
    progressions?: BlockProgressionUncheckedUpdateManyWithoutBlockNestedInput
  }

  export type ProtocolExecutionCreateWithoutSessionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId?: string | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    parameters: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: $Enums.DataClassification
    retentionUntil?: Date | string | null
    currentBlockId?: string | null
    currentWeek?: number
    progress?: number
    tenant: TenantCreateNestedOneWithoutExecutionsInput
    protocol: ProtocolCreateNestedOneWithoutExecutionsInput
    user: UserCreateNestedOneWithoutExecutionsInput
    blockExecutions?: BlockExecutionCreateNestedManyWithoutExecutionInput
  }

  export type ProtocolExecutionUncheckedCreateWithoutSessionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId: string
    protocolId: string
    userId: string
    templateId?: string | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    parameters: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: $Enums.DataClassification
    retentionUntil?: Date | string | null
    currentBlockId?: string | null
    currentWeek?: number
    progress?: number
    blockExecutions?: BlockExecutionUncheckedCreateNestedManyWithoutExecutionInput
  }

  export type ProtocolExecutionCreateOrConnectWithoutSessionsInput = {
    where: ProtocolExecutionWhereUniqueInput
    create: XOR<ProtocolExecutionCreateWithoutSessionsInput, ProtocolExecutionUncheckedCreateWithoutSessionsInput>
  }

  export type ProtocolExecutionUpsertWithoutSessionsInput = {
    update: XOR<ProtocolExecutionUpdateWithoutSessionsInput, ProtocolExecutionUncheckedUpdateWithoutSessionsInput>
    create: XOR<ProtocolExecutionCreateWithoutSessionsInput, ProtocolExecutionUncheckedCreateWithoutSessionsInput>
    where?: ProtocolExecutionWhereInput
  }

  export type ProtocolExecutionUpdateToOneWithWhereWithoutSessionsInput = {
    where?: ProtocolExecutionWhereInput
    data: XOR<ProtocolExecutionUpdateWithoutSessionsInput, ProtocolExecutionUncheckedUpdateWithoutSessionsInput>
  }

  export type ProtocolExecutionUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: EnumDataClassificationFieldUpdateOperationsInput | $Enums.DataClassification
    retentionUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    tenant?: TenantUpdateOneRequiredWithoutExecutionsNestedInput
    protocol?: ProtocolUpdateOneRequiredWithoutExecutionsNestedInput
    user?: UserUpdateOneRequiredWithoutExecutionsNestedInput
    blockExecutions?: BlockExecutionUpdateManyWithoutExecutionNestedInput
  }

  export type ProtocolExecutionUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    protocolId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: EnumDataClassificationFieldUpdateOperationsInput | $Enums.DataClassification
    retentionUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    blockExecutions?: BlockExecutionUncheckedUpdateManyWithoutExecutionNestedInput
  }

  export type ProtocolCreateWithoutSharesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    version?: string
    description?: string | null
    category: string
    difficulty: string
    duration?: number | null
    frequency?: number | null
    visibility?: $Enums.Visibility
    isActive?: boolean
    isPublic?: boolean
    overview?: string | null
    principles?: ProtocolCreateprinciplesInput | string[]
    requirements?: ProtocolCreaterequirementsInput | string[]
    tenant: TenantCreateNestedOneWithoutProtocolsInput
    owner: UserCreateNestedOneWithoutProtocolsInput
    blocks?: BlockCreateNestedManyWithoutProtocolInput
    templates?: ProtocolTemplateCreateNestedManyWithoutProtocolInput
    executions?: ProtocolExecutionCreateNestedManyWithoutProtocolInput
    permissions?: ProtocolPermissionCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolUncheckedCreateWithoutSharesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId: string
    name: string
    version?: string
    description?: string | null
    category: string
    difficulty: string
    duration?: number | null
    frequency?: number | null
    ownerId: string
    visibility?: $Enums.Visibility
    isActive?: boolean
    isPublic?: boolean
    overview?: string | null
    principles?: ProtocolCreateprinciplesInput | string[]
    requirements?: ProtocolCreaterequirementsInput | string[]
    blocks?: BlockUncheckedCreateNestedManyWithoutProtocolInput
    templates?: ProtocolTemplateUncheckedCreateNestedManyWithoutProtocolInput
    executions?: ProtocolExecutionUncheckedCreateNestedManyWithoutProtocolInput
    permissions?: ProtocolPermissionUncheckedCreateNestedManyWithoutProtocolInput
  }

  export type ProtocolCreateOrConnectWithoutSharesInput = {
    where: ProtocolWhereUniqueInput
    create: XOR<ProtocolCreateWithoutSharesInput, ProtocolUncheckedCreateWithoutSharesInput>
  }

  export type UserCreateWithoutSharedProtocolsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutUsersInput
    protocols?: ProtocolCreateNestedManyWithoutOwnerInput
    executions?: ProtocolExecutionCreateNestedManyWithoutUserInput
    permissions?: ProtocolPermissionCreateNestedManyWithoutUserInput
    receivedProtocols?: ProtocolShareCreateNestedManyWithoutSharedWithUserInput
  }

  export type UserUncheckedCreateWithoutSharedProtocolsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name?: string | null
    tenantId: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    protocols?: ProtocolUncheckedCreateNestedManyWithoutOwnerInput
    executions?: ProtocolExecutionUncheckedCreateNestedManyWithoutUserInput
    permissions?: ProtocolPermissionUncheckedCreateNestedManyWithoutUserInput
    receivedProtocols?: ProtocolShareUncheckedCreateNestedManyWithoutSharedWithUserInput
  }

  export type UserCreateOrConnectWithoutSharedProtocolsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSharedProtocolsInput, UserUncheckedCreateWithoutSharedProtocolsInput>
  }

  export type UserCreateWithoutReceivedProtocolsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutUsersInput
    protocols?: ProtocolCreateNestedManyWithoutOwnerInput
    executions?: ProtocolExecutionCreateNestedManyWithoutUserInput
    permissions?: ProtocolPermissionCreateNestedManyWithoutUserInput
    sharedProtocols?: ProtocolShareCreateNestedManyWithoutSharedByUserInput
  }

  export type UserUncheckedCreateWithoutReceivedProtocolsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name?: string | null
    tenantId: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    protocols?: ProtocolUncheckedCreateNestedManyWithoutOwnerInput
    executions?: ProtocolExecutionUncheckedCreateNestedManyWithoutUserInput
    permissions?: ProtocolPermissionUncheckedCreateNestedManyWithoutUserInput
    sharedProtocols?: ProtocolShareUncheckedCreateNestedManyWithoutSharedByUserInput
  }

  export type UserCreateOrConnectWithoutReceivedProtocolsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedProtocolsInput, UserUncheckedCreateWithoutReceivedProtocolsInput>
  }

  export type ProtocolUpsertWithoutSharesInput = {
    update: XOR<ProtocolUpdateWithoutSharesInput, ProtocolUncheckedUpdateWithoutSharesInput>
    create: XOR<ProtocolCreateWithoutSharesInput, ProtocolUncheckedCreateWithoutSharesInput>
    where?: ProtocolWhereInput
  }

  export type ProtocolUpdateToOneWithWhereWithoutSharesInput = {
    where?: ProtocolWhereInput
    data: XOR<ProtocolUpdateWithoutSharesInput, ProtocolUncheckedUpdateWithoutSharesInput>
  }

  export type ProtocolUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    principles?: ProtocolUpdateprinciplesInput | string[]
    requirements?: ProtocolUpdaterequirementsInput | string[]
    tenant?: TenantUpdateOneRequiredWithoutProtocolsNestedInput
    owner?: UserUpdateOneRequiredWithoutProtocolsNestedInput
    blocks?: BlockUpdateManyWithoutProtocolNestedInput
    templates?: ProtocolTemplateUpdateManyWithoutProtocolNestedInput
    executions?: ProtocolExecutionUpdateManyWithoutProtocolNestedInput
    permissions?: ProtocolPermissionUpdateManyWithoutProtocolNestedInput
  }

  export type ProtocolUncheckedUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    principles?: ProtocolUpdateprinciplesInput | string[]
    requirements?: ProtocolUpdaterequirementsInput | string[]
    blocks?: BlockUncheckedUpdateManyWithoutProtocolNestedInput
    templates?: ProtocolTemplateUncheckedUpdateManyWithoutProtocolNestedInput
    executions?: ProtocolExecutionUncheckedUpdateManyWithoutProtocolNestedInput
    permissions?: ProtocolPermissionUncheckedUpdateManyWithoutProtocolNestedInput
  }

  export type UserUpsertWithoutSharedProtocolsInput = {
    update: XOR<UserUpdateWithoutSharedProtocolsInput, UserUncheckedUpdateWithoutSharedProtocolsInput>
    create: XOR<UserCreateWithoutSharedProtocolsInput, UserUncheckedCreateWithoutSharedProtocolsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSharedProtocolsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSharedProtocolsInput, UserUncheckedUpdateWithoutSharedProtocolsInput>
  }

  export type UserUpdateWithoutSharedProtocolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    protocols?: ProtocolUpdateManyWithoutOwnerNestedInput
    executions?: ProtocolExecutionUpdateManyWithoutUserNestedInput
    permissions?: ProtocolPermissionUpdateManyWithoutUserNestedInput
    receivedProtocols?: ProtocolShareUpdateManyWithoutSharedWithUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSharedProtocolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    protocols?: ProtocolUncheckedUpdateManyWithoutOwnerNestedInput
    executions?: ProtocolExecutionUncheckedUpdateManyWithoutUserNestedInput
    permissions?: ProtocolPermissionUncheckedUpdateManyWithoutUserNestedInput
    receivedProtocols?: ProtocolShareUncheckedUpdateManyWithoutSharedWithUserNestedInput
  }

  export type UserUpsertWithoutReceivedProtocolsInput = {
    update: XOR<UserUpdateWithoutReceivedProtocolsInput, UserUncheckedUpdateWithoutReceivedProtocolsInput>
    create: XOR<UserCreateWithoutReceivedProtocolsInput, UserUncheckedCreateWithoutReceivedProtocolsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedProtocolsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedProtocolsInput, UserUncheckedUpdateWithoutReceivedProtocolsInput>
  }

  export type UserUpdateWithoutReceivedProtocolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    protocols?: ProtocolUpdateManyWithoutOwnerNestedInput
    executions?: ProtocolExecutionUpdateManyWithoutUserNestedInput
    permissions?: ProtocolPermissionUpdateManyWithoutUserNestedInput
    sharedProtocols?: ProtocolShareUpdateManyWithoutSharedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedProtocolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    protocols?: ProtocolUncheckedUpdateManyWithoutOwnerNestedInput
    executions?: ProtocolExecutionUncheckedUpdateManyWithoutUserNestedInput
    permissions?: ProtocolPermissionUncheckedUpdateManyWithoutUserNestedInput
    sharedProtocols?: ProtocolShareUncheckedUpdateManyWithoutSharedByUserNestedInput
  }

  export type ProtocolCreateManyTenantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    version?: string
    description?: string | null
    category: string
    difficulty: string
    duration?: number | null
    frequency?: number | null
    ownerId: string
    visibility?: $Enums.Visibility
    isActive?: boolean
    isPublic?: boolean
    overview?: string | null
    principles?: ProtocolCreateprinciplesInput | string[]
    requirements?: ProtocolCreaterequirementsInput | string[]
  }

  export type UserCreateManyTenantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
  }

  export type ProtocolExecutionCreateManyTenantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    userId: string
    templateId?: string | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    parameters: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: $Enums.DataClassification
    retentionUntil?: Date | string | null
    currentBlockId?: string | null
    currentWeek?: number
    progress?: number
  }

  export type ProtocolUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    principles?: ProtocolUpdateprinciplesInput | string[]
    requirements?: ProtocolUpdaterequirementsInput | string[]
    owner?: UserUpdateOneRequiredWithoutProtocolsNestedInput
    blocks?: BlockUpdateManyWithoutProtocolNestedInput
    templates?: ProtocolTemplateUpdateManyWithoutProtocolNestedInput
    executions?: ProtocolExecutionUpdateManyWithoutProtocolNestedInput
    permissions?: ProtocolPermissionUpdateManyWithoutProtocolNestedInput
    shares?: ProtocolShareUpdateManyWithoutProtocolNestedInput
  }

  export type ProtocolUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    principles?: ProtocolUpdateprinciplesInput | string[]
    requirements?: ProtocolUpdaterequirementsInput | string[]
    blocks?: BlockUncheckedUpdateManyWithoutProtocolNestedInput
    templates?: ProtocolTemplateUncheckedUpdateManyWithoutProtocolNestedInput
    executions?: ProtocolExecutionUncheckedUpdateManyWithoutProtocolNestedInput
    permissions?: ProtocolPermissionUncheckedUpdateManyWithoutProtocolNestedInput
    shares?: ProtocolShareUncheckedUpdateManyWithoutProtocolNestedInput
  }

  export type ProtocolUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    principles?: ProtocolUpdateprinciplesInput | string[]
    requirements?: ProtocolUpdaterequirementsInput | string[]
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    protocols?: ProtocolUpdateManyWithoutOwnerNestedInput
    executions?: ProtocolExecutionUpdateManyWithoutUserNestedInput
    permissions?: ProtocolPermissionUpdateManyWithoutUserNestedInput
    sharedProtocols?: ProtocolShareUpdateManyWithoutSharedByUserNestedInput
    receivedProtocols?: ProtocolShareUpdateManyWithoutSharedWithUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    protocols?: ProtocolUncheckedUpdateManyWithoutOwnerNestedInput
    executions?: ProtocolExecutionUncheckedUpdateManyWithoutUserNestedInput
    permissions?: ProtocolPermissionUncheckedUpdateManyWithoutUserNestedInput
    sharedProtocols?: ProtocolShareUncheckedUpdateManyWithoutSharedByUserNestedInput
    receivedProtocols?: ProtocolShareUncheckedUpdateManyWithoutSharedWithUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProtocolExecutionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: EnumDataClassificationFieldUpdateOperationsInput | $Enums.DataClassification
    retentionUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    protocol?: ProtocolUpdateOneRequiredWithoutExecutionsNestedInput
    user?: UserUpdateOneRequiredWithoutExecutionsNestedInput
    blockExecutions?: BlockExecutionUpdateManyWithoutExecutionNestedInput
    sessions?: SessionExecutionUpdateManyWithoutExecutionNestedInput
  }

  export type ProtocolExecutionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: EnumDataClassificationFieldUpdateOperationsInput | $Enums.DataClassification
    retentionUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    blockExecutions?: BlockExecutionUncheckedUpdateManyWithoutExecutionNestedInput
    sessions?: SessionExecutionUncheckedUpdateManyWithoutExecutionNestedInput
  }

  export type ProtocolExecutionUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: EnumDataClassificationFieldUpdateOperationsInput | $Enums.DataClassification
    retentionUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
  }

  export type ProtocolCreateManyOwnerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId: string
    name: string
    version?: string
    description?: string | null
    category: string
    difficulty: string
    duration?: number | null
    frequency?: number | null
    visibility?: $Enums.Visibility
    isActive?: boolean
    isPublic?: boolean
    overview?: string | null
    principles?: ProtocolCreateprinciplesInput | string[]
    requirements?: ProtocolCreaterequirementsInput | string[]
  }

  export type ProtocolExecutionCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId: string
    protocolId: string
    templateId?: string | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    parameters: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: $Enums.DataClassification
    retentionUntil?: Date | string | null
    currentBlockId?: string | null
    currentWeek?: number
    progress?: number
  }

  export type ProtocolPermissionCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    role: $Enums.PermissionRole
    permissions?: ProtocolPermissionCreatepermissionsInput | $Enums.Permission[]
    grantedBy: string
    grantedAt: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type ProtocolShareCreateManySharedByUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    sharedWith: string
    permissions?: ProtocolShareCreatepermissionsInput | $Enums.Permission[]
    expiresAt?: Date | string | null
    isActive?: boolean
    acceptedAt?: Date | string | null
  }

  export type ProtocolShareCreateManySharedWithUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    protocolId: string
    sharedBy: string
    permissions?: ProtocolShareCreatepermissionsInput | $Enums.Permission[]
    expiresAt?: Date | string | null
    isActive?: boolean
    acceptedAt?: Date | string | null
  }

  export type ProtocolUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    principles?: ProtocolUpdateprinciplesInput | string[]
    requirements?: ProtocolUpdaterequirementsInput | string[]
    tenant?: TenantUpdateOneRequiredWithoutProtocolsNestedInput
    blocks?: BlockUpdateManyWithoutProtocolNestedInput
    templates?: ProtocolTemplateUpdateManyWithoutProtocolNestedInput
    executions?: ProtocolExecutionUpdateManyWithoutProtocolNestedInput
    permissions?: ProtocolPermissionUpdateManyWithoutProtocolNestedInput
    shares?: ProtocolShareUpdateManyWithoutProtocolNestedInput
  }

  export type ProtocolUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    principles?: ProtocolUpdateprinciplesInput | string[]
    requirements?: ProtocolUpdaterequirementsInput | string[]
    blocks?: BlockUncheckedUpdateManyWithoutProtocolNestedInput
    templates?: ProtocolTemplateUncheckedUpdateManyWithoutProtocolNestedInput
    executions?: ProtocolExecutionUncheckedUpdateManyWithoutProtocolNestedInput
    permissions?: ProtocolPermissionUncheckedUpdateManyWithoutProtocolNestedInput
    shares?: ProtocolShareUncheckedUpdateManyWithoutProtocolNestedInput
  }

  export type ProtocolUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    principles?: ProtocolUpdateprinciplesInput | string[]
    requirements?: ProtocolUpdaterequirementsInput | string[]
  }

  export type ProtocolExecutionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: EnumDataClassificationFieldUpdateOperationsInput | $Enums.DataClassification
    retentionUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    tenant?: TenantUpdateOneRequiredWithoutExecutionsNestedInput
    protocol?: ProtocolUpdateOneRequiredWithoutExecutionsNestedInput
    blockExecutions?: BlockExecutionUpdateManyWithoutExecutionNestedInput
    sessions?: SessionExecutionUpdateManyWithoutExecutionNestedInput
  }

  export type ProtocolExecutionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    protocolId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: EnumDataClassificationFieldUpdateOperationsInput | $Enums.DataClassification
    retentionUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    blockExecutions?: BlockExecutionUncheckedUpdateManyWithoutExecutionNestedInput
    sessions?: SessionExecutionUncheckedUpdateManyWithoutExecutionNestedInput
  }

  export type ProtocolExecutionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    protocolId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: EnumDataClassificationFieldUpdateOperationsInput | $Enums.DataClassification
    retentionUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
  }

  export type ProtocolPermissionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumPermissionRoleFieldUpdateOperationsInput | $Enums.PermissionRole
    permissions?: ProtocolPermissionUpdatepermissionsInput | $Enums.Permission[]
    grantedBy?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    protocol?: ProtocolUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type ProtocolPermissionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    role?: EnumPermissionRoleFieldUpdateOperationsInput | $Enums.PermissionRole
    permissions?: ProtocolPermissionUpdatepermissionsInput | $Enums.Permission[]
    grantedBy?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProtocolPermissionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    role?: EnumPermissionRoleFieldUpdateOperationsInput | $Enums.PermissionRole
    permissions?: ProtocolPermissionUpdatepermissionsInput | $Enums.Permission[]
    grantedBy?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProtocolShareUpdateWithoutSharedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: ProtocolShareUpdatepermissionsInput | $Enums.Permission[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    protocol?: ProtocolUpdateOneRequiredWithoutSharesNestedInput
    sharedWithUser?: UserUpdateOneRequiredWithoutReceivedProtocolsNestedInput
  }

  export type ProtocolShareUncheckedUpdateWithoutSharedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    sharedWith?: StringFieldUpdateOperationsInput | string
    permissions?: ProtocolShareUpdatepermissionsInput | $Enums.Permission[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProtocolShareUncheckedUpdateManyWithoutSharedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    sharedWith?: StringFieldUpdateOperationsInput | string
    permissions?: ProtocolShareUpdatepermissionsInput | $Enums.Permission[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProtocolShareUpdateWithoutSharedWithUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: ProtocolShareUpdatepermissionsInput | $Enums.Permission[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    protocol?: ProtocolUpdateOneRequiredWithoutSharesNestedInput
    sharedByUser?: UserUpdateOneRequiredWithoutSharedProtocolsNestedInput
  }

  export type ProtocolShareUncheckedUpdateWithoutSharedWithUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    sharedBy?: StringFieldUpdateOperationsInput | string
    permissions?: ProtocolShareUpdatepermissionsInput | $Enums.Permission[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProtocolShareUncheckedUpdateManyWithoutSharedWithUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocolId?: StringFieldUpdateOperationsInput | string
    sharedBy?: StringFieldUpdateOperationsInput | string
    permissions?: ProtocolShareUpdatepermissionsInput | $Enums.Permission[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlockCreateManyProtocolInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    order: number
    duration: number
    phase: string
    intensity: string
    volume: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProtocolTemplateCreateManyProtocolInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    parameters: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    usageCount?: number
  }

  export type ProtocolExecutionCreateManyProtocolInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId: string
    userId: string
    templateId?: string | null
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    parameters: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: $Enums.DataClassification
    retentionUntil?: Date | string | null
    currentBlockId?: string | null
    currentWeek?: number
    progress?: number
  }

  export type ProtocolPermissionCreateManyProtocolInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    role: $Enums.PermissionRole
    permissions?: ProtocolPermissionCreatepermissionsInput | $Enums.Permission[]
    grantedBy: string
    grantedAt: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type ProtocolShareCreateManyProtocolInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sharedBy: string
    sharedWith: string
    permissions?: ProtocolShareCreatepermissionsInput | $Enums.Permission[]
    expiresAt?: Date | string | null
    isActive?: boolean
    acceptedAt?: Date | string | null
  }

  export type BlockUpdateWithoutProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    intensity?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    sessions?: BlockSessionUpdateManyWithoutBlockNestedInput
    progressions?: BlockProgressionUpdateManyWithoutBlockNestedInput
    executions?: BlockExecutionUpdateManyWithoutBlockNestedInput
  }

  export type BlockUncheckedUpdateWithoutProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    intensity?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    sessions?: BlockSessionUncheckedUpdateManyWithoutBlockNestedInput
    progressions?: BlockProgressionUncheckedUpdateManyWithoutBlockNestedInput
    executions?: BlockExecutionUncheckedUpdateManyWithoutBlockNestedInput
  }

  export type BlockUncheckedUpdateManyWithoutProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    intensity?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProtocolTemplateUpdateWithoutProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
  }

  export type ProtocolTemplateUncheckedUpdateWithoutProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
  }

  export type ProtocolTemplateUncheckedUpdateManyWithoutProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
  }

  export type ProtocolExecutionUpdateWithoutProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: EnumDataClassificationFieldUpdateOperationsInput | $Enums.DataClassification
    retentionUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    tenant?: TenantUpdateOneRequiredWithoutExecutionsNestedInput
    user?: UserUpdateOneRequiredWithoutExecutionsNestedInput
    blockExecutions?: BlockExecutionUpdateManyWithoutExecutionNestedInput
    sessions?: SessionExecutionUpdateManyWithoutExecutionNestedInput
  }

  export type ProtocolExecutionUncheckedUpdateWithoutProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: EnumDataClassificationFieldUpdateOperationsInput | $Enums.DataClassification
    retentionUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    blockExecutions?: BlockExecutionUncheckedUpdateManyWithoutExecutionNestedInput
    sessions?: SessionExecutionUncheckedUpdateManyWithoutExecutionNestedInput
  }

  export type ProtocolExecutionUncheckedUpdateManyWithoutProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parameters?: JsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    dataClassification?: EnumDataClassificationFieldUpdateOperationsInput | $Enums.DataClassification
    retentionUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
  }

  export type ProtocolPermissionUpdateWithoutProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumPermissionRoleFieldUpdateOperationsInput | $Enums.PermissionRole
    permissions?: ProtocolPermissionUpdatepermissionsInput | $Enums.Permission[]
    grantedBy?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type ProtocolPermissionUncheckedUpdateWithoutProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumPermissionRoleFieldUpdateOperationsInput | $Enums.PermissionRole
    permissions?: ProtocolPermissionUpdatepermissionsInput | $Enums.Permission[]
    grantedBy?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProtocolPermissionUncheckedUpdateManyWithoutProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumPermissionRoleFieldUpdateOperationsInput | $Enums.PermissionRole
    permissions?: ProtocolPermissionUpdatepermissionsInput | $Enums.Permission[]
    grantedBy?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProtocolShareUpdateWithoutProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: ProtocolShareUpdatepermissionsInput | $Enums.Permission[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sharedByUser?: UserUpdateOneRequiredWithoutSharedProtocolsNestedInput
    sharedWithUser?: UserUpdateOneRequiredWithoutReceivedProtocolsNestedInput
  }

  export type ProtocolShareUncheckedUpdateWithoutProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedBy?: StringFieldUpdateOperationsInput | string
    sharedWith?: StringFieldUpdateOperationsInput | string
    permissions?: ProtocolShareUpdatepermissionsInput | $Enums.Permission[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProtocolShareUncheckedUpdateManyWithoutProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedBy?: StringFieldUpdateOperationsInput | string
    sharedWith?: StringFieldUpdateOperationsInput | string
    permissions?: ProtocolShareUpdatepermissionsInput | $Enums.Permission[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlockSessionCreateManyBlockInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    dayOfWeek: number
    order: number
    exercises: JsonNullValueInput | InputJsonValue
    duration?: number | null
    notes?: string | null
    intensity?: number | null
    volume?: number | null
    rpe?: number | null
  }

  export type BlockProgressionCreateManyBlockInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    week: number
    parameters: JsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    triggers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BlockExecutionCreateManyBlockInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executionId: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    currentWeek?: number
    progress?: number
  }

  export type BlockSessionUpdateWithoutBlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    exercises?: JsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    intensity?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type BlockSessionUncheckedUpdateWithoutBlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    exercises?: JsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    intensity?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type BlockSessionUncheckedUpdateManyWithoutBlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    exercises?: JsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    intensity?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type BlockProgressionUpdateWithoutBlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    week?: IntFieldUpdateOperationsInput | number
    parameters?: JsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    triggers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BlockProgressionUncheckedUpdateWithoutBlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    week?: IntFieldUpdateOperationsInput | number
    parameters?: JsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    triggers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BlockProgressionUncheckedUpdateManyWithoutBlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    week?: IntFieldUpdateOperationsInput | number
    parameters?: JsonNullValueInput | InputJsonValue
    rules?: NullableJsonNullValueInput | InputJsonValue
    triggers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BlockExecutionUpdateWithoutBlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    execution?: ProtocolExecutionUpdateOneRequiredWithoutBlockExecutionsNestedInput
  }

  export type BlockExecutionUncheckedUpdateWithoutBlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
  }

  export type BlockExecutionUncheckedUpdateManyWithoutBlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
  }

  export type BlockExecutionCreateManyExecutionInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    blockId: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    currentWeek?: number
    progress?: number
  }

  export type SessionExecutionCreateManyExecutionInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionId: string
    status?: string
    scheduledDate: Date | string
    actualDate?: Date | string | null
    exercises?: NullableJsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    duration?: number | null
    rpe?: number | null
    volume?: number | null
  }

  export type BlockExecutionUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    block?: BlockUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type BlockExecutionUncheckedUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
  }

  export type BlockExecutionUncheckedUpdateManyWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currentWeek?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
  }

  export type SessionExecutionUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exercises?: NullableJsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SessionExecutionUncheckedUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exercises?: NullableJsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SessionExecutionUncheckedUpdateManyWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exercises?: NullableJsonNullValueInput | InputJsonValue
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use TenantCountOutputTypeDefaultArgs instead
     */
    export type TenantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProtocolCountOutputTypeDefaultArgs instead
     */
    export type ProtocolCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProtocolCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockCountOutputTypeDefaultArgs instead
     */
    export type BlockCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlockCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProtocolExecutionCountOutputTypeDefaultArgs instead
     */
    export type ProtocolExecutionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProtocolExecutionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantDefaultArgs instead
     */
    export type TenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProtocolDefaultArgs instead
     */
    export type ProtocolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProtocolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockDefaultArgs instead
     */
    export type BlockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlockDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockSessionDefaultArgs instead
     */
    export type BlockSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlockSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockProgressionDefaultArgs instead
     */
    export type BlockProgressionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlockProgressionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProtocolPermissionDefaultArgs instead
     */
    export type ProtocolPermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProtocolPermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProtocolTemplateDefaultArgs instead
     */
    export type ProtocolTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProtocolTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProtocolExecutionDefaultArgs instead
     */
    export type ProtocolExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProtocolExecutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockExecutionDefaultArgs instead
     */
    export type BlockExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlockExecutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionExecutionDefaultArgs instead
     */
    export type SessionExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionExecutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProtocolAnalyticsDefaultArgs instead
     */
    export type ProtocolAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProtocolAnalyticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProtocolShareDefaultArgs instead
     */
    export type ProtocolShareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProtocolShareDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}