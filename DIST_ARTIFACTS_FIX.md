# Fix Plan: Remove Dist Artifacts from PR#65

## Quick Diagnosis
```bash
# Verify dist files are tracked
git ls-files packages/*/dist/ | head -10

# Check which commit added them
git log --oneline --all -- packages/logger/dist/index.js
```

## Option A: Interactive Rebase (Clean History) âœ… RECOMMENDED

### Step 1: Start Interactive Rebase
```bash
# Rebase from the commit BEFORE the problematic one
git rebase -i 52f1a75^
```

### Step 2: In the Editor
You'll see:
```
pick 52f1a75 chore(phase3): add typed EventBus getters and Fastify augmentation
pick 87e3320 fix(fastify): resolve rebase conflict and add dist artifacts
pick e3b370b resolve merge conflict in fastify-augment.ts
```

**Change to:**
```
pick 52f1a75 chore(phase3): add typed EventBus getters and Fastify augmentation
edit 87e3320 fix(fastify): resolve rebase conflict and add dist artifacts
pick e3b370b resolve merge conflict in fastify-augment.ts
```

Save and exit.

### Step 3: Remove Dist Artifacts
```bash
# Git will pause at commit 87e3320
# Remove the dist artifacts from the index
git rm --cached -r packages/logger/dist packages/health-schema/dist

# Amend the commit without the dist files
git commit --amend --no-edit

# Continue the rebase
git rebase --continue
```

### Step 4: Verify and Push
```bash
# Verify dist files are no longer tracked
git ls-files packages/*/dist/
# Should return empty

# Check the diff
git diff origin/main...HEAD --name-only | grep dist
# Should return empty

# Force push (required after rebase)
git push origin integration/phase3-rebuild-bus-fastify --force-with-lease
```

---

## Option B: New Commit (Quick Fix) âš¡ FASTER

**Pros:**
- Simpler, no rebase needed
- No force push

**Cons:**
- Leaves "mistake + fix" commits in history

### Steps:
```bash
# Remove dist files from git tracking
git rm --cached -r packages/logger/dist packages/health-schema/dist

# Commit the removal
git commit -m "fix(git): remove accidentally tracked dist artifacts

Dist artifacts were accidentally committed during rebase (87e3320).
These are generated files and should not be tracked per .gitignore.

This fixes ESLint guardrail failures caused by:
- ESLint enumerating changed files including dist/**
- ESLint config ignoring dist/** â†’ generating warnings
- --max-warnings=0 gate â†’ exit code 123

Verified:
- .gitignore contains 'dist/'
- dist/ will be regenerated by build scripts
- No source files affected

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"

# Push to remote
git push origin integration/phase3-rebuild-bus-fastify
```

---

## Option C: CI Workflow Filter (Workaround) ðŸ”§ NOT RECOMMENDED

**Only if you can't modify the branch**

Add filter to `.github/workflows/eslint-guardrails.yml`:

```yaml
- name: Lint Changed Files Only
  run: |
    # Filter out dist artifacts before linting
    CHANGED_FILES=$(echo "$CHANGED_FILES" | grep -v "/dist/")
    if [ -z "$CHANGED_FILES" ]; then
      echo "No non-dist files to lint"
      exit 0
    fi
    npx eslint --config eslint.config.unified.mjs --max-warnings=0 $CHANGED_FILES
```

**Why not recommended:**
- Doesn't fix root cause
- dist files still waste repo space
- Future rebases may have same issue

---

## Verification Steps

After applying fix:

### 1. Check Git Tracking
```bash
git ls-files packages/*/dist/
# Expected: (empty)

git status
# Expected: packages/*/dist/ listed as untracked (if they exist locally)
```

### 2. Check .gitignore Works
```bash
echo "test" > packages/logger/dist/test.txt
git status
# Expected: packages/logger/dist/ NOT shown (ignored)
```

### 3. Verify Build Still Works
```bash
npm run build:packages
ls -la packages/logger/dist/ packages/health-schema/dist/
# Expected: Dist files regenerated successfully
```

### 4. Check ESLint Guardrail Locally
```bash
# Simulate CI check
CHANGED_FILES=$(git diff origin/main...HEAD --name-only --diff-filter=ACMRT | grep -E '\.(ts|tsx|js|jsx)$')
echo "$CHANGED_FILES" | grep dist
# Expected: (empty - no dist files in changed list)

npx eslint --config eslint.config.unified.mjs --max-warnings=0 $CHANGED_FILES
# Expected: Success, 0 warnings
```

### 5. Monitor CI
```bash
gh pr checks 65 --watch
# Expected: "Lint Changed Files Only" passes
```

---

## Success Criteria

âœ… `git ls-files packages/*/dist/` returns empty
âœ… `git status` shows dist/ as untracked (if exists locally)
âœ… ESLint guardrail job passes (exit code 0)
âœ… No "File ignored..." warnings in CI logs
âœ… Build scripts regenerate dist/ successfully

---

## Prevention for Future

### Add Pre-commit Hook (Optional)
```bash
# .githooks/pre-commit
#!/bin/bash
if git diff --cached --name-only | grep -q "dist/"; then
  echo "âŒ ERROR: Attempting to commit dist/ artifacts"
  echo "Dist files are generated and should not be tracked"
  echo "Run: git reset HEAD packages/*/dist/"
  exit 1
fi
```

Enable:
```bash
git config core.hooksPath .githooks
chmod +x .githooks/pre-commit
```

### Update CI Documentation
Add to `docs/ci/code-quality-policy.md`:

> **Important:** Never commit generated dist/ artifacts. The ESLint guardrail will fail with "File ignored..." warnings. If accidentally committed, remove with `git rm --cached -r packages/*/dist`.

---

## Troubleshooting

**Q: Dist files still show up after `git rm --cached`?**
```bash
# Check if files are in .gitignore
grep dist .gitignore

# Force remove
git rm -r --cached packages/*/dist/
git commit --amend --no-edit
```

**Q: Rebase conflicts?**
```bash
# Abort and use Option B instead
git rebase --abort

# Or resolve conflicts and continue
git add <resolved-files>
git rebase --continue
```

**Q: CI still fails after fix?**
```bash
# Check if dist files are truly gone
git ls-files | grep dist/

# Check CI job logs for actual error
gh pr checks 65 --json name,conclusion,detailsUrl
```

---

## Timeline
- **Option A (Interactive Rebase):** ~5 minutes
- **Option B (New Commit):** ~2 minutes
- **CI Validation:** ~2-3 minutes after push

## Recommended: Option B (Quick Fix)
For this situation, Option B is fastest and safest. The history is already public (PR opened), so a clean rebase provides minimal benefit vs. risk.
